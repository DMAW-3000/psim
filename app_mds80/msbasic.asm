
	ORG 0100H

;---------------------------------------------------------------------------

	SECTION BINTRP
;
;
;--------- ---- -- ---- ----- --- ---- -----
;COPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN
;--------- ---- -- ---- ----- --- ---- -----
;
;ORIGINALLY WRITTEN ON THE PDP-10 FROM
;FEBRUARY 9 TO  APRIL 9 1975
;
;BILL GATES WROTE A LOT OF STUFF.
;PAUL ALLEN WROTE OTHER STUFF AND FAST CODE.
;MONTE DAVIDOFF WROTE THE MATH PACKAGE (F4I.MAC).
;
;*
	
	PUBLIC TOPMEM, MEMSIZ, FRETOP
	PUBLIC CURLIN, DATLIN
	PUBLIC CNTOFL
	PUBLIC LPTPOS
	PUBLIC CHRGTR, CHRCON
	PUBLIC SNERR, FCERR
	PUBLIC ERRST, ERRSO
	PUBLIC ENDBUF
	PUBLIC MAXREC
	PUBLIC TEMPST, TEMPPT, TEMP8, TEMP9
	PUBLIC CONSAV, CONTXT, CONLO, CONTYP
	PUBLIC TXTTAB, ARYTAB, ARYTA2, VARTAB
	PUBLIC VALTYP
	PUBLIC ERROR
	PUBLIC STREND
	PUBLIC FACLO
	PUBLIC PRTFLG
	
CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR

BUFOFS	SET	0
BUFOFS	SET	2			;MUST CRUNCH INTO EARLIER PLACE FOR SINGLE QUOTE
KBFLEN	SET	BUFLEN+(BUFLEN/4)	;MAKE KRUNCH BUFFER SOMEWHAT
					;LARGER THAN SOURCE BUFFER (BUF)
	
	PUBLIC	START
START:
	PUBLIC	JMPINI
JMPINI:	JMP	INIT			;INIT IS THE INTIALIZATION ROUTINE

ERRTAB:
	DB	0
Q	SET	0
Q	SET	Q+1
	DB	'NEXT without FOR',0
ERRNF	SET	Q
Q	SET	Q+1
	DB	'Syntax error',0
ERRSN	SET	Q
Q	SET	Q+1
	DB	'RETURN without GOSUB',0
ERRRG	SET	Q
Q	SET	Q+1
	DB	'Out of DATA',0
ERROD	SET	Q
Q	SET	Q+1
	DB	'Illegal function call',0
ERRFC	SET	Q
	PUBLIC	OVRMSG
OVRMSG:
Q	SET	Q+1
	DB	'Overflow',0
ERROV	SET	Q
Q	SET	Q+1
	DB	'Out of memory',0
	PUBLIC	ERROM
ERROM	SET	Q
Q	SET	Q+1
	DB	'Undefined line number',0
ERRUS	SET	Q
Q	SET	Q+1
	DB	'Subscript out of range',0
ERRBS	SET	Q
Q	SET	Q+1
	DB	'Duplicate Definition',0
ERRDD	SET	Q
	PUBLIC	DIVMSG
DIVMSG:
Q	SET	Q+1
	DB	'Division by zero',0
ERRDV0	SET	Q
Q	SET	Q+1
	DB	'Illegal direct',0
ERRID	SET	Q
Q	SET	Q+1
	DB	'Type mismatch',0
ERRTM	SET	Q
Q	SET	Q+1
	DB	'Out of string space',0
ERRSO	SET	Q
Q	SET	Q+1
	DB	'String too long',0
ERRLS	SET	Q
Q	SET	Q+1
	DB	'String formula too complex',0
ERRST	SET	Q
Q	SET	Q+1
	DB	'Can\'t continue',0
ERRCN	SET	Q
Q	SET	Q+1
	DB	'Undefined user function',0
ERRUF	SET	Q
Q	SET	Q+1
	DB	'No RESUME',0
ERRNR	SET	Q
Q	SET	Q+1
	DB	'RESUME without error',0
ERRRE	SET	Q
Q	SET	Q+1
	DB	'Unprintable error',0
ERRUE	SET	Q
Q	SET	Q+1
	DB	'Missing operand',0
ERRMO	SET	Q
	PUBLIC	ERRLBO
Q	SET	Q+1
	DB	'Line buffer overflow',0
ERRLBO	SET	Q

Q	SET	Q+1
	DB	'?',0
Q	SET	Q+1
	DB	'?',0
Q	SET	Q+1
	DB	'FOR Without NEXT',0
ERRFN	SET	Q
Q	SET	Q+1
	DB	'?',0
Q	SET	Q+1
	DB	'?',0
Q	SET	Q+1
	DB	'WHILE without WEND',0
ERRWH	SET	Q
Q	SET	Q+1
	DB	'WEND without WHILE',0
ERRWE	SET	Q
Q	SET	Q+1
	DB	'Graphics statement not implemented',0
ERRGS	SET	Q
NONDSK	SET	Q			;LAST NON DISK ERROR.

Q	SET	49			;DISK ERRORS START AT 50.
DSKERR	SET	Q			;FIRST DISK ERROR
Q	SET	Q+1
	DB	'FIELD overflow',0
	PUBLIC	ERRFOV
ERRFOV	SET	Q
Q	SET	Q+1
	DB	'Internal error',0
	PUBLIC	ERRIER
ERRIER	SET	Q
Q	SET	Q+1
	DB	'Bad file number',0
	PUBLIC	ERRBFN
ERRBFN	SET	Q
Q	SET	Q+1
	DB	'File not found',0
	PUBLIC	ERRFNF
ERRFNF	SET	Q
Q	SET	Q+1
	DB	'Bad file mode',0
ERRBFM	SET	Q
Q	SET	Q+1
	DB	'File already open',0
ERRFAO	SET	Q
Q	SET	Q+1
	DB	'?',0			;PAD IN HOLE
DSKLOC	SET	$+6
Q	SET	Q+1
	DB	'Disk I/O error',0
ERRIOE	SET	Q
Q	SET	Q+1
	DB	'File already exists',0
ERRFAE	SET	Q
Q	SET	Q+1
	DB	'?',0
Q	SET	Q+1
	DB	'?',0			;PAD IN HOLE
Q	SET	Q+1
	DB	'Disk full',0
ERRDFL	SET	Q
Q	SET	Q+1
	DB	'Input past end',0
ERRRPE	SET	Q
Q	SET	Q+1
	DB	'Bad record number',0
ERRBRN	SET	Q
Q	SET	Q+1
	DB	'Bad file name',0
ERRNMF	SET	Q
Q	SET	Q+1
	DB	'?',0
ERRMMM	SET	Q
Q	SET	Q+1
	DB	'Direct statement in file',0
	PUBLIC	ERRFDR
ERRFDR	SET	Q
Q	SET	Q+1
	DB	'Too many files',0
ERRTMF	SET	Q

LSTERR	SET	Q+1			;LAST ERROR USED FOR RANGE CHECKS IN LEN2

	PUBLIC	NULCNT
NULCNT:	DB	1			;STORE HERE THE NUMBER OF NULLS
					;TO PRINT AFTER CRLF
	PUBLIC	CHARC
CHARC:	DB	0			;ISCNTC STORES EATEN CHAR HERE WHEN NOT A ^C
	PUBLIC	ERRFLG
ERRFLG:	DB	0			;USED TO SAVE THE ERROR NUMBER SO EDIT CAN BE
					;CALLED ON "SYNTAX ERROR"
	PUBLIC	LPTLST
LPTLST:	DB	0			;LAST LINE PRINTER OPERATION. ZERO MEANS LINEFEED
					;NON-ZERO MEANS PRINT COMMAND (OKIA ONLY)
LPTPOS:	DB	1			;POSITION OF LPT PRINT HEAD
PRTFLG:	DB	0			;WHETHER OUTPUT GOES TO LPT
	PUBLIC	NLPPOS,LPTSIZ
LNCMPS	SET	(((LPTLEN/CLMWID)-1)*CLMWID);LAST COMMA FIELD POSIT
NLPPOS:	DB	LNCMPS			;LAST COL # BEYOND WHICH NO MORE COMMA FIELDS
LPTSIZ:	DB	LPTLEN			;DEFAULT LINE PRINTER WIDTH
	PUBLIC	LINLEN
LINLEN:	DB	LINLN			;LINE LENGTH
NCMPOS	SET	(((LINLN/CLMWID)-1)*CLMWID);POSITION BEYOND WHICH THERE ARE
					;NO MORE COMMA FIELDS	
CLMLST:	DB	NCMPOS			;POSITION OF LAST COMMA COLUMN
					;NON-ZERO MEANS SEND OUTPUT TO LPT
	PUBLIC	RUBSW
RUBSW:	DB	0			;RUBOUT SWITCH =1 INSIDE
					;THE PROCESSING OF A RUBOUT (INLIN)
CNTOFL:	DB	0			;SUPRESS OUTPUT FLAG
					;NON-ZERO MEANS SUPRESS
					;RESET BY "INPUT",READY AND ERRORS
					;COMPLEMENTED BY INPUT OF ^O
	PUBLIC	PTRFIL
PTRFIL:	DW	0			;POINTER TO DATA BLOCK OF CURRENT FILE
					;USED BY DISK AND NCR CASSETTE CODE

TOPMEM:
	DW	TSTACK+100		;TOP LOCATION TO USE FOR THE STACK
					;INITIALLY SET UP BY INIT
					;ACCORDING TO MEMORY SIZE
					;TO ALLOW FOR 50 BYTES OF STRING SPACE.
					;CHANGED BY A CLEAR COMMAND WITH
					;AN ARGUMENT.
CURLIN:	DW	0+65534			;CURRENT LINE #
					;SET TO 65534 IN PURE VERSION DURING INIT EXECUTION
					;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
TXTTAB:	DW	TSTACK+1		;POINTER TO BEGINNING OF TEXT
					;DOESN'T CHANGE AFTER BEING
					;SETUP BY INIT.
					
;
;	END OF INITIALIZED PART OF RAM
;
;
; DISK DATA STORAGE AREA
;
	PUBLIC	LSTFRE,MAXTRK,DSKMOD,FILPT1,FILPTR,MAXFIL
LSTFRE:	DW	0			;FREE PLACE IN DIRECTORY
MAXTRK:	DB	0			;ALLOCATE INSIDE THIS TRACK
DSKMOD:	DB	0			;MODE OF FILE JUST LOOKED UP
					;ZERO IF FILE WAS JUST CREATED
FILPT1:	DW	0			;[FILPTR] ALWAYS REFETCHED FROM HERE
FILPTR:	DB  32 DUP(0)			;POINTERS TO DATA BLOCKS FOR EACH FILE
MAXFIL:	DB	0			;HIGHEST FILE NUMBER ALLOWED
	PUBLIC	NAMCNT,NAMBUF,NAMTMP
NAMCNT:	DB	0			;THE NUMBER OF CHARACTER BEYOND #2 IN A VAR NAME
NAMBUF:	DB	NAMLEN-2 DUP(0)		;STORAGE FOR CHARS BEYOND #2. USED IN PTRGET
NAMTMP:	DW	0			;TEMP STORAGE DURING NAME SAVE AT INDLOP
	PUBLIC	DIRTMP,FILNA2,FILNAM
DIRTMP	SET	CPMWRM+128		;USE CPM DEFAULT BUFFER IN LOW MEMORY
FILNA2:	DB	16	DUP(0)		;USED BY NAME CODE
FILNAM:	DB	33	DUP(0)		;BECAUSE CPM MUST HAVE BUFFER FOR DIRECTORY READS

;	CP/M 1.4 and 2.x Support

	PUBLIC	CPMVRN,CPMREA,CPMWRI

CPMVRN:	DB  0			;CP/M Version Number (#0 is 2.x)
CPMREA:	DB  0			;CP/M Read Call
CPMWRI:	DB  0			;CP/M Write Call
	DB	':'			;a colon for restarting input
KBUF:	DB 	KBFLEN	DUP(0)	;THIS IS THE KRUNCH BUFFER
	PUBLIC	BUFMIN
BUFMIN:	DB	44			;A COMMA (PRELOAD OR ROM)
					;USED BY INPUT STATEMENT SINCE THE
					;DATA POINTER ALWAYS STARTS ON A
					;COMMA OR TERMINATOR
BUF:	DB	BUFLEN+1 DUP(0)		;TYPE IN STORED HERE
					;DIRECT STATEMENTS EXECUTE OUT OF
					;HERE. REMEMBER "INPUT" SMASHES BUF.
					;MUST BE AT A LOWER ADDRESS
					;THAN DSCTMP OR ASSIGNMENT OF STRING
					;VALUES IN DIRECT STATEMENTS WON'T COPY
					;INTO STRING SPACE -- WHICH IT MUST
	DW  0			;ALLOW FOR SINGLE QUOTE IN BIG LINE
ENDBUF:	DB  0			;PLACE TO STOP BIG LINES
	PUBLIC	TTYPOS
TTYPOS:	DB  0			;STORE TERMINAL POSITION HERE
DIMFLG:	DB  0			;IN GETTING A POINTER TO A VARIABLE
					;IT IS IMPORTANT TO REMEMBER WHETHER IT
					;IS BEING DONE FOR "DIM" OR NOT
					;DIMFLG AND VALTYP MUST BE
					;CONSECUTIVE LOCATIONS
VALTYP:	DB  0			;THE TYPE INDICATOR
					;IN THE 8K 0=NUMERIC 1=STRING
OPRTYP:					;USED TO STORE OPERATOR NUMBER
					;IN THE EXTENDED MOMENTARILY BEFORE
					;OPERATOR APPLICATION (APPLOP)
DORES:	DB  0			;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS
					;TURNED ON IN THE 8K WHEN "DATA"
					;BEING SCANNED BY CRUNCH SO UNQUOTED
					;STRINGS WON'T BE CRUNCHED.
DONUM:	DB  0			;FLAG FOR CRUNCH =0 MEANS
					;NUMBERS ALLOWED, (FLOATING,INT, DBL)
					;1 MEANS NUMBERS ALLOWED, KRUNCH BY CALLING LINGET
					;-1 (377) MEANS NUMBERS DISALLOWED 
					;(SCANNING VARIABLE NAME)
CONTXT:	DW  0			;SAVED TEXT POINTER USED BY CHRGET
					;TO SAVE THE TEXT POINTER AFTER CONSTANT
					;HAS BEEN SCANNED.
CONSAV:	DB  0			;THE SAVED TOKEN FOR A CONSTANT
					;AFTER CHRGET HAS BEEN CALLED
CONTYP:	DB  0			;SAVED CONSTANT VALTYPE
CONLO:	DD  0			;SAVED CONSTANT VALUE
	DD 0			;EXTRA FOUR BYTES FOR DOUBLE PRECISION
MEMSIZ:	DW  0			;HIGHEST LOCATION IN MEMORY
TEMPPT:	DW  0			;POINTER AT FIRST FREE TEMP DESCRIPTOR
					;INITIALIZED TO POINT TO TEMPST
TEMPST:	DB	STRSIZ*NUMTMP  DUP(0)	;STORAGE FOR NUMTMP TEMP DESCRIPTORS
	PUBLIC	DSCTMP,DSCPTR
DSCTMP:	DB	STRSIZ	DUP(0)		;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
					;MUST BE AFTER TEMPST AND BEFORE PARM1
DSCPTR	SET	$-2			;WHERE STRING ADDRESS IS STORE IN DSCTMP
FRETOP:	DW  0			;TOP OF STRING FREE SPACE
TEMP3:	DW  0		;USED TO STORE THE ADDRESS OF THE END OF
					;STRING ARRAYS IN GARBAGE COLLECTION
					;AND USED MOMENTARILY BY FRMEVL
					;USED IN EXTENDED BY FOUT AND
					;USER DEFINED FUNCTIONS
					;ARRAY VARIABLE HANDLING TEMPORARY
TEMP8:	DW  0			;7/3/79 Now used by garbage collection
					;not TEMP3 due to conflict
ENDFOR:	DW  0			;SAVED TEXT POINTER AT END OF "FOR" STATEMENT
DATLIN:	DW  0			;DATA LINE # -- REMEMBER FOR ERRORS
SUBFLG:	DB  0			;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED
					;"FOR" AND USER-DEFINED FUNCTION
					;POINTER FETCHING TURN
					;THIS ON BEFORE CALLING PTRGET
					;SO ARRAYS WON'T BE DETECTED.
					;STKINI AND PTRGET CLEAR IT.
	PUBLIC	USFLG
USFLG:
FLGINP:	DB  0			;FLAGS WHETHER WE ARE DOING "INPUT"
					;OR A READ
	PUBLIC	TEMP
TEMP:	DW  0			;TEMPORARY FOR STATEMENT CODE
					;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C
					;"LET" SAVES VARIABLE
					;POINTERS HERE FOR "FOR"
					;"NEXT" SAVES ITS TEXT POINTER HERE
					;CLEARC SAVES [H,L] HERE
	PUBLIC	PTRFLG
PTRFLG:	DB  0			;=0 IF NO LINE NUMBERS CONVERTED
					;TO POINTERS, NON ZERO IF POINTERS EXIST.
	PUBLIC	AUTFLG
AUTFLG:	DB  0			;FLAG TO INICATE AUTO COMMAND IN
					;PROGRESS =0 IF NOT, NON-ZERO IF SO.
AUTLIN:	DW  0			;CURRENT LINE BEING INSERTED BY AUTO
AUTINC:	DW  0			;THE AUTO INCREMENT
SAVTXT:	DW  0			;PLACE WHERE NEWSTT SAVES TEXT POINTER
					;FOR "RESUME" STATEMENT
	PUBLIC	SAVSTK,ERRLIN
SAVSTK:	DW  0			;NEWSTT SAVES STACK HERE BEFORE
					;SO THAT ERROR REVERY CAN
					;CAN RESTORE THE STACK WHEN AN
					;ERROR OCCURS
ERRLIN:	DW  0			;LINE NUMBER WHERE LAST ERROR OCCURED.
	PUBLIC	DOT
DOT:	DW  0			;KEEPS CURRENT LINE FOR EDIT & LIST
ERRTXT:	DW  0			;TEXT POINTER FOR USE BY "RESUME"
	PUBLIC	ONELIN
ONELIN:	DW  0			;THE LINE TO GOTO WHEN AN ERROR 
					;OCCURS
ONEFLG:	DB  0			;ONEFLG=1 IF WERE ARE EXECUTING
					;AN ERROR TRAP ROUTINE, OTHERWISE 0
TEMP2:	DW  0			;FORMULA EVALUATOR TEMP
					;MUST BE PRESERVED BY OPERATORS
					;USED IN EXTENDED BY FOUT AND
					;USER-DEFINED FUNCTIONS
					;ARRAY VARIABLE HANDLER TEMPORARY
OLDLIN:	DW  0			;OLD LINE NUMBER (SETUP BY ^C,"STOP"
					;OR "END" IN A PROGRAM)
OLDTXT:	DW  0			;OLD TEXT POINTER
					;POINTS AT STATEMENT TO BE EXECUTED NEXT
VARTAB:	DW  0			;POINTER TO START OF SIMPLE
					;VARIABLE SPACE
					;UPDATED WHENEVER THE SIZE OF THE
					;PROGRAM CHANGES, SET TO [TXTTAB]
					;BY SCRATCH ("NEW").
ARYTAB:	DW  0			;POINTER TO BEGINNING OF ARRAY
					;TABLE
					;INCREMENTED BY 6 WHENEVER
					;A NEW SIMPLE VARIABLE IS FOUND, AND
					;SET TO [VARTAB] BY CLEARC.
STREND:	DW  0			;END OF STORAGE IN USE
					;INCREASED WHENEVER A NEW ARRAY
					;OR SIMPLE VARIABLE IS ENCOUNTERED
					;SET TO [VARTAB] BY CLEARC.
DATPTR:	DW  0			;POINTER TO DATA. INITIALIZED TO POINT
					;AT THE ZERO IN FRONT OF [TXTTAB]
					;BY "RESTORE" WHICH IS CALLED BY CLEARC
					;UPDATED BY EXECUTION OF A "READ"
DEFTBL:	DB	26	DUP(0)		;THIS GIVES THE DEFAULT VALTYP FOR EACH
					;LETTER OF THE ALPHABET
					;IT IS SET UP BY "CLEAR" AND CHANGED BY
					;"DEFSTR" "DEFINT" "DEFSNG" "DEFDBL" AND USED
					;BY PTRGET WHEN ! # % OR $ DON'T FOLLOW
					;A VARAIBLE NAME
;
; RAM STORAGE FOR USER DEFINED FUNCTION PARAMETER INFORMATION
;
	PUBLIC	PRMPRV,PRMSTK		;ALLOW INIT TO INITIALIZE THIS CONSTANT
PRMSIZ	SET	100			;NUMBER OF BYTES FOR DEFINITION BLOCK
PRMSTK:	DW	0			;PREVIOUS DEFINITION BLOCK ON STACK
					;BLOCK (FOR GARBAGE COLLECTION)
PRMLEN:	DW  0			;THE NUMBER OF BYTES IN THE ACTIVE TABLE
PARM1:	DB	PRMSIZ  DUP(0)		;THE ACTIVE PARAMETER DEFINITION TABLE
PRMPRV:	DW	PRMSTK			;THE POINTER AT THE PREVIOUS PARAMETER
					;BLOCK (FOR GARBAGE COLLECTION)
PRMLN2:	DW  0			;SIZE OF PARAMETER BLOCK BEING BUILT
PARM2:	DB	PRMSIZ  DUP(0)			;PLACE TO KEEP PARAMETERS BEING MADE
PRMFLG:	DB  0			;USED BY PTRGET TO FLAG IF PARM1 HAS BEEN SEARCHED
ARYTA2:	DW  0			;STOPPING POINT FOR SIMPLE SEARCH
					;(EITHER [ARYTAB] OR PARM1+[PRMLEN])
NOFUNS:	DB  0			;ZERO IF NO FUNCTIONS ACTIVE. SAVES TIME IN SIMPLE SEARCH
TEMP9:	DW  0			;GARBAGE COLLECTION TEMP TO CHAIN THROUGH PARAMETER BLOCKS
FUNACT:	DW  0			;COUNT OF ACTIVE FUNCTIONS
	PUBLIC	INPPAS,NXTTXT,NXTFLG,FVALSV,NXTLIN,OPTVAL,OPTFLG
INPPAS:	DB  0			;FLAG TELLING WHETHER INPUT IS SCANNING FIRST OR
					;SECOND TIME. ZERO IF FIRST.
NXTTXT:	DW  0			;USED TO SAVE TEXT POINTER AT START OF NEXT
NXTFLG:	DB  0			;ZERO IF "FOR" IS USING NEXT CODE
					;TO CHECK FOR EMPTY LOOP
FVALSV:	DD  0			;USE TO STORE THE START VALUE OF THE LOOP VARIABLE
					;SINCE ANSI SAYS START AND END ARE EVALUATED
					;BEFORE ASSIGNMENT TAKES PLACE
NXTLIN:	DW  0			;THE LINE NUMBER DURING SCAN FOR "NEXT"
OPTVAL:	DB  0			;ZERO FOR OPTION BASE 0 ONE FOR OPTION BASE 1
OPTFLG:	DB  0			;NON-ZERO IF "OPTION BASE" HAS BEEN SCANNED
	PUBLIC	PATCH
PATCH:	DB	30	DUP(0)		;THIRTY BYTES OF PATCH SPACE
	PUBLIC	TEMPA
TEMPA:	DW  0			;MISC TEMP USED BY CALL AND LIST
	PUBLIC	SAVFRE
SAVFRE:	DW  0			;FRETOP SAVED HERE BY CHAIN
	PUBLIC	MAXREC
MAXREC:	DW  0			;MAXIMUM RECORD SIZE
	PUBLIC	PROFLG
PROFLG:	DB  0			;NON-ZERO IF WE HAVE LOADED A PROTECTED FILE W/O PASSWRD
	PUBLIC	CHNFLG,CHNLIN,MDLFLG,MRGFLG,CMEPTR,CMSPTR
MRGFLG:	DB  0			;NON-ZERO IF CHAIN W/ MERGE IN PROGRESS
MDLFLG:	DB  0			;NON-ZERO I CHAIN W/ MERGE AND DELETE IN PROGRESS
CMEPTR:	DW  0			;POINTER TTO END LINE TO DELETE
CMSPTR:	DW  0			;POINTER TO START LINE TO DELETE
CHNFLG:	DB  0			;NON-ZERO IF CHAIN IN PROGRESS
CHNLIN:	DW  0			;DESTINATION LINE IN NEW PROGRAM
	PUBLIC	SWPTMP
SWPTMP:	DD  0			;VALUE OF FIRST "SWAP" VARIABLE STORED HERE
	DD 9			;ENOUGH ROOM FOR DOUBLE PRECISION
TRCFLG:	DB  0			;ZERO MEANS NO TRACE IN PROGRESS

; THIS IS THE RAM TERMPORARY AREA FOR THE MATH PACKAGE ROUTINES
;
;THE FLOATING ACCUMULATOR
	DB  0			;[TEMPORARY LEAST SIGNIFICANT BYTE]
DFACLO:	DD  0			;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
FACLO:	DW  0
	DB  0
					;[MIDDLE ORDER OF MANTISSA]
					;[HIGH ORDER OF MANTISSA]
FAC:	DW  0			;[EXPONENT]
					;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
	PUBLIC	FANSII
	PUBLIC	FLGOVC,OVCSTR
FLGOVC:	DB  0			;OVERFLOW PRINT FLAG,=0,1 PRINT 
					;FURTHER =1 CHANGE TO 2
OVCSTR:	DB  0			;PLACE TO STORE OVERFLOW FLAG AFTER FIN
FANSII:	DB  0			;FLAG TO FORCE FIXED OUTPUT (SEE ANSI)
	DB  0			;[TEMPORARY LEAST SIGNIFICANT BYTE]
ARGLO:	DB  7  DUP(0)			;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
ARG:	DB  0			; PRECISION]
					;FOR INTEL FORMATS MUST HAVE SPACE FOR
					;11 BITS OF EXPONENT
FBUFFR:	DB	13  DUP(0)		;BUFFER FOR FOUT

	DB	43-13	DUP(0)		;THE LAST 3 LOCATIONS ARE TEMP FOR ROM FMULT
	PUBLIC	FMLTT1,FMLTT2
FMLTT1	SET	FBUFFR+40
FMLTT2	SET	FBUFFR+41
					
	PUBLIC	DERDFL
DERDFL:	MVI	E,ERRDFL
	DB	1			;"DISK FULL"
	PUBLIC	DERIOE
DERIOE:	MVI	E,ERRIOE
	DB	1			;"DISK I/O ERROR"
	PUBLIC	DERBFM
DERBFM:	MVI	E,ERRBFM
	DB	1			;"BAD FILE MODE"
	PUBLIC	DERFNF
DERFNF:	MVI	E,ERRFNF
	DB	1			;"FILE NOT FOUND"
	PUBLIC	DERBFN
DERBFN:	MVI	E,ERRBFN
	DB	1			;"BAD FILE NUMBER"
	PUBLIC	DERIER
DERIER:	MVI	E,ERRIER
	DB	1			;"INTERNAL ERROR"
	PUBLIC	DERRPE
DERRPE:	MVI	E,ERRRPE
	DB	1			;"READ PAST END"
	PUBLIC	DERFAO
DERFAO:	MVI	E,ERRFAO
	DB	1			;"FILE ALREADY OPEN"
	PUBLIC	DERNMF
DERNMF:	MVI	E,ERRNMF
	DB	1			;"BAD FILE NAME"
	PUBLIC	DERBRN
DERBRN:	MVI	E,ERRBRN
	DB	1			;"BAD RECORD NUMBER"
	PUBLIC	DERFOV
DERFOV:	MVI	E,ERRFOV
	DB	1			;"FIELD OVERFLOW"
	PUBLIC	DERTMF
DERTMF:	MVI	E,ERRTMF
	DB	1			;"TOO MANY FILES"
	PUBLIC	DERFAE
DERFAE:	MVI	E,ERRFAE
	JMP	ERROR			;"FILE ALREADY EXISTS"
DATSNE:	LHLD	DATLIN			;GET DATA LINE
	SHLD	CURLIN			;MAKE IT CURRENT LINE
SNERR:	MVI	E,ERRSN			;"SYNTAX ERROR"
	DB	1Q			;"LXI B," OVER THE NEXT 2
DV0ERR:	MVI	E,ERRDV0		;DIVISION BY ZERO
	DB	1Q			;"LXI B," OVER THE NEXT 2
NFERR:	MVI	E,ERRNF			;"NEXT WITHOUT FOR" ERROR
	PUBLIC	DDERR
	DB	1Q			;"LXI B," OVER THE NEXT TWO BYTES
DDERR:	MVI	E,ERRDD			;"REDIMENSIONED VARIABLE"
	DB	1Q			;"LXI B," OVER THE NEXT 2 BYTES
UFERR:	MVI	E,ERRUF			;"UNDEFINED FUNCTION" ERROR
	DB	1Q			;"LXI B," OVER THE NEXT TWO
REERR:	MVI	E,ERRRE			;"RESUME WITHOUT ERROR"
	DB	1Q			;"LXI B," OVER THE NEXT TWO
OVERR:	MVI	E,ERROV			;SET OVERFLOW ERROR CODE
	DB	1Q			;"LXI B," OVER NEXT TWO
MOERR:	MVI	E,ERRMO			;TYPE MISMATCH ERROR
	DB	1Q			;"LXI	B," OVER THE NEXT TWO
TMERR:	MVI	E,ERRTM			;TYPE MISMATCH ERROR
ERROR:
	; TODO - implement ERROR
	HLT
				
FCERR:	MVI	E,ERRFC			;TOO BIG. FUNCTION CALL ERROR
	JMP	ERROR
	
;
; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]
; ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS
; LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO
; IT CAN MERELY DO A RETURN WHEN IT IS DONE.
;
NEWSTT:
	PUSH	H
	PUBLIC	CONST2,CSTS
CSTS	SET	0
CONST2:	CALL	CSTS			;GET CONSOLE STATUS

CHRGTR:	INX	H			;DUPLICATION OF CHRGET RST FOR SPEED
	PUBLIC	CHRGT2
CHRGT2:	MOV	A,M			;SEE CHRGET RST FOR EXPLANATION
	CPI	':'
	RNC	
	
;
; CHRCON IS THE CONTINUATION OF THE CHRGET RST
;
; IN EXTENDED, CHECK FOR INLINE CONSTANT AND IF ONE
; MOVE IT INTO THE FAC & SET VALTYP APPROPRIATELY
OCTCON	SET	11			;EMBEDED OCTAL CONSTANT
HEXCON	SET	12			;EMBEDED CONSTANT
PTRCON	SET	13			;A LINE REFERENCE CONSTANT
LINCON	SET	14			;A LINE NUMBER UNCONVERTED TO POINTER
IN2CON	SET	15			;SINGLE BYTE (TWO BYTE WITH TOKEN) INTEGER
CONCN2	SET	16			;TOKEN RETURNED SECOND TYPE CONSTANT IS SCANNED.
ONECON	SET	17			;FIRST OF 10 (0-9) INTEGER SPECIAL TOKENS
INTCON	SET	28			;REGULAR 16 BIT TWO'S COMPLEMENT INT
SNGCON	SET	29			;SINGLE PREC (4 BYTE) CONSTANT
CONCON	SET	30			;TOKEN RETURNED BY CHRGET AFTER CONSTANT SCANNED
DBLCON	SET	31			;DOUBLE PREC (8 BYTE) CONSTANT
CHRCON:	CPI	' '			;MUST SKIP SPACES
	JZ	CHRGTR			;GET ANOTHER CHARACTER
	JNC	NOTLFT			;NOT SPECIAL TRY OTHER POSSIB.
	ORA	A			;NULL AT EOL?
	RZ				;YES, ALL DONE
	CPI	OCTCON			;IS IT INLINE CONSTANT
	JC	NOTCON			;NO, SHOULD BE TAB OR LF
	CPI	CONCON			;ARE WE TRYING TO RE-SCAN A CONSTANT?
	JNZ	NTRSCC			;NO.
	LDA	CONSAV			;GET THE SAVED CONSTANT TOKEN
	ORA	A			;SET NON-ZERO, NON CARRY CC'S
	RET				;ALL DONE

NTRSCC:	CPI	CONCN2			;GOING TO SCAN PAST EMBEDDED CONSTANT?
	JNZ	NTRSC2			;NO, TRY OTHER CASES
CONSCN:	LHLD	CONTXT			;GET SAVED TEXT POINTER
	JMP	CHRGT2			;AND SCAN THING AFTER CONSTANT
NTRSC2:	PUSH	PSW			;SAVE TOKEN TO RETURN
	INX	H			;POINT TO NUMBER
	STA	CONSAV			;SAVE CURRENT TOKEN
	SUI	INTCON			;IS IT LESS THAN INTEGER CONSTANT?
	JNC	MAKTKN			;NO, NOT LINE NUMBER CONSTANT
	SUI	365O			;<ONECON-INTCON>&^O377
					;LESS THAN EMBEDDED 1 BYTER
	JNC	ONEI			;WAS ONE BYTER
	CPI	IN2CON-ONECON		;IS IT TWO BYTER?
	JNZ	FRCINC			;NOPE, NORMAL INT
	MOV	A,M			;GET EMBEDED INT
	INX	H			;POINT AFTER CONSTANT
ONEI:	SHLD	CONTXT			;SAVE TEXT POINTER
	MVI	H,0			;GET UPPER BYTE OF ZERO
ONEI2:	MOV	L,A			;GET VALUE
	SHLD	CONLO			;SAVE CONSTANT VALUE
	MVI	A,2			;GET VALTYPE
	STA	CONTYP			;SET IT UP IN SAVE PLACE
	LXI	H,NUMCON		;POINT TO NUMBER RE-SCANNER
	POP	PSW			;GET BACK TOKEN
	ORA	A			;MAKE SURE NUMBER FLAG RE-SET
	RET				;RETURN TO CALLER

FRCINC:	MOV	A,M			;GET LOW BYTE OF CONSTANT
	INX	H			;POINT PAST IT
	INX	H			;TO NEXT THING
	SHLD	CONTXT			;SAVE POINTER PAST
	DCX	H			;BACK TO HIGH BYTE
	MOV	H,M			;GET HIGH BYTE
	JMP	ONEI2			;FINISH SCANNING
MAKTKN:	INR	A			;CALCULATE VALTYPE
	RLC				;*2 TO GET VALTYPE 0=2, 1=4, 3=8
	STA	CONTYP			;CONTYPE NOW SETUP
	PUSH	D			;SAVE SOME RGS
	PUSH	B
	LXI	D,CONLO			;PLACE TO STORE SAVED CONSTANT
	XCHG				;GET TEXT POINTER IN [D,E]
	MOV	B,A			;SETUP COUNTER IN [B]
	CALL	MOVE1			;MOVE DATA IN
	XCHG				;GET TEXT POINTER BACK
	POP	B			;RESTORE [B,C]
	POP	D
FININ1:	SHLD	CONTXT			;SAVE THE GOOD TEXT POINTER
	POP	PSW			;RESTORE TOKEN
	LXI	H,NUMCON		;GET POINTER TO FAKE TEXT
	ORA	A			;CLEAR CARRY SO OTHERS DONT THINK ITS A NUMBER
					;AND SET NON-ZERO SO NOT TERMINATOR
	RET				;ALL DONE
NOTCON:
	CPI	9			;LINE FEED OR TAB?
	JNC	CHRGTR			;YES, EAT.
NOTLFT:	CPI	'0'			;ALL CHARACTERS GREATER THAN
					;"9" HAVE RETURNED, SO SEE IF NUMERIC
	CMC				;MAKE NUMERICS HAVE CARRY ON
	INR	A			;SET ZERO IF [A]=0
	DCR	A
	RET	

NUMCON:	DB	CONCON			;THESE FAKE TOKENS FORCE CHRGET
	DB	CONCN2			;TO EFFECTIVELY RE-SCAN THE EMBEDED CONSTANT
	
;
; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
;
; LINE NUMBERS RANGE FROM 0 TO 65529
;
; THE ANSWER IS RETURNED IN [D,E].
; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
; AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION
; CODES SET UP TO REFLECT ITS VALUE.
;
LINGET:	DCX	H			;BACKSPACE PTR
LINGT2:	CALL	CHRGTR			;FETCH CHAR (GOBBLE LINE CONSTANTS)
	CPI	LINCON			;EMBEDDED LINE CONSTANT?
	JZ	LINGT3			;YES, RETURN DOUBLE BYTE VALUE
	CPI	PTRCON			;ALSO CHECK FOR POINTER
LINGT3:	XCHG				;SAVE TEXT PTR IN [D,E]
	LHLD	CONLO			;GET EMBEDDED LINE #
	XCHG				;RESTORE TEXT PTR.
	JZ	CHRGTR			;EAT FOLLOWING CHAR
	DCX	H			;BACK UP POINTER
	LXI	D,0			;ZERO ACCUMULATED LINE #
MORLIN:	CALL	CHRGTR
	RNC				;WAS IT A DIGIT
	PUSH	H
	PUSH	PSW
	LXI	H,0+6552		;SEE IF THE LINE # IS TOO BIG
	CALL	DCOMPR
	JC	POPHSR			;YES, DON'T SCAN ANY MORE DIGITS IF SO
					;FORCE CALLER TO SEE DIGIT AND GIVE SYNTAX ERROR
					;CAN'T JUST GO TO SYNTAX ERROR BECAUSE OF NON-FAST
					;RENUM WHICH CAN'T TERMINATE
	MOV	H,D			;SAVE [D,E]
	MOV	L,E
	DAD	D
	DAD	H
	DAD	D
	DAD	H			;PUTTING [D,E]*10 INTO [H,L]
	POP	PSW
	SUI	'0'
	MOV	E,A
	MVI	D,0
	DAD	D			;ADD THE NEW DIGIT
	XCHG	
	POP	H			;GET BACK TEXT POINTER
	JMP	MORLIN
POPHSR:	POP	PSW			;GET OFF TERMINATING DIGIT
	POP	H			;GET BACK OLD TEXT POINTER
	RET	
	
	PUBLIC	CNSGET
CNSGET:
	CPI	'&'			;OCTAL PERHAPS?
	JNZ	LINGET
	
	ENDSECTION BINTRP
	
;---------------------------------------------------------------------------

	SECTION BIO
	
; Microsoft BASIC has a number of primitive I/O routines:
;	OUTDO (either CALL or RST) prints char in [A] no registers affected
;		to either terminal or disk file or printer depending
;		flags:
;			PRTFLG if non-zero print to printer
;			PTRFIL if non-zero print to disk file pointed to
;				by PTRFIL
;
;	INCHR	input a character into [A] condiation codes destroyed.
;		input from disk file if PTRFIL non-zero.
;
;	CRDO	Print a carriage return sequence on either
;		terminal or printer or disk file depending on flags
;		See OUTDO above. See below code for register use
	
	PUBLIC	OUTDO
OUTDO:	PUSH	PSW
	PUSH	H
	LHLD	PTRFIL
OUTCON:
	MOV	A,H
	ORA	L
	JNZ	FILOUT
	POP	H
LPTCOD:	LDA	PRTFLG			;SEE IF WE WANT TO TALK TO LPT
	ORA	A			;TEST BITS

					;REGULAR OKIA DRIVER ONLY
	JZ	TTYCHR			;IF ZERO THEN NOT
	POP	PSW			;GET BACK CHAR
	PUSH	PSW
	CPI	8			;BACKSPACE?
	JNZ	NTBKS2			;NO
	LDA	LPTPOS			;GET LPT POS
	DCR	A			;SUBTRACT ONE FROM PRINTER POSIT
	STA	LPTPOS			;CORRECT LPTPOS
	POP	PSW			;GET BACK BACKSPACE
	JMP	LPTCHR			;SEND CHAR
NTBKS2:	CPI	9			;TAB
	JNZ	NOTABL			;NO
MORSPL:	MVI	A,32			;GET SPACE
	CALL	OUTDO			;SEND IT
	LDA	LPTPOS			;GET CURRENT PRINT POSIT
	ANI	7			;AT TAB STOP?
	JNZ	MORSPL			;GO BACK IF MORE TO PRINT
	POP	PSW			;POP OFF CHAR
	RET				;RETURN
NOTABL:

	POP	PSW			;GET CHAR BACK
	PUSH	PSW			;SAVE AGAIN
	SUI	13			;IF FUNNY CONTROL CHAR, (LF) DO NOTHING
	JZ	ZERLP1
	JC	LPTCH1			;JUST PRINT CHAR
	LDA	LPTSIZ			;GET SIZE OF PRINTER
	INR	A			;IS IT INFINITE?
	LDA	LPTPOS			;GET POSIT
	JZ	ZERLPT			;THEN DONT FOLD
	PUSH	H			;SSAVE [H,L]
	LXI	H,LPTSIZ		;MAX LENGTH
	CMP	M			;SET CC'S
	POP	H			;THEN DO CRLF
	CZ	PRINTW			;DO CRLF
	JZ	LPTCH1			;IF FORCED CR, LEAVE LPTPOS AT ZERO
ZERLPT:
	CPI	255			;MAX LENGTH?
	JZ	LPTCH1			;THEN JUST PRINT
	INR	A			;INCREMENT POSIT
ZERLP1:	STA	LPTPOS
LPTCH1:	POP	PSW			;GET CHAR BACK
LPTCHR:	PUSH	PSW			;SAVE BACK AGAIN
	PUSH	B			;SAVE [B,C]
	PUSH	D			;SAVE [D,E]
	PUSH	H
	MOV	C,A			;CPM WANTS CHAR IN [C]
	PUBLIC	LPTOUT
LPTOUT:	CALL	0			;PRINTER ROUTINE ADDRESS STORED HERE
	POP	H			;RESTORE REGS
	POP	D
	POP	B
	POP	PSW			;RESTORE CHAR
	RET				;RETURN FROM OUTCHR
	PUBLIC	FINLPT
FINLPT:	XRA	A			;RESET PRINT FLAG SO
	STA	PRTFLG			;OUTPUT GOES TO TERMINAL
	LDA	LPTPOS			;GET CURRENT LPT POSIT
	ORA	A			;ON LEFT HAND MARGIN ALREADY?
	RZ				;YES, RETURN
PRINTW:	MVI	A,13			;PUT OUT CRLF
	CALL	LPTCHR
	MVI	A,10
	CALL	LPTCHR
	XRA	A			;ZERO LPTPOS
	STA	LPTPOS
	RET				;DONE
	PUBLIC	TTYCHR
TTYCHR:
	LDA	CNTOFL
	ORA	A
	JNZ	PPSWRT			;NO, DO OUTPUT
	POP	PSW			;GET THE CHARACTER
	PUSH	B
	PUSH	PSW			;AND SAVE IT AGAIN
	CPI	8			;BACKSPACE?
	JNZ	NTBKS1			;NO
	LDA	TTYPOS			;GET TTY POS
	ORA	A			;SET CC'S
	JZ	MORSPR			;RETURN
	DCR	A			;DECRMENT POSIT BY ONE
	STA	TTYPOS			;CORRECT TTYPOS
					;CORRECT TTYPOS
	MVI	A,8			;GET BACK BACKSPACE CHAR
	JMP	TRYOUT			;SEND IT
NTBKS1:	CPI	9			;OUTPUTTING TAB?
	JNZ	NOTAB			;NO.
MORSP:	MVI	A,32			;GET SPACE CHAR
	CALL	OUTDO			;CALL OUTCHR RECURSIVELY (!)
	LDA	TTYPOS			;GET CURRENT PRINT POS.
	ANI	7			;AT TAB STOP YET??
	JNZ	MORSP			;NO, KEEP SPACING
MORSPR:	POP	PSW			;RESTORE CURRENT CHAR (TAB)
	POP	B			;GET [B,C] BACK
	RET				;ALL DONE
NOTAB:
	CPI	32			;IS THIS A MEANINGFUL CHARACTER?
	JC	TRYOUT			;IF IT'S A NON-PRINTING CHARACTER
	LDA	LINLEN
	MOV	B,A			;[B]=LINE LENGTH
					;DON'T INCLUDE IT IN TTYPOS
	LDA	TTYPOS			;SEE IF PRINT HEAD IS AT THE END OF THE LINE
	INR	B			;IS WIDTH 255?
	JZ	INCTPS			;YES, JUST INC TTYPOS
	DCR	B			;CORRECT [B]
	CMP	B
	PUBLIC	LINPT1
LINPT1	SET	$-1
	CZ	CRDO			;TYPE CRLF AND SET TTYPOS AND [A]=0 IF SO
	JZ	TRYOUT			;IF FORCED CRLF, LEAVE TTYPOS AT ZERO
INCTPS:
	CPI	255			;HAVE WE HIT MAX #?
	JZ	TRYOUT			;THEN LEAVE IT THERE
	INR	A			;INCREMENT TTYPOS SINCE WE'RE
					;GOING TO PRINT A CHARACTER.
	STA	TTYPOS			;STORE NEW PRINT HEAD POSITION
					;STORE NEW PRINT HEAD POSITION	

TRYOUT:
	POP	PSW			;GET CHAR OFF STACK
	POP	B			;RESTORE [B,C]
	PUSH	PSW			;SAVE PSW BACK
	PUBLIC	NOPRIN
NOPRIN:					; END OF PHLZ80 OFF
	POP	PSW			;GET CHARACTER BACK

	PUSH	PSW			;THEN SAVE BACK
	PUSH	B			;SAVE ALL REGS
	PUSH	D
	PUSH	H
	MOV	C,A			;CPM WANTS CHAR IN [C]
	PUBLIC	CONOUT
CONOUT:	CALL	0			;CPM (BIOS) ENTRY POINT
	POP	H			;RESTORE REGS
	POP	D
	POP	B
	POP	PSW			;RESTORE CHAR
	RET				;RETURN FROM OUTCHR
	
TRYIN:
	PUBLIC	INCHRI
INCHRI:
	PUSH	B			;SAVE REGS
	PUSH	D
	PUSH	H
	PUBLIC	CONIN
CONIN:	CALL	0			;CHANGED TO CALL CI
	POP	H			;RESTORE REGS
	POP	D
	POP	B
	PUBLIC	CNLCB2
CNLCB2	SET	$-1			;CONSOLE COMMAND CHANGE LOCs

	PUBLIC	ISCNTC
ISCNTC:

	PUSH	B			;SAVE REGS
	PUSH	D
	PUSH	H

	PUBLIC	CONSTS
CONSTS:	CALL	CSTS			;GET CONSOLE STATUS
	POP	H
	POP	D
	POP	B
	ORA	A			;SET CC'S
	RZ				;0=FALSE - NO CHARACTER TYPED
					;IF NONE, RETURN

	PUBLIC CONST3
MRCHRI:
CONST3:	CALL	0
	ORA	A			;SET NON-ZERO IF CHAR THERE
	
	ENDSECTION BIO
	
;---------------------------------------------------------------------------

	SECTION IADAHL
	
;
; LONG VARIABLE NAME SUBROUTINES. AFTER THE NORMAL 2 CHARACTER NAME
; THE COUNT OF ADDITIONAL CHARACTERS IS STORED. FOLLOWING THIS
; COMES THE CHARACTERS IN ORDER WITH THE HIGH BIT TURNED ON SO A BACKWARD
; SCAN IS POSSIBLE
;
	PUBLIC	IADAHL
IADAHL:	MOV	A,M			;GET THE CHARACTER COUNT
	INX	H
ADDAHL:	PUSH	B			;ADD [A] TO [H,L]
	MVI	B,0
	MOV	C,A
	DAD	B
	POP	B			;RESTORE THE SAVED [B,C]
	RET	
NPUTSB:	PUSH	B			;THIS ROUTINE STORE THE "LONG" NAME AT [H,L]
	PUSH	D
	PUSH	PSW
	LXI	D,NAMCNT		;POINT AT DATA TO SAVE
	LDAX	D			;GET THE COUNT
	MOV	B,A
	INR	B			;[B]= NUMBER OF BYTES TO SAVE
SLPLNG:	LDAX	D			;FETCH STORE VALUE
	INX	D
	INX	H			;MOVE UP TO STORE NAME INTO TABLE
	MOV	M,A			;DO THE STORE
	DCR	B			;AND REPEAT [B] TIMES
	JNZ	SLPLNG			;FOR THE COUNT AND DATA
	POP	PSW
	POP	D
	POP	B
	RET	
	
	ENDSECTION IADAHL
	
;---------------------------------------------------------------------------

	SECTION BISTRS
	
	PUBLIC GARBA2
	PUBLIC STROUT
	
CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	
CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR

STRIN1:	MVI	A,1			;MAKE ONE CHAR STRING (CHR$, INKEY$)
STRINI:	CALL	GETSPA			;GET SOME STRING SPACE ([A] CHARS)
STRAD2:	LXI	H,DSCTMP		;GET DESC. TEMP
STRAD1:	PUSH	H			;SAVE DESC. POINTER
	MOV	M,A			;SAVE CHARACTER COUNT
PUTDEI:	INX	H			;STORE [D,E]=POINTER TO FREE SPACE
	MOV	M,E
	INX	H
	MOV	M,D
	POP	H			;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
	RET	
;
; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
; NOT SET UP.
;
	PUBLIC	STRLT2
STRLIT:	DCX	H
STRLTI:	MVI	B,34			;ASSUME STR ENDS ON QUOTE
STRLT3:	MOV	D,B
STRLT2:	PUSH	H			;SAVE POINTER TO START OF LITERAL
	MVI	C,255			;INITIALIZE CHARACTER COUNT
STRGET:	INX	H
	MOV	A,M			;GET CHAR
	INR	C			;BUMP CHARACTER COUNT
	ORA	A			;IF 0, (END OF LINE) DONE
	JZ	STRFIN			;TEST
	CMP	D
	JZ	STRFIN
	CMP	B			;CLOSING QUOTE
	JNZ	STRGET			;NO, GO BACK FOR MORE
STRFIN:	CPI	34			;IF QUOTE TERMINATES THE STRING
	CZ	CHRGTR			;SKIP OVER THE QUOTE
	PUSH	H			;SAVE POINTER AT END OF STRING
	MOV	A,B			;WERE WE SCANNING AN UNQUOTED STRING?
	CPI	44
	JNZ	NTTRLS			;IF NOT, DON'T SUPPRESS TRAILING SPACES
	INR	C			;FIX [C] WHICH IS THE CHARACTER COUNT
LPTRLS:	DCR	C			;DECREMENT UNTIL WE FIND A NON-SPACE CHARACTER
	JZ	NTTRLS			;DON'T GO PAST START (ALL SPACES)
	DCX	H			;LOOK AT PREVIOUS CHARACTER
	MOV	A,M
	CPI	' '
	JZ	LPTRLS			;IF SO CONTINUE LOOKING
NTTRLS:	POP	H
	XTHL	
	INX	H
	XCHG				;GET POINTER TO TEMP
	MOV	A,C			;GET CHARACTER COUNT IN A
	CALL	STRAD2			;SAVE STR INFO
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE 
; RESULT AS TYPE STRING
;
	PUBLIC	PUTNEW
PUTNEW:	LXI	D,DSCTMP		;[D,E] POINT AT RESULT DESCRIPTOR
	PUBLIC	PUTTMP
	DB	76Q			;SKIP THE NEXT BYTE ("MVI AL,")
PUTTMP:	PUSH	D			;SAVE A POINTER TO THE START OF THE STRING
	LHLD	TEMPPT			;[H,L]=POINTER TO FIRST FREE TEMP
	SHLD	FACLO			;POINTER AT WHERE RESULT DESCRIPTOR WILL BE
	MVI	A,3
	STA	VALTYP			;FLAG THIS AS A STRING
	CALL	VMOVE			;AND MOVE THE VALUE INTO A TEMPORARY
	LXI	D,DSCTMP+3		;IF THE CALL IS TO PUTTMP, [D,E]
					;WILL NOT EQUAL DSCTMP +3
	CALL	DCOMPR			;DSCTMP IS JUST BEYOND THE TEMPS
					;AND IF TEMPPT POINTS AT IT THERE
					;ARE NO FREE TEMPS
	SHLD	TEMPPT			;SAVE NEW TEMPORARY POINTER
	POP	H			;GET THE TEXT POINTER
	MOV	A,M			;GET CURRENT CHARACTER INTO [A]
	RNZ	
	LXI	D,0+ERRST		;"STRING TEMPORARY" ERROR
	JMP	ERROR			;GO TELL HIM
;
; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
;
STROUI:	INX	H			;POINT AT NEXT CHARACTER
STROUT:	CALL	STRLIT			;GET A STRING LITERAL
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
;
STRPRT:	CALL	FREFAC			;RETURN TEMP POINTER BY FACLO
	CALL	GETBCD			;[D]=LENGTH [B,C]=POINTER AT DATA
	INR	D			;INCREMENT AND DECREMENT EARLY
					;TO CHECK FOR NULL STRING
STRPR2:	DCR	D			;DECREMENT THE LENGTH
	RZ				;ALL DONE
	LDAX	B			;GET CHARACTER TO PRINT
	CALL	OUTDO
	CPI	13
	CZ	CRFIN
	INX	B			;POINT TO THE NEXT CHARACTER
	JMP	STRPR2			;AND PRINT IT...
	
;
; GETSPA - GET SPACE FOR CHARACTER STRING
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARS (BYTES) IN [A]
; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
;
	PUBLIC	GETSPA
GETSPA:	ORA	A			;MUST BE NON ZERO. SIGNAL NO GARBAG YET
	DB	16Q			;"MVI C" AROUND THE NEXT BYTE 
TRYGI2:	POP	PSW			;IN CASE COLLECTED WHAT WAS LENGTH?
	PUSH	PSW			;SAVE IT BACK
	LHLD	STREND
	XCHG				;IN [D,E]
	LHLD	FRETOP			;GET TOP OF FREE SPACE IN [H,L]
	CMA				;-# OF CHARS
	MOV	C,A			;IN [B,C]
	MVI	B,255
	DAD	B			;SUBTRACT FROM TOP OF FREE
	INX	H
	CALL	DCOMPR			;COMPARE THE TWO
	JC	GARBAG			;NOT ENOUGH ROOM FOR STRING, OFFAL TIME
	SHLD	FRETOP			;SAVE NEW BOTTOM OF MEMORY
	INX	H			;MOVE BACK TO POINT TO STRING
	XCHG				;RETURN WITH POINTER IN [D,E]
	PUBLIC	PPSWRT
PPSWRT:	POP	PSW			;GET CHARACTER COUNT
	RET				;RETURN FROM GETSPA

GARBAG:	POP	PSW			;HAVE WE COLLECTED BEFORE?
	LXI	D,0+ERRSO		;GET READY FOR OUT OF STRING SPACE ERROR
	JZ	ERROR			;GO TELL USER HE LOST
	CMP	A			;SET ZERO FLAG TO SAY WEVE GARBAGED
	PUSH	PSW			;SAVE FLAG BACK ON STACK
	LXI	B,TRYGI2		;PLACE FOR GARBAG TO RETURN TO.
	PUSH	B			;SAVE ON STACK
GARBA2:	LHLD	MEMSIZ			;START FROM TOP DOWN
FNDVAR:	SHLD	FRETOP			;LIKE SO
	LXI	H,0			;GET DOUBLE ZERO
	PUSH	H			;SAY DIDNT SEE VARS THIS PASS
	LHLD	STREND			;FORCE DVARS TO IGNORE STRINGS
					;IN THE PROGRAM TEXT (LITERALS, DATA)
	PUSH	H			;FORCE FIND HIGH ADDRESS
	LXI	H,TEMPST		;GET START OF STRING TEMPS
TVAR:	XCHG				;SAVE IN [D,E]
	LHLD	TEMPPT			;SEE IF DONE
	XCHG				;FLIP
	CALL	DCOMPR			;TEST
					;CANNOT RUN IN RAM SINCE IT STORES TO MESS UP BASIC
	LXI	B,TVAR			;FORCE JUMP TO TVAR
	JNZ	DVAR2			;DO TEMP VAR GARBAGE COLLECT

	LXI	H,PRMPRV		;SETUP ITERATION FOR PARAMETER BLOCKS
	SHLD	TEMP9
	LHLD	ARYTAB			;GET STOPPING POINT IN [H,L]
	SHLD	ARYTA2			;STORE IN STOP LOCATION
	LHLD	VARTAB			;GET STARTING POINT IN [H,L]

SVAR:	XCHG	
	LHLD	ARYTA2			;GET STOPPING LOCATION
	XCHG	
	CALL	DCOMPR			;SEE IF AT END OF SIMPS
	JZ	ARYVAR
	MOV	A,M			;GET VALTYP
	INX	H			;BUMP POINTER TWICE
	INX	H			;
	INX	H			;POINT AT THE VALUE
	PUSH	PSW			;SAVE VALTYP
	CALL	IADAHL			;AND SKIP OVER EXTRA CHARACTERS AND COUNT
	POP	PSW
	CPI	3			;SEE IF ITS A STRING
	JNZ	SKPVAR			;IF NOT, JUST SKIP AROUND IT
	CALL	DVARS			;COLLECT IT
	XRA	A			;AND DON'T SKIP ANYTHING MORE
SKPVAR:	MOV	E,A
	MVI	D,0			;[D,E]=AMOUNT TO SKIP
	DAD	D
	JMP	SVAR			;GET NEXT ONE
ARYVAR:	LHLD	TEMP9			;GET LINK IN PARAMETER BLOCK CHAIN
	MOV	A,M			;GO BACK ONE LEVEL
	INX	H
	MOV	H,M
	MOV	L,A
	ORA	H			;WAS THAT THE END?
	XCHG				;SETUP TO START ARRAYS
	LHLD	ARYTAB
	JZ	ARYVA4			;OTHERWISE GARBAGE COLLECT ARRAYS
	XCHG	
	SHLD	TEMP9			;SETUP NEXT LINK IN CHAIN FOR ITERATION
	INX	H			;SKIP CHAIN POINTER
	INX	H
	MOV	E,M			;PICK UP THE LENGTH
	INX	H
	MOV	D,M
	INX	H
	XCHG				;SET [D,E]= ACTUAL END ADDRESS BY
	DAD	D			;ADDING BASE TO LENGTH
	SHLD	ARYTA2			;SET UP STOP LOCATION
	XCHG	
	JMP	SVAR

ARYVA2:	POP	B			;GET RID OF STACK GARBAGE
ARYVA4:	XCHG				;SAVE ARYVAR IN [D,E]
	LHLD	STREND			;GET END OF ARRAYS
	XCHG				;FLIP BACK
	CALL	DCOMPR			;SEE IF DONE WITH ARRAYS
	JZ	GRBPAS			;YES, SEE IF DONE COLLECTING
	MOV	A,M			;GET THE VALUE TYPE INTO [A]
	INX	H
	PUSH	PSW			;SAVE THE VALTYP
	INX	H			;SKIP THE NAME CHARACTERS
	INX	H
	CALL	IADAHL			;SKIP THE EXTRA CHARACTERS
	MOV	C,M			;PICK UP THE LENGTH
	INX	H
	MOV	B,M
	INX	H
	POP	PSW			;RESTORE THE VALTYP
	PUSH	H			;SAVE POINTER TO DIMS
	DAD	B			;ADD TO CURRENT POINTER POSITION
	CPI	3			;SEE IF ITS A STRING
	JNZ	ARYVA2			;IF NOT JUST SKIP IT
	SHLD	TEMP8			;SAVE END OF ARRAY
	POP	H			;GET BACK CURRENT POSITION
	MOV	C,M			;PICK UP NUMBER OF DIMS
	MVI	B,0			;MAKE DOUBLE WITH HIGH ZERO
	DAD	B			;GO PAST DIMS
	DAD	B			;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
	INX	H			;ONE MORE TO ACCOUNT FOR #DIMS.
ARYSTR:	XCHG				;SAVE CURRENT POSIT IN [D,E]
	LHLD	TEMP8			;GET END OF ARRAY
	XCHG				;FIX [H,L] BACK TO CURRENT
	CALL	DCOMPR			;SEE IF AT END OF ARRAY
	JZ	ARYVA4			;END OF ARRAY, TRY NEXT ARRAY
	LXI	B,ARYSTR		;ADDR OF WHERE TO RETURN TO
DVAR2:	PUSH	B			;GOES ON STACK
DVAR:
DVARS:	XRA	A
	ORA	M			;SEE IF ITS THE NULL STRING
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H			;[D,E]=POINTER AT THE VALUE
	RZ				;NULL STRING, RETURN
	MOV	B,H			;MOVE [H,L] TO [B,C]
	MOV	C,L
	LHLD	FRETOP			;GET POINTER TO TOP OF STRING FREE SPACE
	CALL	DCOMPR			;IS THIS STRINGS POINTER .LT. FRETOP
	MOV	H,B			;MOVE [B,C] BACK TO [H,L]
	MOV	L,C
	RC				;IF NOT, NO NEED TO MESS WITH IT FURTHUR
	POP	H			;GET RETURN ADDRESS OFF STACK
	XTHL				;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
	CALL	DCOMPR			;LETS SEE
	XTHL				;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
	PUSH	H			;SAVE RETURN ADDRESS BACK
	MOV	H,B			;MOVE [B,C] BACK TO [H,L]
	MOV	L,C
	RNC				;IF NOT, LETS LOOK AT NEXT VAR
	POP	B			;GET RETURN ADDR OFF STACK
	POP	PSW			;POP OFF MAX SEEN
	POP	PSW			;AND VARIABLE POINTER
	PUSH	H			;SAVE NEW VARIABLE POINTER
	PUSH	D			;AND NEW MAX POINTER
	PUSH	B			;SAVE RETURN ADDRESS BACK
	RET				;AND RETURN
	
;
; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
;
GRBPAS:	POP	D			;POP OFF MAX POINTER
	POP	H			;AND GET VARIABLE POINTER
	MOV	A,L			;GET LOW IN
	ORA	H			;SEE IF ZERO POINTER
	RZ				;IF END OF COLLECTION,
					;THEN MAYBE RETURN TO GETSPA
	DCX	H			;CURRENTLY JUST PAST THE DESCRIPTOR
	MOV	B,M			;[B]=HIGH BYTE OF DATA POINTER
	DCX	H
	MOV	C,M			;[B,C]=POINTER AT STRING DATA
	PUSH	H			;SAVE THIS LOCATION SO THE POINTER
					;CAN BE UPDATED AFTER THE STRING IS
					;MOVED
	DCX	H
	MOV	L,M			;[L]=STRING LENGTH
	MVI	H,0			;[H,L] GET CHARACTER COUNT
	DAD	B			;[H,L]=POINTER BEYOND STRING
	MOV	D,B
	MOV	E,C			;[D,E]=ORIGINAL POINTER
	DCX	H			;DON'T MOVE ONE BEYOND STRING
	MOV	B,H			;GET TOP OF STRING IN [B,C]
	MOV	C,L
	LHLD	FRETOP			;GET TOP OF FREE SPACE
	CALL	BLTUC			;MOVE STRING
	POP	H			;GET BACK POINTER TO DESC.
	MOV	M,C			;SAVE FIXED ADDR
	INX	H			;MOVE POINTER
	MOV	M,B			;HIGH PART
	MOV	L,C
	MOV	H,B			;[H,L]=NEW POINTER
	DCX	H			;FIX UP FRETOP
	JMP	FNDVAR			;AND TRY TO FIND HIGH AGAIN
	
;
; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
; THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
; LONGER IN USE.
;
	PUBLIC	FREFAC
FRESTR:	CALL	CHKSTR			;MAKE SURE ITS A STRING
FREFAC:	LHLD	FACLO
	PUBLIC	FRETM2
FRETM2:	XCHG				;FREE UP THE TEMP IN THE FACLO
FRETMP:	CALL	FRETMS			;FREE UP THE TEMPORARY
	XCHG				;PUT THE STRING POINTER INTO [H,L]
	RNZ	
	PUSH	D			;SAVE [D,E] TO RETURN IN [H,L]
	MOV	D,B			;[D,E]=POINTER AT STRING
	MOV	E,C
	DCX	D			;SUBTRACT ONE
	MOV	C,M			;[C]=LENGTH OF THE STRING FREED UP
	LHLD	FRETOP			;SEE IF ITS THE FIRST 
					;ONE IN STRING SPACE
	CALL	DCOMPR
	JNZ	NOTLST			;NO SO DON'T ADD
	MOV	B,A			;MAKE [B]=0
	DAD	B			;ADD
	SHLD	FRETOP			;AND UPDATE FRETOP
NOTLST:	POP	H			;GET POINTER AT CURRENT DESCRIPTOR
	RET	
FRETMS:	LHLD	TEMPPT			;GET TEMP POINTER
	DCX	H			;LOOK AT WHAT IS IN THE LAST TEMP
	MOV	B,M			;[B,C]=POINTER AT STRING
	DCX	H			;DECREMENT TEMPPT BY STRSIZ
	MOV	C,M
	DCX	H
	CALL	DCOMPR			;SEE IF [D,E] POINT AT THE LAST 
	RNZ				;RETURN NOW IF NOW FREEING DONE
	SHLD	TEMPPT			;UPDATE THE TEMP POINTER SINCE
					;ITS BEEN DECREMENTED BY 4
	RET	


	ENDSECTION BISTRS
	
;---------------------------------------------------------------------------

	SECTION BIMISC
	
	PUBLIC SYNCHR
	PUBLIC DCOMPR
	PUBLIC OMERR
	PUBLIC BLTUC
	PUBLIC REASON
	
CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR

;
; THIS IS THE BLOCK TRANSFER ROUTINE
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
;
; [H,L] = DESTINATION OF HIGH ADDRESS
; [D,E] = LOW ADDRESS TO BE TRANSFERRED
; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
;
; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
; THE HIGHEST LOCATION TRANSFERRED INTO
;
; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
;
BLTU:	CALL	REASON			;CHECK DESTINATION TO MAKE
					;SURE THE STACK WON'T BE OVERRUN
BLTUC:	PUSH	B			;EXCHANGE [B,C] AND [H,L]
	XTHL	
	POP	B
BLTLOP:	CALL	DCOMPR			;SEE IF WE ARE DONE
	MOV	A,M			;GET THE WORD TO TRANSFER
	STAX	B			;TRANSFER IT
	RZ	
	DCX	B
	DCX	H			;BACKUP FOR NEXT GUY
	JMP	BLTLOP

;
; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
; OF LOCATIONS REMAIN AVAILABLE FOR THE
; STACK. THE CALL IS :
;	MVI	C,NUMBER OF 2 BYTE ENTRIES NECESSARY
;	CALL	GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV STACK LOCATIONS NEED NOT CALL THIS
;
GETSTK:	PUSH	H			;SAVE [H,L]
	LHLD	MEMSIZ
	MVI	B,0
	DAD	B
	DAD	B			;SEE IF WE CAN HAVE THIS MANY
;
; [H,L]= SOME ADDRESS
; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
;
CONS1	SET	256-(2*NUMLEV)
	MVI	A,CONS1			;SET [H,L]=-[H,L]-2*NUMLEV
	SUB	L
	MOV	L,A
	MVI	A,255
	SBB	H
	JC	OMERR			;IN CASE [H,L] WAS TOO BIG(MBM 3/18**)
	MOV	H,A			;NOW SEE IF [SP] IS LARGER
	DAD	SP			;IF SO, CARRY WILL BE SET
	POP	H			;GET BACK ORIGINAL [H,L]
	RC				;WAS OK?
OMERR:

					;FOR SPACE REASONS LEAVE THIS CODE OUT

					;ONLY IMPORTANT IN VERSIONS WHERE
					;STACK CONTEXT SURVIVES OTHER ERRORS
	LHLD	TOPMEM
	DCX	H			;UP SOME MEMORY SPACE
	DCX	H			;MAKE SURE THE FNDFOR STOPPER IS SAVED
	SHLD	SAVSTK			;PLACE STACK IS RESTORED FROM
OMERRR:	LXI	D,0+ERROM		;"OUT OF MEMORY"
	JMP	ERROR
REASON:	CALL	REALLY			;ENOUGH SPACE BETWEEN STRING & STACK
	RNC				;YES
	PUSH	B			;SAVE ALL REGS
	PUSH	D
	PUSH	H
	CALL	GARBA2			;DO A GARBAGE COLLECTION
	POP	H			;RESTORE ALL REGS
	POP	D
	POP	B
	CALL	REALLY			;ENOUGH SPACE THIS TIME?
	RNC				;YES
	JMP	OMERRR			;NO, GIVE "OUT OF MEMORY BUT DONT TOUCH STACK
REALLY:	PUSH	D			;SAVE [D,E]
	XCHG				;SAVE [H,L] IN [D,E]
	LHLD	FRETOP			;GET WHERE STRINGS ARE
	CALL	DCOMPR			;IS TOP OF VARS LESS THAN STRINGS?
	XCHG				;BACK TO [D,E]
	POP	D			;RESTORE [D,E]
	RET				;DONE
	
DCOMPR:	MOV	A,H			;REPLACEMENT FOR "COMPAR" RST
	SUB	D
	RNZ	
	MOV	A,L
	SUB	E
	RET
	
SYNCHR:	MOV	A,M			;REPLACEMENT FOR "SYNCHK" RST
	XTHL	
	CMP	M
	JNZ	SYNERR
	INX	H
	XTHL	
	INX	H			;LOOK AT NEXT CHAR
	MOV	A,M			;GET IT
	CPI	':'			;IS IT END OF STATMENT OR BIGGER
	RNC	
SYNCON:	JMP	CHRCON			;REST OF CHRGET
SYNERR:	JMP	SNERR
	
	ENDSECTION BIMISC
	
;---------------------------------------------------------------------------
	
	SECTION F4
	
	PUBLIC VMOVE
	PUBLIC GETBCD
	
					;MOVE FAC TO REGISTERS (B,C,D,E)
					;ALTERS B,C,D,E,H,L
MOVRF:	LXI	H,FACLO			;GET POINTER TO FAC
					;FALL INTO MOVRM


					;GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
					;ALTERS B,C,D,E,H,L
					;AT EXIT (HL):=(HL)+4
MOVRM:	MOV	E,M			;GET LO
	INX	H			;POINT TO MO
GETBCD:	MOV	D,M			;GET MO, ENTRY FOR BILL
	INX	H			;POINT TO HO
	MOV	C,M			;GET HO
	INX	H			;POINT TO EXPONENT
	MOV	B,M			;GET EXPONENT
INXHRT:	INX	H			;INC POINTER TO BEGINNING OF NEXT NUMBER
	RET				;ALL DONE
	
					;MOVE NUMBER FROM FAC TO MEMORY [(HL)]
					;ALTERS A,B,D,E,H,L
MOVMF:	LXI	D,FACLO			;GET POINTER TO FAC
					;FALL INTO MOVE


					;MOVE NUMBER FROM (DE) TO (HL)
					;ALTERS A,B,D,E,H,L
					;EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
MOVE:	MVI	B,4			;SET COUNTER
	JMP	MOVE1			;CONTINUE WITH THE MOVE


					;MOVE ANY TYPE VALUE (AS INDICATED BY VALTYP) FROM (DE) TO (HL)
					;ALTERS A,B,D,E,H,L
MOVVFM:	XCHG				;ENTRY TO SWITCH (DE) AND (HL)
VMOVE:	LDA	VALTYP			;GET THE LENGTH OF THE NUMBER
	MOV	B,A			;SAVE IT AWAY
	PUBLIC	MOVE1
MOVE1:	LDAX	D			;GET WORD, ENTRY FROM VMOVMF
	MOV	M,A			;PUT IT WHERE IT BELONGS
	INX	D			;INCREMENT POINTERS TO NEXT WORD
	INX	H
	DCR	B
	JNZ	MOVE1
	RET	
	
	ENDSECTION F4
	
;---------------------------------------------------------------------------
	
	SECTION DCPM
	
CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	
; Offsets into file blocks for specific entries

LOCOFS	SET	34+3*1+9*0+14*0-10*0+267*0-30*0;OFFSET TO CURLOC BYTES
ORNOFS	SET	2+LOCOFS		;OFFSET TO NUMBER OF BYTES
					;ORIGINALLY IN THE BUFFER
NMLOFS	SET	1+ORNOFS+0		;OFFSET TO BYTES REMAINING IN THE BUFFER
NMLOFC	SET	0+NMLOFS
					;OR THE PRINT POSITION ON OUTPUT
NMLO.C	SET	0+NMLOFS


DATOFS	SET	1+NMLOFS+0+6*0+288*0+10*0;OFFSET TO BUFFER
DATOFC	SET	0+DATOFS
DBLKSZ	SET	DATOFS+DATPSC
	PUBLIC	DBLK.C
DBLK.C	SET	0+DBLKSZ

Q	SET	DBLKSZ
;DEFINE	ENT(SYM,SIZ),<
;INTERN	SYM
;SYM=Q
;Q=Q+SIZ>

	PUBLIC	FD.SIZ,FD.PHY,FD.LOG,FD.CHG,FD.OPS,FD.DAT
FD.MAX	SET	0			;Size of FIELD buffer

;ENT	FD.SIZ,2		;Variable length record size default 128
FD.SIZ	SET	Q
Q	SET	Q+2
;ENT	FD.PHY,2		;Current physical record #
FD.PHY	SET	Q
Q	SET	Q+2
;ENT	FD.LOG,2		;Current logical record number
FD.LOG	SET	Q
Q	SET	Q+2
;ENT	FD.CHG,1		;Future flag for accross block PRINTs etc.
FD.CHG	SET	Q
Q	SET	Q+1
;ENT	FD.OPS,2		;Output print position for PRINT, INPUT, WRITE
FD.OPS	SET	Q
Q	SET	Q+2
;ENT	FD.DAT,FD.MAX		;Actual FIELD data buffer
FD.DAT	SET	Q
Q	SET	Q+FD.MAX
					;Size is FD.SIZ bytes long

	PUBLIC	FNZBLK
FNZBLK	SET	0+Q

EOFCHR	SET	26+2*0-22*0-23*0	;END OF FILE CHARACTER
	
	ENDSECTION DCPM

;---------------------------------------------------------------------------

	SECTION SINIT
	
CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR

TRUROM	SET	0

SWTCHR	SET	57O			;DEFAULT SWITCH CHARACTER IS SLASH

	PUBLIC INIT, INITSA
	PUBLIC TSTACK

INITSA:
	HLT

ENDIO:	DW 0
INIT:
	LXI	H,TSTACK		;SET UP TEMP STACK
	SPHL
	MVI A,44		;INITIALIZE BUFFER
	STA BUFMIN
	XRA	A			;INITIALIZE PROTECT FLAG
	STA	PROFLG
	SHLD	TOPMEM
	SHLD	SAVSTK			;WE RESTORE STACK WHEN ERRORS
	LHLD	CPMWRM+1		;GET START OF BIOS VECTOR TABLE
	LXI	B,0+4			;CSTS
	DAD	B			;ADD FOUR
	MOV	E,M			;PICK UP CSTS ADDRESS
	INX	H
	MOV	D,M
	XCHG				;GET CSTS ADDRESS
	SHLD	CONST3+1		;THIRD CONTROL-C CHECK
	SHLD	CONSTS+1		;SAVE
	SHLD	CONST2+1		;FAST CONTROL-C CHECK
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;POINT AT CI ADDRESS
	INX	H
	MOV	E,M			;GET LOW BYTE OF CI ADDRESS
	INX	H
	MOV	D,M			;GET HIGH BYTE
	XCHG				;INPUT ADDRESS TO [H,L]
	SHLD	CONIN+1		;SAVE IN CONSOLE INPUT CALL
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;SKIP "JMP" OPCODE
	INX	H			;BUMP POINTER
	MOV	E,M			;GET OUTPUT ROUTINE ADDRESS
	INX	H
	MOV	D,M
	XCHG				;INTO [H,L]
	SHLD	CONOUT+1		;SAVE INTO OUTPUT ROUTINE
	XCHG				;POINTER BACK TO [H,L]
	INX	H			;NOW POINT TO PRINTER OUTPUT
	INX	H			;ROUTINE ADDRESS
	MOV	E,M			;PICK IT UP
	INX	H
	MOV	D,M
	XCHG				;GET ADDRESS INTO [D,E]
	SHLD	LPTOUT+1		;SET PRINT ROUTINE ADDRESS
	
;	Check CP/M Version Number

	MVI	C,12			;Version Test
	CALL	CPMENT
	STA	CPMVRN			;[A] = Version Number (0 = 1.x)
	ORA	A			;Test version number
	LXI	H,21*256+20+0		;1.x Read / Write
	JZ	CPMVR1
	LXI	H,34*256+33+0		;2.x Read / Write
CPMVR1:	SHLD	CPMREA			;Save Read/Write Codes
	LXI	H,0+65534		;SAY INITIALIZATION IS EXECUTING
	SHLD	CURLIN			;IN CASE OF ERROR MESSAGE
	XRA	A
	STA	CNTOFL
	STA	ENDBUF			;MAKE SURE OVERRUNS STOP
	STA	CHNFLG			;MAKE SURE CHAINS AND MERGES
	STA	MRGFLG			;DONT TRY TO HAPPEN
	STA	ERRFLG			;DON'T ALLOW EDIT TO BE CALLED ON ERRORS
	LXI	H,0			;GET 0
	SHLD	LPTPOS		;ZERO FLAG AND POSITION
	LXI	H,0+128			;DEFAULT MAX REC SIZE
	SHLD	MAXREC
	LXI	H,TEMPST
	SHLD	TEMPPT
	LXI	H,PRMSTK		;INITIALIZE PARAMETER BLOCK CHAIN
	SHLD	PRMPRV
	LHLD	CPMENT+1		;GET LAST LOC IN MEMORY
	SHLD	MEMSIZ			;USE AS DEFAULT
;
;
; THE FOLLOWING CODE SCANS A CP/M COMMAND LINE FOR BASIC.
; THE FORMAT OF THE COMMAND IS:
;
; BASIC <FILE NAME>[/M:<TOPMEM>][/F:<FILES>]
;
;*
	MVI	A,3			;DEFAULT FILES
	STA	MAXFIL			;BY SETTING MAXFIL=3
	LXI	H,ZEROB			;POINT AT ZERO BYTE
	SHLD	CPMFIL			;SO IF RE-INITAILIZE OK
	LDA	COMAGN			;HAVE WE ALREADY READ COMMAND LINE
	ORA	A			;AND GOT ERROR?
	JNZ	ERRCMD			;THEN DEFAULT
	INR	A			;MAKE NON-ZERO
	STA	COMAGN			;STORE BACK NON-ZERO FOR NEXT TIME
TBUFF	SET	CPMWRM+128		;WHERE CP/M COMMAND BUFFER IS LOCATED

	LXI	H,TBUFF			;POINT TO FIRST CHAR OF COMMAND BUFFER
	MOV	A,M			;WHICH CONTAINS # OF CHARS IN COMMAND
	ORA	A			;IS THERE A COMMAND?
	SHLD	CPMFIL			;SAVE POINTER TO THIS ZERO
	JZ	DONCMD			;NOTHING IN COMMAND BUFFER
	MOV	B,M			;AND [B]
	INX	H			;POINT TO FIRST CHAR IN BUFFER
TBFLP:	MOV	A,M			;GET CHAR FROM BUFFER
	DCX	H			;BACK UP POINTER
	MOV	M,A			;STORE CHAR BACK
	INX	H			;NOW ADVANCE CHAR TO ONE PLACE
	INX	H			;AFTER PREVIOUS POSIT.
	DCR	B			;DECREMENT COUNT OF CHARS TO MOVE
	JNZ	TBFLP			;KEEP MOVING CHARS
	DCX	H			;BACK UP POINTER
ENDCMD:	MVI	M,0			;STORE TERMINATOR FOR CHRGET (0)
	SHLD	CPMFIL			;SAVE POINTER TO NEW ZERO (OLD DESTROYED)
	LXI	H,TBUFF-1		;POINT TO CHAR BEFORE BUFFER
	CALL	CHRGTR			;IGNORE LEADING SPACES
	ORA	A
	JZ	DONCMD			;END OF COMMAND
	CPI	SWTCHR			;IS IT A SLASH
	JZ	FNDSLH			;YES
	DCX	H			;BACK UP POINTER
	MVI	M,34			;STORE DOUBLE QUOTE
	SHLD	CPMFIL			;SAVE POINTER TO START OF FILE NAME
	INX	H			;BUMP POINTER
ISSLH:	CPI	SWTCHR			;OPTION?
	JZ	FNDSLH			;YES
	CALL	CHRGTR			;SKIP OVER CHAR IN FILE NAME
	ORA	A			;SET CC'S
	JNZ	ISSLH			;KEEP LOOKING FOR OPTION
	JMP	DONCMD
FNDSLH:	MVI	M,0			;STORE TERMINATOR OVER "/"
SCANSW:	CALL	CHRGTR			;GET CHAR AFTER SLASH
SCANS1:
	CPI	'S'			;IS IT /S: ? (SET MAX RECORD SIZE)
	JZ	WASS			;YES
	CPI	'M'			;MEMORY OPTION
	PUSH	PSW			;SAVE INDICATOR
	JZ	WASM			;WAS MEMORY OPTION
	CPI	'F'			;FILES OPTION
	JNZ	SNERR			;NOT "M" OR "F" ERROR
WASM:	CALL	CHRGTR			;GET NEXT CHAR
	CALL	SYNCHR
	DB	':'			;COLON SHOULD FOLLOW
	CALL	CNSGET			;GET VALUE FOLLOWING COLON
	POP	PSW			;GET BACK M/F FLAG
	JZ	MEM			;WAS MEMORY OPTION
	MOV	A,D			;FILES CANT BE .GT. 255
	ORA	A			;SET CC'S
	JNZ	FCERR			;FUNCTION CALL ERROR
	MOV	A,E			;GET LOW BYTE
	CPI	16			;MUST BE .LT. 16
	JNC	FCERR
	STA	MAXFIL			;STORE IN # OF FILES
	JMP	FOK			;DONE
MEM:	XCHG				;PUT VALUE IN [D,E]
	SHLD	MEMSIZ			;SAVE INTO MEMSIZE
	XCHG				;GET BACK TEXT POINTER
FOK:	DCX	H			;RESCAN LAST CHAR
	CALL	CHRGTR			;BY CALLING CHRGET
	JZ	DONCMD			;END OF COMMAND
	CALL	SYNCHR
	DB	SWTCHR			;SLASH SHOULD FOLLOW
	JMP	SCANS1			;SCAN NEXT SWITCH
WASS:	CALL	CHRGTR			;GET CHAR AFTER "S"
	CALL	SYNCHR
	DB	':'			;MAKE SURE COLON FOLLOWS
	CALL	CNSGET			;GET VALUE FOLLOWING COLON
	XCHG				;SAVE IT
	SHLD	MAXREC
	XCHG	
	JMP	FOK			;CONTINUE SCANNING
ZEROB:	DB	0			;ZERO BYTE
CPMFIL:	DW  0			;POINTER TO BASIC LOAD FILE
COMAGN:	DB	0			;WE HAVENT SCANNED COMMAND YET
ERRCMD:
DONCMD:
ASKMEM:
USEDEF:	DCX	H
	LHLD	MEMSIZ			;GET SIZE OF MEMORY
	PUSH	H			;ALSO SAVE FOR LATER
					;SET UP DEFAULT STRING SPACE
	POP	H
	DCX	H			;ALWAYS LEAVE TOP BYTE UNUSED BECAUSE
					;VAL(STRING) MAKES BYTE IN MEMORY
					;BEYOND LAST CHAR OF STRING=0
	SHLD	MEMSIZ			;SAVE IN REAL MEMORY SIZE
	DCX	H			;ONE LOWER IS STKTOP
	PUSH	H			;SAVE IT ON STACK
	
;
; DISK INITIALIZATION ROUTINE
; SETUP  FILE INFO BLOCKS
; THE NUMBER OF EACH AND INFORMATION FOR
; GETTING TO POINTERS TO EACH IS STORED. NO LOCATIONS ARE
; INITIALIZED, THIS IS DONE BY NODSKS, FIRST CLOSING ALL FILES.
; THE NUMBER OF FILES IS THE FILE POINTER TABLE
;
	PUBLIC	DSKDAT
DSKDAT	SET	ENDIO			;START DATA AFTER ALL CODE
ASKSK:
	LDA	MAXFIL			;GET HIGHEST FILE #
	LXI	H,DSKDAT		;GET START OF MEMORY
	SHLD	FILPT1
	LXI	D,FILPTR		;POINT TO TABLE TO SET UP
	STA	MAXFIL			;REMEMBER HOW MANY FILES
	INR	A			;ALWAYS FILE 0 FOR INTERNAL USE
	LXI	B,DBLK.C		;SIZE OF A FILE INFO BLOCK PLUS $CODE
LOPFLB:	XCHG				;[H,L] POINT INTO POINTER BLOCK
	MOV	M,E			;STORE THE POINTER AT THIS FILE
	INX	H
	MOV	M,D
	INX	H
	XCHG	
	DAD	B			;[H,L] POINT TO NEXT INFO BLOCK
	PUSH	H			;SAVE [H,L]
	LHLD	MAXREC			;GET MAX RECORD SIZE
	LXI	B,FNZBLK		;GET SIZE OF OTHER STUFF
	DAD	B
	MOV	B,H
	MOV	C,L			;RESULT TO [B,C]
	POP	H			;RESTORE [H,L]
	DCR	A			;ARE THERE MORE?
	JNZ	LOPFLB
HAVFNS:					;TEXT ALWAYS PRECEDED BY ZERO
					;STORE IT
	INX	H			;INCREMENT POINTER
	SHLD	TXTTAB			;SAVE BOTTOM OF MEMORY
	SHLD	SAVSTK			;WE RESTORE STACK WHEN ERRORS
	POP	D			;GET  CURRENT MEMSIZ
	MOV	A,E			;CALC TOTAL FREE/8
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	JC	OMERR
	MVI	B,3			;DIVIDE BY 2 THREE TIMES
SHFLF3:	ORA	A
	MOV	A,H
	RAR	
	MOV	H,A
	MOV	A,L
	RAR	
	MOV	L,A
	DCR	B
	JNZ	SHFLF3
	MOV	A,H			;SEE HOW MUCH
	CPI	2			;IF LESS THAN 512 USE 1 EIGHTH
	JC	SMLSTK
	LXI	H,0+512
SMLSTK:	MOV	A,E			;SUBTRACT STACK SIZE FROM TOP MEM
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	JC	OMERR
	SHLD	MEMSIZ
	XCHG	
	SHLD	TOPMEM
	SHLD	FRETOP			;REASON USES THIS...
	SPHL				;SET UP NEW STACK
	SHLD	SAVSTK
	LHLD	TXTTAB
	XCHG	
	CALL	REASON
	MOV	A,L			;SUBTRACT MEMSIZ-TXTTAB
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
	DCX	H			;SINCE TWO ZEROS EXIST BETWEEN
	DCX	H			;TXTTAB AND STREND, ADJUST
	PUSH	H			;SAVE NUMBER OF BYTES TO PRINT
	LXI	H,HEDING		;GET HEADING ("BASIC VERSION...")
	CALL	STROUT			;PRINT IT
	POP	H			;RESTORE NUMBER OF BYTES TO PRINT
	CALL	LINPRT			;PRINT # OF BYTES FREE
	LXI	H,WORDS			;TYPE THE HEADING
	CALL	STROUT			;"BYTES FREE"
	LXI	H,STROUT
	SHLD	REPINI+1
	CALL	CRDO			;PRINT CARRIAGE RETURN
	LXI	H,READYR
	SHLD	JMPINI+1
	JMP	INITSA
	
AUTTXT:	DB	13
	DB	10
	DB	10
	DB	'Owned by Microsoft'
	DB	13
	DB	10
	DB	0

WORDS:	DB	' Bytes Free'
	DB	0
HEDING:
	DB	26
	DB	'BASIC 5.2'
	DB	13
	DB	10

	DB	'MAGIC Operating System'
	DB	13
	DB	10
	DB	'    Copyright 1982 (C)'
	DB	13,10
	DB	32,32,32,32,32
	DB	0

LASTWR:				;LAST WORD OF SYSTEM CODE+1
	DS	70+300*0+200*0+30*0	;SPACE FOR TEMP STACK
TSTACK:

	ENDSECTION SINIT
