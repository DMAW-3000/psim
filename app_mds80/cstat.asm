;
; File generated by pyplm compiler
;

	ORG 0100H

STAT:     ; 0100
JUMP	DB  0C3H    ; 0100
JADR	DW  STATUS    ; 0101
MOVE:     ; 0103
	LXI H,_MOVE_N  ; store proc arg 1
	MOV M,E
	MOV L,C
	MOV H,B
	SHLD _MOVE_S  ; store proc arg 2
	LXI H,00002H  ; get ext args on stack
	DAD SP
	MOV A,M  ; proc ext arg load
	STA _MOVE_D  ; assign LSB
	INX H
	MOV A,M
	STA _MOVE_D+1  ; assign MSB
__L00000:     ; 0119
	LXI H,_MOVE_N  ; load var left
	MOV E,M   ; to E
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	LXI H,_MOVE_N   ; assign
	MOV M,E    ; from E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; <>
	JZ __L00002 ; =
	MVI E,001H  ; rel true left
	JMP __L00003
__L00002:     ; 0131
	MVI E,000H  ; rel false left
__L00003:     ; 0133
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00001  ; skip while
	LHLD _MOVE_S  ; load based left
	MOV E,M   ; to E
	LHLD _MOVE_D  ; assign based
	MOV M,E    ; from E
	LHLD _MOVE_S ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _MOVE_S ; assign
	LHLD _MOVE_D ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _MOVE_D ; assign
	JMP __L00000  ; END
__L00001:     ; 015b
	RET  ; proc return
PRINTCHAR:     ; 015c
	LXI H,_PRINTCHAR_CHAR  ; store proc arg 1
	MOV M,E
	MVI E,002H  ; load const left
	LXI H,_PRINTCHAR_CHAR  ; load var right
	MOV C,M   ; to C
	MVI B,000H  ; zero pad MSB
	CALL MON1  ; proc call
	RET  ; proc return
CRLF:     ; 016c
	MVI E,00AH  ; load const left
	CALL PRINTCHAR  ; proc call
	MVI E,00DH  ; load const left
	JMP PRINTCHAR  ; OPT CALLRET
PRINTB:     ; 0176
	MVI E,020H  ; load const left
	CALL PRINTCHAR  ; proc call
	RET  ; proc return
PRINTX:     ; 017c
	XCHG
	SHLD _PRINTX_A  ; store proc arg 1
__L00004:     ; 0180
	LHLD _PRINTX_A  ; load based left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00006 ; =
	MVI E,001H  ; rel true left
	JMP __L00007
__L00006:     ; 018f
	MVI E,000H  ; rel false left
__L00007:     ; 0191
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00005  ; skip while
	LHLD _PRINTX_A  ; load based left
	MOV E,M   ; to E
	CALL PRINTCHAR  ; proc call
	LHLD _PRINTX_A ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _PRINTX_A ; assign
	JMP __L00004  ; END
__L00005:     ; 01ac
	RET  ; proc return
PRINT:     ; 01ad
	XCHG
	SHLD _PRINT_A  ; store proc arg 1
	CALL CRLF  ; proc call
	LHLD _PRINT_A ; load var left
	XCHG    ; to D,E
	JMP PRINTX  ; OPT CALLRET
BREAK:     ; 01bb
	MVI E,00BH  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON2  ; OPT CALLRET
	RET  ; proc return
VERS:     ; 01c4
	MVI E,00CH  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON2  ; OPT CALLRET
	RET  ; proc return
SELECT:     ; 01cd
	LXI H,_SELECT_D  ; store proc arg 1
	MOV M,E
	MVI E,00EH  ; load const left
	LXI H,_SELECT_D  ; load var right
	MOV C,M   ; to C
	MVI B,000H  ; zero pad MSB
	CALL MON1  ; proc call
	RET  ; proc return
SEARCH:     ; 01dd
	XCHG
	SHLD _SEARCH_FCB  ; store proc arg 1
	MVI E,011H  ; load const left
	LHLD _SEARCH_FCB ; load var right
	MOV C,L
	MOV B,H ; to B,C
	CALL MON2  ; proc call
	LXI H,_STATUS_DCNT   ; assign
	MOV M,E    ; from E
	RET  ; proc return
SEARCHN:     ; 01f0
	MVI E,012H  ; load const left
	LXI B,00000H  ; OPT MVICB
	CALL MON2  ; proc call
	LXI H,_STATUS_DCNT   ; assign
	MOV M,E    ; from E
	RET  ; proc return
CSELECT:     ; 01fd
	MVI E,019H  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON2  ; OPT CALLRET
	RET  ; proc return
SETDMA:     ; 0206
	XCHG
	SHLD _SETDMA_DMA  ; store proc arg 1
	MVI E,01AH  ; load const left
	LHLD _SETDMA_DMA ; load var right
	MOV C,L
	MOV B,H ; to B,C
	CALL MON1  ; proc call
	RET  ; proc return
GETALLOCA:     ; 0215
	MVI E,01BH  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON3  ; OPT CALLRET
	RET  ; proc return
GETLOGIN:     ; 021e
	MVI E,018H  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON3  ; OPT CALLRET
	RET  ; proc return
WRITEPROT:     ; 0227
	MVI E,01CH  ; load const left
	LXI B,00000H  ; OPT MVICB
	CALL MON1  ; proc call
	RET  ; proc return
GETRODISK:     ; 0230
	MVI E,01DH  ; load const left
	LXI B,00000H  ; OPT MVICB
	JMP MON3  ; OPT CALLRET
	RET  ; proc return
SETIND:     ; 0239
	MVI E,01EH  ; load const left
	LXI B,0005CH  ; OPT MVICB
	CALL MON1  ; proc call
	RET  ; proc return
SETDPB:     ; 0242
	MVI E,01FH  ; load const left
	LXI B,00000H  ; OPT MVICB
	CALL MON3  ; proc call
	XCHG    ; from D,E
	SHLD DPBA ; assign
	RET  ; proc return
GETUSER:     ; 024f
	MVI E,020H  ; load const left
	LXI B,000FFH  ; OPT MVICB
	JMP MON2  ; OPT CALLRET
	RET  ; proc return
GETFILESIZE:     ; 0258
	XCHG
	SHLD _GETFILESIZE_FCB  ; store proc arg 1
	MVI E,023H  ; load const left
	LHLD _GETFILESIZE_FCB ; load var right
	MOV C,L
	MOV B,H ; to B,C
	CALL MON1  ; proc call
	RET  ; proc return
SETBPB:     ; 0267
	CALL SETDPB  ; proc call
	LXI D,00001H  ; OPT MVIED
	LHLD DPBA  ; load struct based right
	LXI B,00002H
	DAD B     ; struct offset
	MOV C,M   ; to (B),C
__L00008:     ; 0275
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	DCR C
	JNZ __L00008  ; more SHL
	LXI B,00880H  ; OPT MVICB
	LXI H,00000H  ; * init
__L00009:     ; 0287
	MOV A,C
	RAR
	MOV C,A
	JNC __L00010  ; * check bits of right arg
	DAD D
__L00010:     ; 028e
	XCHG
	DAD H
	XCHG
	DCR B  ; check count
	JNZ __L00009 ;  * more bits
	SHLD _STATUS_BPB ; assign
	RET  ; proc return
SELECTDISK:     ; 0299
	LXI H,_SELECTDISK_D  ; store proc arg 1
	MOV M,E
	LXI H,_SELECTDISK_D  ; load var left
	MOV E,M   ; to E
	CALL SELECT  ; proc call
	JMP SETBPB  ; OPT CALLRET
GETALLOC:     ; 02a7
	XCHG
	SHLD _GETALLOC_I  ; store proc arg 1
	LHLD _GETALLOC_I ; load var left
	XCHG    ; to D,E
	MVI C,003H  ; load const right
__L00011:     ; 02b1
	STC
	CMC
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR  ; SHR
	MOV E,A
	DCR C
	JNZ __L00011  ; more SHR
	LHLD _STATUS_ALLOCA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	PUSH D ; save left binary
	LHLD _GETALLOC_I ; load var left
	XCHG    ; to D,E
	LXI B,00007H  ; OPT MVICB
	MOV A,C
	ANA E    ; & left
	MOV E,A
	MOV A,B
	ANA D
	MOV D,A  ; result to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG     ; from D,E
	DAD B    ; + right
	MOV C,L  ; result to B,C
	MOV B,H
	POP D  ; restore left binary
__L00012:     ; 02d8
	MOV A,E
	RLC  ; ROL
	MOV E,A
	DCR C
	JNZ __L00012  ; more ROL
	RET  ; proc return
	RET  ; proc return
COMPARE:     ; 02e1
	XCHG
	SHLD _COMPARE_A  ; store proc arg 1
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00015  ; DO first iter
__L00013:     ; 02eb
	MVI E,003H  ; load const left
	LDA _COMPARE_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00015   ; = 
	JNC __L00014  ; > DO complete
__L00015:     ; 02f8
	STA _COMPARE_I  ; DO assign
	LXI H,_COMPARE_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _COMPARE_A  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	PUSH D  ; save left array
	LXI H,_COMPARE_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_STATUS_ACCUM  ; load arr right
	DAD D    ; arr offset
	MOV C,M  ; arr element to (B),C
	POP D  ; restore left array
	MOV A,C
	CMP E ; <>
	JZ __L00016 ; =
	MVI E,001H  ; rel true left
	JMP __L00017
__L00016:     ; 031d
	MVI E,000H  ; rel false left
__L00017:     ; 031f
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00018  ; skip if
	MVI E,000H  ; load const left
	RET  ; proc return
__L00018:     ; 0327
	JMP __L00013  ; END
__L00014:     ; 032a
	MVI E,001H  ; load const left
	RET  ; proc return
SETACC:     ; 032d
	LXI H,_SETACC_B  ; store proc arg 1
	MOV M,E
	LXI H,_SETACC_B  ; load var left
	MOV E,M   ; to E
	PUSH D  ; save left array
	LXI H,_SCAN_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_STATUS_ACCUM  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	LXI H,_SCAN_I  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_SCAN_I   ; assign
	MOV M,E    ; from E
	RET  ; proc return
SCAN:     ; 034f
__L00019:     ; 034f
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,00080H  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00021 ; !=
	MVI E,001H  ; rel true left
	JMP __L00022
__L00021:     ; 0365
	MVI E,000H  ; rel false left
__L00022:     ; 0367
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00020  ; skip while
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_STATUS_IBP   ; assign
	MOV M,E    ; from E
	JMP __L00019  ; END
__L00020:     ; 037b
	MVI E,000H  ; load const left
	LXI H,_SCAN_I   ; assign
	MOV M,E    ; from E
__L00023:     ; 0381
	LXI H,_SCAN_I  ; load var left
	MOV E,M   ; to E
	MVI A,004H  ; OPT MVICA
	CMP E  ; < 
	JC __L00025
	JZ __L00025
	MVI E,001H  ; rel true left
	JMP __L00026
__L00025:     ; 0393
	MVI E,000H  ; rel false left
__L00026:     ; 0395
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00024  ; skip while
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,00080H  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LXI H,_SCAN_B   ; assign
	MOV M,E    ; from E
	MVI A,001H  ; OPT MVICA
	CMP E  ; > 
	JNC __L00027
	MVI E,001H  ; rel true left
	JMP __L00028
__L00027:     ; 03b4
	MVI E,000H  ; rel false left
__L00028:     ; 03b6
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00029  ; skip if
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	CALL SETACC  ; proc call
	JMP __L00030  ; skip else
__L00029:     ; 03c5
	MVI E,020H  ; load const left
	CALL SETACC  ; proc call
__L00030:     ; 03ca
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	CMP E   ; <=
	JC __L00031
__L00033:     ; 03d4
	MVI E,001H  ; rel true left
	JMP __L00032
__L00031:     ; 03d9
	MVI E,000H  ; rel false left
__L00032:     ; 03db
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,02CH  ; OPT MVICA
	CMP E ; =
	JNZ __L00034 ; !=
	MVI C,001H  ; rel true right
	JMP __L00035
__L00034:     ; 03eb
	MVI C,000H  ; rel false right
__L00035:     ; 03ed
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,03AH  ; OPT MVICA
	CMP E ; =
	JNZ __L00036 ; !=
	MVI C,001H  ; rel true right
	JMP __L00037
__L00036:     ; 0401
	MVI C,000H  ; rel false right
__L00037:     ; 0403
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,02AH  ; OPT MVICA
	CMP E ; =
	JNZ __L00038 ; !=
	MVI C,001H  ; rel true right
	JMP __L00039
__L00038:     ; 0417
	MVI C,000H  ; rel false right
__L00039:     ; 0419
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,02EH  ; OPT MVICA
	CMP E ; =
	JNZ __L00040 ; !=
	MVI C,001H  ; rel true right
	JMP __L00041
__L00040:     ; 042d
	MVI C,000H  ; rel false right
__L00041:     ; 042f
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,03EH  ; OPT MVICA
	CMP E ; =
	JNZ __L00042 ; !=
	MVI C,001H  ; rel true right
	JMP __L00043
__L00042:     ; 0443
	MVI C,000H  ; rel false right
__L00043:     ; 0445
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,03CH  ; OPT MVICA
	CMP E ; =
	JNZ __L00044 ; !=
	MVI C,001H  ; rel true right
	JMP __L00045
__L00044:     ; 0459
	MVI C,000H  ; rel false right
__L00045:     ; 045b
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_SCAN_B  ; load var left
	MOV E,M   ; to E
	MVI A,03DH  ; OPT MVICA
	CMP E ; =
	JNZ __L00046 ; !=
	MVI C,001H  ; rel true right
	JMP __L00047
__L00046:     ; 046f
	MVI C,000H  ; rel false right
__L00047:     ; 0471
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00048  ; skip if
	MVI E,001H  ; load const left
	PUSH D  ; save left array
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,00080H  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00049  ; skip else
__L00048:     ; 048c
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_STATUS_IBP   ; assign
	MOV M,E    ; from E
__L00049:     ; 0498
	JMP __L00023  ; END
__L00024:     ; 049b
	LXI H,_STATUS_IBP  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_STATUS_IBP   ; assign
	MOV M,E    ; from E
	RET  ; proc return
PDECIMAL:     ; 04a8
	XCHG
	SHLD _PDECIMAL_V  ; store proc arg 1
	MOV L,C
	MOV H,B
	SHLD _PDECIMAL_PREC  ; store proc arg 2
	MVI E,001H  ; load const left
	LXI H,_PDECIMAL_ZEROSUP   ; assign
	MOV M,E    ; from E
__L00050:     ; 04b7
	LHLD _PDECIMAL_PREC ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00054  ; =
	JMP __L00055 ; !=
__L00054:     ; 04c6
	MOV A,B
	CMP D  ; <>
	JZ __L00052 ; =
__L00055:     ; 04cb
	MVI E,001H  ; rel true left
	JMP __L00053
__L00052:     ; 04d0
	MVI E,000H  ; rel false left
__L00053:     ; 04d2
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00051  ; skip while
	LHLD _PDECIMAL_V ; load var left
	XCHG    ; to D,E
	LHLD _PDECIMAL_PREC ; load var right
	MOV C,L
	MOV B,H ; to B,C
	LXI H,00000H  ; / init
__L00056:     ; 04e3
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	JC __L00057  ; / complete
	MOV D,A
	INX H
	JMP __L00056  ; more /
__L00057:     ; 04f0
	XCHG  ; / result to D,E
	LXI H,_PDECIMAL_D   ; assign
	MOV M,E    ; from E
	LHLD _PDECIMAL_V ; load var left
	XCHG    ; to D,E
	LHLD _PDECIMAL_PREC ; load var right
	MOV C,L
	MOV B,H ; to B,C
__L00058:     ; 04fe
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	MOV D,A
	JNC __L00058  ; more MOD
	XCHG
	DAD B
	SHLD _PDECIMAL_V ; assign
	LHLD _PDECIMAL_PREC ; load var left
	XCHG    ; to D,E
	LXI B,0000AH  ; OPT MVICB
	LXI H,00000H  ; / init
__L00059:     ; 0516
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	JC __L00060  ; / complete
	MOV D,A
	INX H
	JMP __L00059  ; more /
__L00060:     ; 0523
	SHLD _PDECIMAL_PREC ; assign
	LHLD _PDECIMAL_PREC ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00063  ; =
	JMP __L00064 ; !=
__L00063:     ; 0535
	MOV A,B
	CMP D  ; <>
	JZ __L00061 ; =
__L00064:     ; 053a
	MVI E,001H  ; rel true left
	JMP __L00062
__L00061:     ; 053f
	MVI E,000H  ; rel false left
__L00062:     ; 0541
	LXI H,_PDECIMAL_ZEROSUP  ; load var right
	MOV A,M  ; OPT MOVMCA
	ANA E    ; & left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_PDECIMAL_D  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; =
	JNZ __L00065 ; !=
	MVI C,001H  ; rel true right
	JMP __L00066
__L00065:     ; 0557
	MVI C,000H  ; rel false right
__L00066:     ; 0559
	POP D  ; restore left binary
	MOV A,C
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00067  ; skip if
	CALL PRINTB  ; proc call
	JMP __L00068  ; skip else
__L00067:     ; 0568
	MVI E,000H  ; load const left
	LXI H,_PDECIMAL_ZEROSUP   ; assign
	MOV M,E    ; from E
	MVI E,030H  ; load const left
	LXI H,_PDECIMAL_D  ; load var right
	MOV A,M  ; OPT MOVMCA
	ADD E    ; + left
	MOV E,A  ; result to E
	CALL PRINTCHAR  ; proc call
__L00068:     ; 0579
	JMP __L00050  ; END
__L00051:     ; 057c
	RET  ; proc return
ADDBLOCK:     ; 057d
	XCHG
	SHLD _ADDBLOCK_AK  ; store proc arg 1
	MOV L,C
	MOV H,B
	SHLD _ADDBLOCK_AB  ; store proc arg 2
	LHLD _ADDBLOCK_AB  ; load based left
	MOV E,M
	INX H
	MOV D,M  ; to D,E
	LHLD _STATUS_BPB ; load var right
	MOV C,L
	MOV B,H ; to B,C
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LHLD _ADDBLOCK_AB  ; assign based
	MOV M,E
	INX H
	MOV M,D  ; from D,E
__L00069:     ; 059a
	LHLD _ADDBLOCK_AB  ; load based left
	MOV E,M
	INX H
	MOV D,M  ; to D,E
	LXI B,00400H  ; load const right
	MOV A,D
	CMP B  ; >=
	JZ __L00073  ; =
	JC __L00071  ; <
	JMP __L00074 ; >
__L00073:     ; 05ae
	MOV A,E
	CMP C  ; >=
	JC __L00071  ; <
__L00074:     ; 05b3
	MVI E,001H  ; rel true left
	JMP __L00072
__L00071:     ; 05b8
	MVI E,000H  ; rel false left
__L00072:     ; 05ba
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00070  ; skip while
	LHLD _ADDBLOCK_AB  ; load based left
	MOV E,M
	INX H
	MOV D,M  ; to D,E
	LXI B,00400H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A
	MOV A,D
	SBB B
	MOV D,A  ; result to D,E
	LHLD _ADDBLOCK_AB  ; assign based
	MOV M,E
	INX H
	MOV M,D  ; from D,E
	LHLD _ADDBLOCK_AK  ; load based left
	MOV E,M
	INX H
	MOV D,M  ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LHLD _ADDBLOCK_AK  ; assign based
	MOV M,E
	INX H
	MOV M,D  ; from D,E
	JMP __L00069  ; END
__L00070:     ; 05e9
	RET  ; proc return
COUNT:     ; 05ea
	LXI H,_COUNT_MODE  ; store proc arg 1
	MOV M,E
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _COUNT_KA ; assign
	SHLD _COUNT_BA ; assign
	MVI E,000H  ; load const left
	LXI H,_COUNT_BIT   ; assign
	MOV M,E    ; from E
	LXI D,00000H  ; OPT MVIED
	XCHG     ; from D,E
	JMP __L00077  ; DO first iter
__L00075:     ; 0605
	LHLD DPBA  ; load struct based left
	LXI D,00005H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	LHLD _COUNT_I  ; DO load
	INX H    ; DO update
	MOV A,H
	CMP D   ; DO <=
	JZ __L00078   ; =
	JNC __L00076  ; > DO complete
	JMP __L00077  ; <
__L00078:     ; 061e
	MOV A,L
	CMP E   ; DO <=
	JZ __L00077   ; =
	JNC __L00076  ; > DO complete
__L00077:     ; 0626
	SHLD _COUNT_I  ; DO assign
	LXI H,_COUNT_MODE  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00079  ; skip if
	LHLD _COUNT_I ; load var left
	XCHG    ; to D,E
	CALL GETALLOC  ; proc call
	LXI H,_COUNT_BIT   ; assign
	MOV M,E    ; from E
__L00079:     ; 0641
	LXI H,_COUNT_BIT  ; load var left
	MOV E,M   ; to E
	MOV A,E
	CMA      ; NOT left
	ANI 001H
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00080  ; skip if
	LXI D,_COUNT_KA  ; load ref left
	LXI B,_COUNT_BA  ; load ref right
	CALL ADDBLOCK  ; proc call
__L00080:     ; 0658
	JMP __L00075  ; END
__L00076:     ; 065b
	LHLD _COUNT_KA ; load var left
	XCHG    ; to D,E
	RET  ; proc return
ABORTMSG:     ; 0660
	LXI D,__L00081  ; load ref left
	CALL PRINT  ; proc call
	RET  ; proc return
_USERSTATUS_UFCB	DB  03FH,03FH,03FH,03FH,03FH,03FH,03FH,03FH,03FH,03FH,03FH,03FH,000H,000H,000H    ; 0667
USERSTATUS:     ; 0676
	LXI D,__L00082  ; load ref left
	CALL PRINT  ; proc call
	CALL GETUSER  ; proc call
	MVI C,00AH  ; load const right
	MVI D,000H  ; zero pad MSB
	MVI B,000H  ; zero pad MSB
	CALL PDECIMAL  ; proc call
	LXI D,__L00083  ; load ref left
	CALL PRINT  ; proc call
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00086  ; DO first iter
__L00084:     ; 0694
	MVI E,01FH  ; LAST low left
	LDA _USERSTATUS_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00086   ; = 
	JNC __L00085  ; > DO complete
__L00086:     ; 06a1
	STA _USERSTATUS_I  ; DO assign
	MVI E,000H  ; load const left
	PUSH D  ; save left array
	LXI H,_USERSTATUS_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_USERSTATUS_USER  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00084  ; END
__L00085:     ; 06b6
	LXI D,MEMORY  ; load ref left
	CALL SETDMA  ; proc call
	LXI D,_USERSTATUS_UFCB  ; load ref left
	CALL SEARCH  ; proc call
__L00087:     ; 06c2
	LXI H,_STATUS_DCNT  ; load var left
	MOV E,M   ; to E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; <>
	JZ __L00089 ; =
	MVI E,001H  ; rel true left
	JMP __L00090
__L00089:     ; 06d1
	MVI E,000H  ; rel false left
__L00090:     ; 06d3
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00088  ; skip while
	LXI H,_STATUS_DCNT  ; load var left
	MOV E,M   ; to E
	MVI A,003H  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	MVI C,005H  ; load const right
__L00093:     ; 06e2
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00093  ; more SHL
	MVI D,000H  ; zero pad index MSB
	LXI H,MEMORY  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LXI H,_USERSTATUS_I   ; assign
	MOV M,E    ; from E
	MVI A,0E5H  ; OPT MVICA
	CMP E ; <>
	JZ __L00091 ; =
	MVI E,001H  ; rel true left
	JMP __L00092
__L00091:     ; 0701
	MVI E,000H  ; rel false left
__L00092:     ; 0703
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00094  ; skip if
	MVI E,001H  ; load const left
	PUSH D  ; save left array
	LXI H,_USERSTATUS_I  ; load var left
	MOV E,M   ; to E
	MVI A,01FH  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_USERSTATUS_USER  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
__L00094:     ; 071b
	CALL SEARCHN  ; proc call
	JMP __L00087  ; END
__L00088:     ; 0721
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00097  ; DO first iter
__L00095:     ; 0727
	MVI E,01FH  ; LAST low left
	LDA _USERSTATUS_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00097   ; = 
	JNC __L00096  ; > DO complete
__L00097:     ; 0734
	STA _USERSTATUS_I  ; DO assign
	LXI H,_USERSTATUS_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_USERSTATUS_USER  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00098  ; skip if
	LXI H,_USERSTATUS_I  ; load var left
	MOV E,M   ; to E
	MVI C,00AH  ; load const right
	MVI D,000H  ; zero pad MSB
	MVI B,000H  ; zero pad MSB
	CALL PDECIMAL  ; proc call
__L00098:     ; 0758
	JMP __L00095  ; END
__L00096:     ; 075b
	RET  ; proc return
PV:     ; 075c
	XCHG
	SHLD _PV_V  ; store proc arg 1
	CALL CRLF  ; proc call
	LHLD _PV_V ; load var left
	XCHG    ; to D,E
	LXI B,02710H  ; load const right
	CALL PDECIMAL  ; proc call
	MVI E,03AH  ; load const left
	CALL PRINTCHAR  ; proc call
	JMP PRINTB  ; OPT CALLRET
DRIVESTATUS:     ; 0775
	LXI D,__L00099  ; load ref left
	CALL PRINT  ; proc call
	CALL CSELECT  ; proc call
	MVI A,041H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	CALL PRINTCHAR  ; proc call
	MVI E,03AH  ; load const left
	CALL PRINTCHAR  ; proc call
	LXI D,__L00100  ; load ref left
	CALL PRINTX  ; proc call
	LXI D,00001H  ; OPT MVIED
	LHLD DPBA  ; load struct based right
	LXI B,00002H
	DAD B     ; struct offset
	MOV C,M   ; to (B),C
__L00101:     ; 079b
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	DCR C
	JNZ __L00101  ; more SHL
	XCHG    ; from D,E
	SHLD _DRIVESTATUS_RPB ; assign
	LHLD DPBA  ; load struct based left
	LXI D,00005H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LHLD _DRIVESTATUS_RPB ; load var right
	MOV C,L
	MOV B,H ; to B,C
	MVI A,010H  ; * count
	LXI H,00000H  ; * init
__L00105:     ; 07c5
	PUSH PSW  ; * save count
	MOV A,B
	RAR
	MOV B,A
	MOV A,C
	RAR
	MOV C,A
	JNC __L00106  ; * check bits of right arg
	DAD D
__L00106:     ; 07d0
	XCHG
	DAD H
	XCHG
	POP PSW ;  * check count
	DCR A
	JNZ __L00105 ;  * more bits
	SHLD _DRIVESTATUS_RPD ; assign
	XCHG    ; restore D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; =
	JNZ __L00103 ; !=
	MOV A,B
	CMP D  ; =
	JNZ __L00103 ; !=
	MVI E,001H  ; rel true left
	JMP __L00104
__L00103:     ; 07ee
	MVI E,000H  ; rel false left
__L00104:     ; 07f0
	PUSH D ; save left binary
	LHLD _DRIVESTATUS_RPB ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00109  ; =
	JMP __L00110 ; !=
__L00109:     ; 0800
	MOV A,B
	CMP D  ; <>
	JZ __L00107 ; =
__L00110:     ; 0805
	MVI C,001H  ; rel true right
	JMP __L00108
__L00107:     ; 080a
	MVI C,000H  ; rel false right
__L00108:     ; 080c
	POP D  ; restore left binary
	MOV A,C
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00111  ; skip if
	LXI D,__L00102  ; load ref left
	CALL PRINT  ; proc call
	JMP __L00112  ; skip else
__L00111:     ; 081e
	LHLD _DRIVESTATUS_RPD ; load var left
	XCHG    ; to D,E
	CALL PV  ; proc call
__L00112:     ; 0825
	LXI D,__L00113  ; load ref left
	CALL PRINTX  ; proc call
	MVI E,000H  ; load const left
	CALL COUNT  ; proc call
	CALL PV  ; proc call
	LXI D,__L00114  ; load ref left
	CALL PRINTX  ; proc call
	LHLD DPBA  ; load struct based left
	LXI D,00007H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	CALL PV  ; proc call
	LXI D,__L00115  ; load ref left
	CALL PRINTX  ; proc call
	LHLD DPBA  ; load struct based left
	LXI D,0000BH
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	MVI C,002H  ; load const right
__L00116:     ; 085e
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	DCR C
	JNZ __L00116  ; more SHL
	CALL PV  ; proc call
	LXI D,__L00117  ; load ref left
	CALL PRINTX  ; proc call
	LHLD DPBA  ; load struct based left
	LXI D,00004H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	MVI C,080H  ; load const right
	MVI D,000H  ; zero pad MSB
	MVI B,008H  ; * count
	LXI H,00000H  ; * init
__L00118:     ; 0888
	MOV A,C
	RAR
	MOV C,A
	JNC __L00119  ; * check bits of right arg
	DAD D
__L00119:     ; 088f
	XCHG
	DAD H
	XCHG
	DCR B  ; check count
	JNZ __L00118 ;  * more bits
	XCHG  ; * result do D,E
	CALL PV  ; proc call
	LXI D,__L00120  ; load ref left
	CALL PRINTX  ; proc call
	LHLD _DRIVESTATUS_RPB ; load var left
	XCHG    ; to D,E
	CALL PV  ; proc call
	LXI D,__L00121  ; load ref left
	CALL PRINTX  ; proc call
	LHLD DPBA  ; load struct based left
	LXI D,00000H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	CALL PV  ; proc call
	LXI D,__L00122  ; load ref left
	CALL PRINTX  ; proc call
	LHLD DPBA  ; load struct based left
	LXI D,0000DH
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	CALL PV  ; proc call
	LXI D,__L00123  ; load ref left
	CALL PRINTX  ; proc call
	JMP CRLF  ; OPT CALLRET
DISKSTATUS:     ; 08d6
	CALL GETLOGIN  ; proc call
	XCHG    ; from D,E
	SHLD _DISKSTATUS_LOGIN ; assign
	MVI E,000H  ; load const left
	LXI H,_DISKSTATUS_D   ; assign
	MOV M,E    ; from E
__L00124:     ; 08e3
	LHLD _DISKSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00128  ; =
	JMP __L00129 ; !=
__L00128:     ; 08f2
	MOV A,B
	CMP D  ; <>
	JZ __L00126 ; =
__L00129:     ; 08f7
	MVI E,001H  ; rel true left
	JMP __L00127
__L00126:     ; 08fc
	MVI E,000H  ; rel false left
__L00127:     ; 08fe
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00125  ; skip while
	LHLD _DISKSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00130  ; skip if
	LXI H,_DISKSTATUS_D  ; load var left
	MOV E,M   ; to E
	CALL SELECTDISK  ; proc call
	CALL DRIVESTATUS  ; proc call
__L00130:     ; 091a
	LHLD _DISKSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	MVI C,001H  ; load const right
__L00131:     ; 0920
	STC
	CMC
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR  ; SHR
	MOV E,A
	DCR C
	JNZ __L00131  ; more SHR
	XCHG    ; from D,E
	SHLD _DISKSTATUS_LOGIN ; assign
	LXI H,_DISKSTATUS_D  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_DISKSTATUS_D   ; assign
	MOV M,E    ; from E
	JMP __L00124  ; END
__L00125:     ; 093f
	RET  ; proc return
MATCH:     ; 0940
	XCHG
	SHLD _MATCH_VA  ; store proc arg 1
	LXI H,_MATCH_VL  ; store proc arg 2
	MOV M,C
	MVI E,000H  ; load const left
	LXI H,_MATCH_J   ; assign
	MOV M,E    ; from E
	LXI H,_MATCH_SYNC   ; assign
	MOV M,E    ; from E
	MVI E,001H  ; load const left
	MOV A,E
	JMP __L00134  ; DO first iter
__L00132:     ; 0958
	LXI H,_MATCH_VL  ; load var left
	MOV E,M   ; to E
	LDA _MATCH_SYNC  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00134   ; = 
	JNC __L00133  ; > DO complete
__L00134:     ; 0967
	STA _MATCH_SYNC  ; DO assign
	MVI E,001H  ; load const left
	LXI H,_MATCH_MATCH   ; assign
	MOV M,E    ; from E
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00137  ; DO first iter
__L00135:     ; 0976
	MVI E,003H  ; load const left
	LDA _MATCH_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00137   ; = 
	JNC __L00136  ; > DO complete
__L00137:     ; 0983
	STA _MATCH_I  ; DO assign
	LXI H,_MATCH_J  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _MATCH_VA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	PUSH D  ; save left array
	LXI H,_MATCH_I  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LXI H,_STATUS_ACCUM  ; load arr right
	DAD D    ; arr offset
	MOV C,M  ; arr element to (B),C
	POP D  ; restore left array
	MOV A,C
	CMP E ; <>
	JZ __L00138 ; =
	MVI E,001H  ; rel true left
	JMP __L00139
__L00138:     ; 09a8
	MVI E,000H  ; rel false left
__L00139:     ; 09aa
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00140  ; skip if
	MVI E,000H  ; load const left
	LXI H,_MATCH_MATCH   ; assign
	MOV M,E    ; from E
__L00140:     ; 09b5
	LXI H,_MATCH_J  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_MATCH_J   ; assign
	MOV M,E    ; from E
	JMP __L00135  ; END
__L00136:     ; 09c4
	LXI H,_MATCH_MATCH  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00141  ; skip if
	LXI H,_MATCH_SYNC  ; load var left
	MOV E,M   ; to E
	RET  ; proc return
__L00141:     ; 09d6
	JMP __L00132  ; END
__L00133:     ; 09d9
	MVI E,000H  ; load const left
	RET  ; proc return
_STATUS_DEVL	DB  043H,04FH,04EH,03AH,052H,044H,052H,03AH,050H,055H,04EH,03AH,04CH,053H,054H,03AH,044H,045H,056H,03AH,056H,041H,04CH,03AH,055H,053H,052H,03AH,044H,053H,04BH,03AH    ; 09dc
_DEVREQ_DEVR	DB  054H,054H,059H,03AH,043H,052H,054H,03AH,042H,041H,054H,03AH,055H,043H,031H,03AH,054H,054H,059H,03AH,050H,054H,052H,03AH,055H,052H,031H,03AH,055H,052H,032H,03AH,054H,054H,059H,03AH,050H,054H,050H,03AH,055H,050H,031H,03AH,055H,050H,032H,03AH,054H,054H,059H,03AH,043H,052H,054H,03AH,04CH,050H,054H,03AH,055H,04CH,031H,03AH    ; 09fc
PRNAME:     ; 0a3c
	XCHG
	SHLD _PRNAME_A  ; store proc arg 1
__L00142:     ; 0a40
	LHLD _PRNAME_A  ; load based left
	MOV E,M   ; to E
	MVI A,03AH  ; OPT MVICA
	CMP E ; <>
	JZ __L00144 ; =
	MVI E,001H  ; rel true left
	JMP __L00145
__L00144:     ; 0a4f
	MVI E,000H  ; rel false left
__L00145:     ; 0a51
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00143  ; skip while
	LHLD _PRNAME_A  ; load based left
	MOV E,M   ; to E
	CALL PRINTCHAR  ; proc call
	LHLD _PRNAME_A ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _PRNAME_A ; assign
	JMP __L00142  ; END
__L00143:     ; 0a6c
	MVI E,03AH  ; load const left
	JMP PRINTCHAR  ; OPT CALLRET
DEVREQ:     ; 0a71
	MVI E,000H  ; load const left
	LXI H,_DEVREQ_ITEMS   ; assign
	MOV M,E    ; from E
__L00146:     ; 0a77
	MVI E,001H  ; load const left
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00147  ; skip while
	CALL SCAN  ; proc call
	LXI D,_STATUS_DEVL  ; load ref left
	MVI C,008H  ; load const right
	CALL MATCH  ; proc call
	LXI H,_DEVREQ_I   ; assign
	MOV M,E    ; from E
	MVI A,000H  ; OPT MVICA
	CMP E ; =
	JNZ __L00150 ; !=
	MVI E,001H  ; rel true left
	JMP __L00151
__L00150:     ; 0a9c
	MVI E,000H  ; rel false left
__L00151:     ; 0a9e
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00152  ; skip if
	LXI H,_DEVREQ_ITEMS  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00148 ; =
	MVI E,001H  ; rel true left
	JMP __L00149
__L00148:     ; 0ab2
	MVI E,000H  ; rel false left
__L00149:     ; 0ab4
	RET  ; proc return
__L00152:     ; 0ab5
	LXI H,_DEVREQ_ITEMS  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_ITEMS   ; assign
	MOV M,E    ; from E
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI A,005H  ; OPT MVICA
	CMP E ; =
	JNZ __L00153 ; !=
	MVI E,001H  ; rel true left
	JMP __L00154
__L00153:     ; 0ad0
	MVI E,000H  ; rel false left
__L00154:     ; 0ad2
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00155  ; skip if
	LXI H,00003H  ; load var left
	MOV E,M   ; to E
	LXI H,_DEVREQ_IOBYTE   ; assign
	MOV M,E    ; from E
	MVI E,000H  ; load const left
	LXI H,_DEVREQ_J   ; assign
	MOV M,E    ; from E
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00158  ; DO first iter
__L00156:     ; 0aeb
	MVI E,003H  ; load const left
	LDA _DEVREQ_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00158   ; = 
	JNC __L00157  ; > DO complete
__L00158:     ; 0af8
	STA _DEVREQ_I  ; DO assign
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00159:     ; 0b01
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00159  ; more SHL
	MVI D,000H  ; zero pad MSB
	LXI H,_STATUS_DEVL  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	CALL PRNAME  ; proc call
	LXI D,__L00160  ; load ref left
	CALL PRINTX  ; proc call
	LXI H,_DEVREQ_IOBYTE  ; load var left
	MOV E,M   ; to E
	MVI A,003H  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	MVI C,002H  ; load const right
__L00161:     ; 0b24
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00161  ; more SHL
	LXI H,_DEVREQ_J  ; load var right
	MOV A,M  ; OPT MOVMCA
	ADD E    ; + left
	MOV E,A  ; result to E
	MVI D,000H  ; zero pad MSB
	LXI H,_DEVREQ_DEVR  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	CALL PRNAME  ; proc call
	LXI H,_DEVREQ_J  ; load var left
	MOV E,M   ; to E
	MVI A,010H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_J   ; assign
	MOV M,E    ; from E
	LXI H,_DEVREQ_IOBYTE  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00162:     ; 0b4f
	STC
	CMC
	MOV A,E
	RAR  ; SHR
	MOV E,A
	DCR C
	JNZ __L00162  ; more SHR
	LXI H,_DEVREQ_IOBYTE   ; assign
	MOV M,E    ; from E
	CALL CRLF  ; proc call
	JMP __L00156  ; END
__L00157:     ; 0b62
	JMP __L00166  ; skip else
__L00155:     ; 0b65
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI A,006H  ; OPT MVICA
	CMP E ; =
	JNZ __L00163 ; !=
	MVI E,001H  ; rel true left
	JMP __L00164
__L00163:     ; 0b74
	MVI E,000H  ; rel false left
__L00164:     ; 0b76
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00165  ; skip if
	LXI D,__L00167  ; load ref left
	CALL PRINT  ; proc call
	LXI D,__L00168  ; load ref left
	CALL PRINT  ; proc call
	LXI D,__L00169  ; load ref left
	CALL PRINT  ; proc call
	LXI D,__L00170  ; load ref left
	CALL PRINT  ; proc call
	LXI D,__L00171  ; load ref left
	CALL PRINT  ; proc call
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00174  ; DO first iter
__L00172:     ; 0b9f
	MVI E,003H  ; load const left
	LDA _DEVREQ_I  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00174   ; = 
	JNC __L00173  ; > DO complete
__L00174:     ; 0bac
	STA _DEVREQ_I  ; DO assign
	CALL CRLF  ; proc call
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00175:     ; 0bb8
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00175  ; more SHL
	MVI D,000H  ; zero pad MSB
	LXI H,_STATUS_DEVL  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	CALL PRNAME  ; proc call
	LXI D,__L00176  ; load ref left
	CALL PRINTX  ; proc call
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00179  ; DO first iter
__L00177:     ; 0bd7
	MVI E,00CH  ; load const left
	LDA _DEVREQ_J  ; DO load
	ADI 004H  ; DO update
	CMP E   ; DO <=
	JZ __L00179   ; = 
	JNC __L00178  ; > DO complete
__L00179:     ; 0be5
	STA _DEVREQ_J  ; DO assign
	MVI E,020H  ; load const left
	CALL PRINTCHAR  ; proc call
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI C,004H  ; load const right
__L00180:     ; 0bf3
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00180  ; more SHL
	LXI H,_DEVREQ_J  ; load var right
	MOV A,M  ; OPT MOVMCA
	ADD E    ; + left
	MOV E,A  ; result to E
	MVI D,000H  ; zero pad MSB
	LXI H,_DEVREQ_DEVR  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	CALL PRNAME  ; proc call
	JMP __L00177  ; END
__L00178:     ; 0c0f
	JMP __L00172  ; END
__L00173:     ; 0c12
__L00166:     ; 0c12
	JMP __L00184  ; skip else
__L00165:     ; 0c15
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI A,007H  ; OPT MVICA
	CMP E ; =
	JNZ __L00181 ; !=
	MVI E,001H  ; rel true left
	JMP __L00182
__L00181:     ; 0c24
	MVI E,000H  ; rel false left
__L00182:     ; 0c26
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00183  ; skip if
	CALL USERSTATUS  ; proc call
	MVI E,001H  ; load const left
	RET  ; proc return
__L00184:     ; 0c31
	JMP __L00188  ; skip else
__L00183:     ; 0c34
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI A,008H  ; OPT MVICA
	CMP E ; =
	JNZ __L00185 ; !=
	MVI E,001H  ; rel true left
	JMP __L00186
__L00185:     ; 0c43
	MVI E,000H  ; rel false left
__L00186:     ; 0c45
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00187  ; skip if
	CALL DISKSTATUS  ; proc call
__L00188:     ; 0c4d
	JMP __L00189  ; skip else
__L00187:     ; 0c50
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_I   ; assign
	MOV M,E    ; from E
	MVI C,004H  ; load const right
__L00190:     ; 0c5f
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00190  ; more SHL
	LXI H,_DEVREQ_J   ; assign
	MOV M,E    ; from E
	CALL SCAN  ; proc call
	LXI D,00000H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,03DH  ; OPT MVICA
	CMP E ; <>
	JZ __L00191 ; =
	MVI E,001H  ; rel true left
	JMP __L00192
__L00191:     ; 0c82
	MVI E,000H  ; rel false left
__L00192:     ; 0c84
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00193  ; skip if
	LXI D,__L00194  ; load ref left
	CALL PRINT  ; proc call
	MVI E,001H  ; load const left
	RET  ; proc return
__L00193:     ; 0c92
	CALL SCAN  ; proc call
	LXI H,_DEVREQ_J  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad MSB
	LXI H,_DEVREQ_DEVR  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	MVI C,004H  ; load const right
	CALL MATCH  ; proc call
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_J   ; assign
	MOV M,E    ; from E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; =
	JNZ __L00195 ; !=
	MVI E,001H  ; rel true left
	JMP __L00196
__L00195:     ; 0cb9
	MVI E,000H  ; rel false left
__L00196:     ; 0cbb
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00197  ; skip if
	LXI D,__L00198  ; load ref left
	CALL PRINT  ; proc call
	MVI E,001H  ; load const left
	RET  ; proc return
__L00197:     ; 0cc9
	MVI E,0FCH  ; load const left
	LXI H,_DEVREQ_IOBYTE   ; assign
	MOV M,E    ; from E
__L00199:     ; 0ccf
	LXI H,_DEVREQ_I  ; load var left
	MOV E,M   ; to E
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_I   ; assign
	MOV M,E    ; from E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; <>
	JZ __L00201 ; =
	MVI E,001H  ; rel true left
	JMP __L00202
__L00201:     ; 0ce7
	MVI E,000H  ; rel false left
__L00202:     ; 0ce9
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00200  ; skip while
	LXI H,_DEVREQ_IOBYTE  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00203:     ; 0cf4
	MOV A,E
	RLC  ; ROL
	MOV E,A
	DCR C
	JNZ __L00203  ; more ROL
	LXI H,_DEVREQ_IOBYTE   ; assign
	MOV M,E    ; from E
	LXI H,_DEVREQ_J  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00204:     ; 0d05
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00204  ; more SHL
	LXI H,_DEVREQ_J   ; assign
	MOV M,E    ; from E
	JMP __L00199  ; END
__L00200:     ; 0d15
	LXI H,00003H  ; load var left
	MOV E,M   ; to E
	LXI H,_DEVREQ_IOBYTE  ; load var right
	MOV A,M  ; OPT MOVMCA
	ANA E    ; & left
	MOV E,A  ; result to E
	LXI H,_DEVREQ_J  ; load var right
	MOV A,M  ; OPT MOVMCA
	ORA E    ; | left
	MOV E,A  ; result to E
	LXI H,00003H   ; assign
	MOV M,E    ; from E
__L00189:     ; 0d29
	CALL SCAN  ; proc call
	LXI D,00000H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00205 ; !=
	MVI E,001H  ; rel true left
	JMP __L00206
__L00205:     ; 0d3f
	MVI E,000H  ; rel false left
__L00206:     ; 0d41
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00207  ; skip if
	MVI E,001H  ; load const left
	RET  ; proc return
__L00207:     ; 0d49
	LXI D,00000H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,02CH  ; OPT MVICA
	CMP E ; <>
	JZ __L00208 ; =
	MVI E,001H  ; rel true left
	JMP __L00209
__L00208:     ; 0d5c
	MVI E,000H  ; rel false left
__L00209:     ; 0d5e
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00210  ; skip if
	LXI D,__L00211  ; load ref left
	CALL PRINT  ; proc call
	MVI E,001H  ; load const left
	RET  ; proc return
__L00210:     ; 0d6c
	JMP __L00146  ; END
__L00147:     ; 0d6f
	RET  ; proc return
PVALUE:     ; 0d70
	XCHG
	SHLD _PVALUE_V  ; store proc arg 1
	LXI D,02710H  ; load const left
	XCHG    ; from D,E
	SHLD _PVALUE_K ; assign
	MVI E,000H  ; load const left
	LXI H,_PVALUE_ZERO   ; assign
	MOV M,E    ; from E
__L00212:     ; 0d81
	LHLD _PVALUE_K ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00216  ; =
	JMP __L00217 ; !=
__L00216:     ; 0d90
	MOV A,B
	CMP D  ; <>
	JZ __L00214 ; =
__L00217:     ; 0d95
	MVI E,001H  ; rel true left
	JMP __L00215
__L00214:     ; 0d9a
	MVI E,000H  ; rel false left
__L00215:     ; 0d9c
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00213  ; skip while
	LHLD _PVALUE_V ; load var left
	XCHG    ; to D,E
	LHLD _PVALUE_K ; load var right
	MOV C,L
	MOV B,H ; to B,C
	LXI H,00000H  ; / init
__L00218:     ; 0dad
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	JC __L00219  ; / complete
	MOV D,A
	INX H
	JMP __L00218  ; more /
__L00219:     ; 0dba
	XCHG  ; / result to D,E
	LXI H,_PVALUE_D   ; assign
	MOV M,E    ; from E
	LHLD _PVALUE_V ; load var left
	XCHG    ; to D,E
	LHLD _PVALUE_K ; load var right
	MOV C,L
	MOV B,H ; to B,C
__L00220:     ; 0dc8
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	MOV D,A
	JNC __L00220  ; more MOD
	XCHG
	DAD B
	SHLD _PVALUE_V ; assign
	LHLD _PVALUE_K ; load var left
	XCHG    ; to D,E
	LXI B,0000AH  ; OPT MVICB
	LXI H,00000H  ; / init
__L00221:     ; 0de0
	MOV A,E
	SUB C
	MOV E,A
	MOV A,D
	SBB B
	JC __L00222  ; / complete
	MOV D,A
	INX H
	JMP __L00221  ; more /
__L00222:     ; 0ded
	SHLD _PVALUE_K ; assign
	LXI H,_PVALUE_ZERO  ; load var left
	MOV E,M   ; to E
	PUSH D ; save left binary
	LHLD _PVALUE_K ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; =
	JNZ __L00223 ; !=
	MOV A,B
	CMP D  ; =
	JNZ __L00223 ; !=
	MVI C,001H  ; rel true right
	JMP __L00224
__L00223:     ; 0e0b
	MVI C,000H  ; rel false right
__L00224:     ; 0e0d
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LXI H,_PVALUE_D  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00225 ; =
	MVI C,001H  ; rel true right
	JMP __L00226
__L00225:     ; 0e21
	MVI C,000H  ; rel false right
__L00226:     ; 0e23
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00227  ; skip if
	MVI E,001H  ; load const left
	LXI H,_PVALUE_ZERO   ; assign
	MOV M,E    ; from E
	MVI E,030H  ; load const left
	LXI H,_PVALUE_D  ; load var right
	MOV A,M  ; OPT MOVMCA
	ADD E    ; + left
	MOV E,A  ; result to E
	CALL PRINTCHAR  ; proc call
__L00227:     ; 0e3d
	JMP __L00212  ; END
__L00213:     ; 0e40
	MVI E,06BH  ; load const left
	CALL PRINTCHAR  ; proc call
	JMP CRLF  ; OPT CALLRET
COMPALLOC:     ; 0e48
	CALL GETALLOCA  ; proc call
	XCHG    ; from D,E
	SHLD _STATUS_ALLOCA ; assign
	CALL CSELECT  ; proc call
	MVI A,041H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	CALL PRINTCHAR  ; proc call
	LXI D,__L00228  ; load ref left
	JMP PRINTX  ; OPT CALLRET
PRCOUNT:     ; 0e5f
	MVI E,001H  ; load const left
	CALL COUNT  ; proc call
	CALL PVALUE  ; proc call
	RET  ; proc return
PRALLOC:     ; 0e68
	LXI D,__L00229  ; load ref left
	CALL PRINT  ; proc call
	CALL COMPALLOC  ; proc call
	JMP PRCOUNT  ; OPT CALLRET
PRSTATUS:     ; 0e74
	CALL GETLOGIN  ; proc call
	XCHG    ; from D,E
	SHLD _PRSTATUS_LOGIN ; assign
	CALL GETRODISK  ; proc call
	XCHG    ; from D,E
	SHLD _PRSTATUS_RODISK ; assign
	MVI E,000H  ; load const left
	LXI H,_PRSTATUS_D   ; assign
	MOV M,E    ; from E
__L00230:     ; 0e88
	LHLD _PRSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; <>
	JZ __L00234  ; =
	JMP __L00235 ; !=
__L00234:     ; 0e97
	MOV A,B
	CMP D  ; <>
	JZ __L00232 ; =
__L00235:     ; 0e9c
	MVI E,001H  ; rel true left
	JMP __L00233
__L00232:     ; 0ea1
	MVI E,000H  ; rel false left
__L00233:     ; 0ea3
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00231  ; skip while
	LHLD _PRSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00236  ; skip if
	LXI H,_PRSTATUS_D  ; load var left
	MOV E,M   ; to E
	CALL SELECTDISK  ; proc call
	CALL COMPALLOC  ; proc call
	LXI D,__L00237  ; load ref left
	CALL PRINTX  ; proc call
	LHLD _PRSTATUS_RODISK ; load var left
	XCHG    ; to D,E
	MVI A,001H  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00238  ; skip if
	MVI E,04FH  ; load const left
	CALL PRINTCHAR  ; proc call
	JMP __L00239  ; skip else
__L00238:     ; 0eda
	MVI E,057H  ; load const left
	CALL PRINTCHAR  ; proc call
__L00239:     ; 0edf
	LXI D,__L00240  ; load ref left
	CALL PRINTX  ; proc call
	CALL PRCOUNT  ; proc call
__L00236:     ; 0ee8
	LHLD _PRSTATUS_LOGIN ; load var left
	XCHG    ; to D,E
	MVI C,001H  ; load const right
__L00241:     ; 0eee
	STC
	CMC
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR  ; SHR
	MOV E,A
	DCR C
	JNZ __L00241  ; more SHR
	XCHG    ; from D,E
	SHLD _PRSTATUS_LOGIN ; assign
	LHLD _PRSTATUS_RODISK ; load var left
	XCHG    ; to D,E
	MVI C,001H  ; load const right
__L00242:     ; 0f04
	STC
	CMC
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR  ; SHR
	MOV E,A
	DCR C
	JNZ __L00242  ; more SHR
	XCHG    ; from D,E
	SHLD _PRSTATUS_RODISK ; assign
	LXI H,_PRSTATUS_D  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	LXI H,_PRSTATUS_D   ; assign
	MOV M,E    ; from E
	JMP __L00230  ; END
__L00231:     ; 0f23
	JMP CRLF  ; OPT CALLRET
SETDISK:     ; 0f26
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00243 ; =
	MVI E,001H  ; rel true left
	JMP __L00244
__L00243:     ; 0f39
	MVI E,000H  ; rel false left
__L00244:     ; 0f3b
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00245  ; skip if
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	CALL SELECTDISK  ; proc call
__L00245:     ; 0f50
	RET  ; proc return
MULTI16:     ; 0f51
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	MVI C,004H  ; load const right
__L00246:     ; 0f57
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	DCR C
	JNZ __L00246  ; more SHL
	LXI B,MEMORY  ; load ref right
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_FCBSA ; assign
	RET  ; proc return
_GETFILE_FSTATLIST	DB  052H,02FH,04FH,000H,052H,02FH,057H,000H,053H,059H,053H,000H,044H,049H,052H,000H    ; 0f6c
_SETFILESTATUS_FSTAT	DB  052H,02FH,04FH,020H,052H,02FH,057H,020H,053H,059H,053H,020H,044H,049H,052H,020H    ; 0f7c
SETFILESTATUS:     ; 0f8c
	LXI H,0006DH  ; load var left
	MOV E,M   ; to E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00247 ; !=
	MVI E,001H  ; rel true left
	JMP __L00248
__L00247:     ; 0f9b
	MVI E,000H  ; rel false left
__L00248:     ; 0f9d
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00249  ; skip if
	MVI E,000H  ; load const left
	RET  ; proc return
__L00249:     ; 0fa5
	LXI D,_STATUS_ACCUM  ; load ref left
	PUSH D  ; proc ext arg
	MVI E,004H  ; load const left
	LXI B,0006EH  ; load ref right
	CALL MOVE  ; proc call
	POP H  ; proc ext arg discard
	LXI D,00000H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,053H  ; OPT MVICA
	CMP E ; =
	JNZ __L00250 ; !=
	MVI E,001H  ; rel true left
	JMP __L00251
__L00250:     ; 0fc5
	MVI E,000H  ; rel false left
__L00251:     ; 0fc7
	PUSH D ; save left binary
	LXI D,00001H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00252 ; !=
	MVI C,001H  ; rel true right
	JMP __L00253
__L00252:     ; 0fdb
	MVI C,000H  ; rel false right
__L00253:     ; 0fdd
	POP D  ; restore left binary
	MOV A,C
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00254  ; skip if
	MVI E,001H  ; load const left
	LXI H,SIZESET   ; assign
	MOV M,E    ; from E
	MOV A,E
	CMA      ; NOT left
	ANI 001H
	MOV E,A  ; result to E
	RET  ; proc return
__L00254:     ; 0ff2
	LXI D,_SETFILESTATUS_FSTAT  ; load ref left
	MVI C,004H  ; load const right
	CALL MATCH  ; proc call
	LXI H,_GETFILE_SCASE   ; assign
	MOV M,E    ; from E
	MVI A,000H  ; OPT MVICA
	CMP E ; =
	JNZ __L00256 ; !=
	MVI E,001H  ; rel true left
	JMP __L00257
__L00256:     ; 1009
	MVI E,000H  ; rel false left
__L00257:     ; 100b
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00258  ; skip if
	LXI D,__L00255  ; load ref left
	CALL PRINT  ; proc call
__L00258:     ; 1016
	MVI E,001H  ; load const left
	RET  ; proc return
PRINTFN:     ; 1019
	MVI E,001H  ; load const left
	MOV A,E
	JMP __L00261  ; DO first iter
__L00259:     ; 101f
	MVI E,00BH  ; load const left
	LDA _PRINTFN_K  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00261   ; = 
	JNC __L00260  ; > DO complete
__L00261:     ; 102c
	STA _PRINTFN_K  ; DO assign
	LXI H,_PRINTFN_K  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,07FH  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	LXI H,_PRINTFN_LB   ; assign
	MOV M,E    ; from E
	MVI A,020H  ; OPT MVICA
	CMP E ; <>
	JZ __L00262 ; =
	MVI E,001H  ; rel true left
	JMP __L00263
__L00262:     ; 104d
	MVI E,000H  ; rel false left
__L00263:     ; 104f
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00264  ; skip if
	LXI H,_PRINTFN_K  ; load var left
	MOV E,M   ; to E
	MVI A,009H  ; OPT MVICA
	CMP E ; =
	JNZ __L00265 ; !=
	MVI E,001H  ; rel true left
	JMP __L00266
__L00265:     ; 1063
	MVI E,000H  ; rel false left
__L00266:     ; 1065
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00267  ; skip if
	MVI E,02EH  ; load const left
	CALL PRINTCHAR  ; proc call
__L00267:     ; 106f
	LXI H,_PRINTFN_LB  ; load var left
	MOV E,M   ; to E
	CALL PRINTCHAR  ; proc call
__L00264:     ; 1076
	JMP __L00259  ; END
__L00260:     ; 1079
	RET  ; proc return
GETFILE:     ; 107a
	CALL SETBPB  ; proc call
	CALL SETDISK  ; proc call
	MVI E,000H  ; load const left
	LXI H,SIZESET   ; assign
	MOV M,E    ; from E
	MVI E,0FFH  ; load const left
	LXI H,_GETFILE_SCASE   ; assign
	MOV M,E    ; from E
	CALL SETFILESTATUS  ; proc call
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00268  ; skip if
	LXI H,_GETFILE_SCASE  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; =
	JNZ __L00269 ; !=
	MVI E,001H  ; rel true left
	JMP __L00270
__L00269:     ; 10a7
	MVI E,000H  ; rel false left
__L00270:     ; 10a9
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00271  ; skip if
	RET  ; proc return
__L00271:     ; 10af
	LXI H,_GETFILE_SCASE  ; load var left
	MOV E,M   ; to E
	MVI C,001H  ; load const right
	MOV A,E
	SUB C    ; - left
	MOV E,A  ; result to E
	LXI H,_GETFILE_SCASE   ; assign
	MOV M,E    ; from E
	JMP __L00275  ; skip else
__L00268:     ; 10bf
	LXI D,00001H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00272 ; !=
	MVI E,001H  ; rel true left
	JMP __L00273
__L00272:     ; 10d2
	MVI E,000H  ; rel false left
__L00273:     ; 10d4
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00274  ; skip if
	CALL PRALLOC  ; proc call
	RET  ; proc return
__L00275:     ; 10dd
__L00274:     ; 10dd
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_FCBN ; assign
	XCHG    ; restore D,E
	PUSH D  ; save left array
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	MVI E,03FH  ; load const left
	PUSH D  ; save left array
	LXI D,0000CH  ; OPT MVIED
	LXI H,0005CH  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	PUSH D  ; save left array
	LXI D,0000EH  ; OPT MVIED
	LXI H,0005CH  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	LXI D,0005CH  ; OPT MVIED
	CALL SEARCH  ; proc call
COLLECT:     ; 110b
__L00276:     ; 110b
	LXI H,_STATUS_DCNT  ; load var left
	MOV E,M   ; to E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; <>
	JZ __L00278 ; =
	MVI E,001H  ; rel true left
	JMP __L00279
__L00278:     ; 111a
	MVI E,000H  ; rel false left
__L00279:     ; 111c
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00277  ; skip while
	LXI H,_STATUS_DCNT  ; load var left
	MOV E,M   ; to E
	MVI A,003H  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	MVI C,005H  ; load const right
__L00280:     ; 112b
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00280  ; more SHL
	MVI A,080H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	MVI D,000H  ; zero pad MSB
	XCHG    ; from D,E
	SHLD _GETFILE_BFCBA ; assign
	MVI E,000H  ; load const left
	LXI H,_GETFILE_MATCHED   ; assign
	MOV M,E    ; from E
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
__L00281:     ; 114b
	LXI H,_GETFILE_MATCHED  ; load var left
	MOV E,M   ; to E
	MOV A,E
	CMA      ; NOT left
	ANI 001H
	MOV E,A  ; result to E
	PUSH D ; save left binary
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LHLD _GETFILE_FCBN ; load var right
	MOV C,L
	MOV B,H ; to B,C
	MOV A,D
	CMP B  ; <
	JZ __L00285   ; =
	JNC __L00283  ; >
	JMP __L00286  ; <
__L00285:     ; 1169
	MOV A,E
	CMP C  ; <
	JNC __L00283 ; >=
__L00286:     ; 116e
	MVI C,001H  ; rel true right
	JMP __L00284
__L00283:     ; 1173
	MVI C,000H  ; rel false right
__L00284:     ; 1175
	POP D  ; restore left binary
	MOV A,C
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00282  ; skip while
	CALL MULTI16  ; proc call
	MVI E,001H  ; load const left
	MOV A,E
	JMP __L00289  ; DO first iter
__L00287:     ; 1187
	MVI E,00BH  ; load const left
	LDA _GETFILE_KB  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00289   ; = 
	JNC __L00288  ; > DO complete
__L00289:     ; 1194
	STA _GETFILE_KB  ; DO assign
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_BFCBA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	PUSH D  ; save left array
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_FCBSA  ; load arr based right
	DAD D    ; arr offset
	MOV C,M  ; arr element to (B),C
	POP D  ; restore left array
	MOV A,C
	CMP E ; <>
	JZ __L00290 ; =
	MVI E,001H  ; rel true left
	JMP __L00291
__L00290:     ; 11b9
	MVI E,000H  ; rel false left
__L00291:     ; 11bb
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00292  ; skip if
	MVI E,00BH  ; load const left
	LXI H,_GETFILE_KB   ; assign
	MOV M,E    ; from E
	JMP __L00295  ; skip else
__L00292:     ; 11c9
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI A,00BH  ; OPT MVICA
	CMP E ; =
	JNZ __L00293 ; !=
	MVI E,001H  ; rel true left
	JMP __L00294
__L00293:     ; 11d8
	MVI E,000H  ; rel false left
__L00294:     ; 11da
	LXI H,_GETFILE_MATCHED   ; assign
	MOV M,E    ; from E
__L00295:     ; 11de
	JMP __L00287  ; END
__L00288:     ; 11e1
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_I ; assign
	JMP __L00281  ; END
__L00282:     ; 11f0
CHECKMATCHED:     ; 11f0
	LXI H,_GETFILE_MATCHED  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00296  ; skip if
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	MOV A,E
	SUB C    ; - left
	MOV E,A
	MOV A,D
	SBB B
	MOV D,A  ; result to D,E
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
	JMP __L00297  ; skip else
__L00296:     ; 1211
	LHLD _GETFILE_FCBN ; load var left
	SHLD _GETFILE_I ; assign
	XCHG    ; restore D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_FCBN ; assign
	CALL MULTI16  ; proc call
	LHLD _GETFILE_FCBN ; load var left
	XCHG    ; to D,E
	LXI B,00200H  ; load const right
	MOV A,D
	CMP B   ; >
	JC __L00298   ; <
	JZ __L00300   ; =
	JMP __L00301  ; >
__L00300:     ; 1235
	MOV A,E
	CMP C  ; >
	JC __L00298  ; <
	JZ __L00298  ; =
__L00301:     ; 123d
	MVI E,001H  ; rel true left
	JMP __L00299
__L00298:     ; 1242
	MVI E,000H  ; rel false left
__L00299:     ; 1244
	PUSH D ; save left binary
	LHLD _GETFILE_FCBSA ; load var left
	XCHG    ; to D,E
	LXI B,00010H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LHLD 00006H ; load var right
	MOV C,L
	MOV B,H ; to B,C
	MOV A,D
	CMP B  ; >=
	JZ __L00304  ; =
	JC __L00302  ; <
	JMP __L00305 ; >
__L00304:     ; 125f
	MOV A,E
	CMP C  ; >=
	JC __L00302  ; <
__L00305:     ; 1264
	MVI C,001H  ; rel true right
	JMP __L00303
__L00302:     ; 1269
	MVI C,000H  ; rel false right
__L00303:     ; 126b
	POP D  ; restore left binary
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00306  ; skip if
	LXI D,__L00307  ; load ref left
	CALL PRINT  ; proc call
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
	LXI D,00001H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_FCBN ; assign
	CALL MULTI16  ; proc call
__L00306:     ; 128b
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FINX  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	MVI E,000H  ; load const left
	MOV A,E
	JMP __L00310  ; DO first iter
__L00308:     ; 12a4
	MVI E,00BH  ; load const left
	LDA _GETFILE_KB  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00310   ; = 
	JNC __L00309  ; > DO complete
__L00310:     ; 12b1
	STA _GETFILE_KB  ; DO assign
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_BFCBA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	PUSH D  ; save left array
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_FCBSA  ; store arr based
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00308  ; END
__L00309:     ; 12cf
	LXI D,00000H  ; OPT MVIED
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBE  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBB  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBK  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBR  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
__L00297:     ; 130e
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBE  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBE  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBR  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	PUSH D  ; save left array
	LXI D,0000FH  ; OPT MVIED
	LHLD _GETFILE_BFCBA  ; load arr based right
	DAD D    ; arr offset
	MOV C,M  ; arr element to (B),C
	POP D  ; restore left array
	MVI B,000H  ; zero pad MSB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	PUSH D ; save left binary
	LXI D,0000CH  ; OPT MVIED
	LHLD _GETFILE_BFCBA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LHLD DPBA  ; load struct based right
	LXI B,00004H
	DAD B     ; struct offset
	MOV A,M  ; OPT MOVMCA
	ANA E    ; & left
	MOV E,A  ; result to E
	MVI C,080H  ; load const right
	MVI D,000H  ; zero pad MSB
	MVI B,008H  ; * count
	LXI H,00000H  ; * init
__L00311:     ; 1368
	MOV A,C
	RAR
	MOV C,A
	JNC __L00312  ; * check bits of right arg
	DAD D
__L00312:     ; 136f
	XCHG
	DAD H
	XCHG
	DCR B  ; check count
	JNZ __L00311 ;  * more bits
	MOV C,L  ; * result to B,C
	MOV B,H
	POP D  ; restore left binary
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	PUSH D  ; save left array
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBR  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
COUNTBYTES:     ; 138b
	MVI E,001H  ; load const left
	LXI H,_GETFILE_LB   ; assign
	MOV M,E    ; from E
	LHLD DPBA  ; load struct based left
	LXI D,00005H
	DAD D     ; struct offset
	MOV E,M   ; to (D),E
	INX H
	MOV D,M
	LXI B,000FFH  ; OPT MVICB
	MOV A,D
	CMP B   ; >
	JC __L00313   ; <
	JZ __L00315   ; =
	JMP __L00316  ; >
__L00315:     ; 13a9
	MOV A,E
	CMP C  ; >
	JC __L00313  ; <
	JZ __L00313  ; =
__L00316:     ; 13b1
	MVI E,001H  ; rel true left
	JMP __L00314
__L00313:     ; 13b6
	MVI E,000H  ; rel false left
__L00314:     ; 13b8
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00317  ; skip if
	MVI E,002H  ; load const left
	LXI H,_GETFILE_LB   ; assign
	MOV M,E    ; from E
__L00317:     ; 13c3
	MVI E,010H  ; load const left
	MOV A,E
	JMP __L00320  ; DO first iter
__L00318:     ; 13c9
	MVI E,01FH  ; load const left
	LXI H,_GETFILE_LB  ; load var right
	MOV C,M   ; to C
	LDA _GETFILE_KB  ; DO load
	ADD C  ; DO update
	CMP E   ; DO <=
	JZ __L00320   ; = 
	JNC __L00319  ; > DO complete
__L00320:     ; 13da
	STA _GETFILE_KB  ; DO assign
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_BFCBA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LXI H,_GETFILE_MB   ; assign
	MOV M,E    ; from E
	LXI H,_GETFILE_LB  ; load var left
	MOV E,M   ; to E
	MVI A,002H  ; OPT MVICA
	CMP E ; =
	JNZ __L00321 ; !=
	MVI E,001H  ; rel true left
	JMP __L00322
__L00321:     ; 13fb
	MVI E,000H  ; rel false left
__L00322:     ; 13fd
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00323  ; skip if
	LXI H,_GETFILE_MB  ; load var left
	MOV E,M   ; to E
	PUSH D  ; save left array
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI A,001H  ; OPT MVICA
	ADD E    ; + left
	MOV E,A  ; result to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_BFCBA  ; load arr based right
	DAD D    ; arr offset
	MOV C,M  ; arr element to (B),C
	POP D  ; restore left array
	MOV A,C
	ORA E    ; | left
	MOV E,A  ; result to E
	LXI H,_GETFILE_MB   ; assign
	MOV M,E    ; from E
__L00323:     ; 141e
	LXI H,_GETFILE_MB  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00324 ; =
	MVI E,001H  ; rel true left
	JMP __L00325
__L00324:     ; 142d
	MVI E,000H  ; rel false left
__L00325:     ; 142f
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00326  ; skip if
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBK  ; load ref left
	XCHG
	DAD H  ; index << 1
	DAD D    ; ref offset
	XCHG     ; to D,E
	PUSH D  ; save left ref
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBB  ; load ref right
	XCHG
	DAD H  ; index << 1
	DAD D    ; ref offset
	MOV C,L  ; to B,C
	MOV B,H
	POP D  ; restore left ref
	CALL ADDBLOCK  ; proc call
__L00326:     ; 1450
	JMP __L00318  ; END
__L00319:     ; 1453
	CALL SEARCHN  ; proc call
	JMP __L00276  ; END
__L00277:     ; 1459
DISPLAY:     ; 1459
	LHLD _GETFILE_FCBN ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,C
	CMP E  ; =
	JNZ __L00327 ; !=
	MOV A,B
	CMP D  ; =
	JNZ __L00327 ; !=
	MVI E,001H  ; rel true left
	JMP __L00328
__L00327:     ; 146f
	MVI E,000H  ; rel false left
__L00328:     ; 1471
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00329  ; skip if
	LXI D,__L00330  ; load ref left
	CALL PRINT  ; proc call
	JMP __L00334  ; skip else
__L00329:     ; 147f
	LXI H,_GETFILE_SCASE  ; load var left
	MOV E,M   ; to E
	MVI A,0FFH  ; OPT MVICA
	CMP E ; =
	JNZ __L00331 ; !=
	MVI E,001H  ; rel true left
	JMP __L00332
__L00331:     ; 148e
	MVI E,000H  ; rel false left
__L00332:     ; 1490
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00333  ; skip if
	LHLD _GETFILE_FCBN ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	MOV A,D
	CMP B   ; >
	JC __L00335   ; <
	JZ __L00337   ; =
	JMP __L00338  ; >
__L00337:     ; 14a7
	MOV A,E
	CMP C  ; >
	JC __L00335  ; <
	JZ __L00335  ; =
__L00338:     ; 14af
	MVI E,001H  ; rel true left
	JMP __L00336
__L00335:     ; 14b4
	MVI E,000H  ; rel false left
__L00336:     ; 14b6
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00339  ; skip if
	LXI D,00001H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_L ; assign
__L00340:     ; 14c2
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LXI B,00000H  ; OPT MVICB
	MOV A,D
	CMP B   ; >
	JC __L00342   ; <
	JZ __L00344   ; =
	JMP __L00345  ; >
__L00344:     ; 14d4
	MOV A,E
	CMP C  ; >
	JC __L00342  ; <
	JZ __L00342  ; =
__L00345:     ; 14dc
	MVI E,001H  ; rel true left
	JMP __L00343
__L00342:     ; 14e1
	MVI E,000H  ; rel false left
__L00343:     ; 14e3
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00341  ; skip while
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_L ; assign
	LXI D,00000H  ; OPT MVIED
	XCHG     ; from D,E
	JMP __L00348  ; DO first iter
__L00346:     ; 14f6
	LHLD _GETFILE_FCBN ; load var left
	XCHG    ; to D,E
	LXI B,00002H  ; OPT MVICB
	MOV A,E
	SUB C    ; - left
	MOV E,A
	MOV A,D
	SBB B
	MOV D,A  ; result to D,E
	LHLD _GETFILE_M  ; DO load
	INX H    ; DO update
	MOV A,H
	CMP D   ; DO <=
	JZ __L00349   ; =
	JNC __L00347  ; > DO complete
	JMP __L00348  ; <
__L00349:     ; 1512
	MOV A,L
	CMP E   ; DO <=
	JZ __L00348   ; =
	JNC __L00347  ; > DO complete
__L00348:     ; 151a
	SHLD _GETFILE_M  ; DO assign
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LXI H,_GETFILE_FINX  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
	CALL MULTI16  ; proc call
	LHLD _GETFILE_FCBSA ; load var left
	SHLD _GETFILE_BFCBA ; assign
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FINX  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
	CALL MULTI16  ; proc call
	MVI E,001H  ; load const left
	MOV A,E
	JMP __L00352  ; DO first iter
__L00350:     ; 1557
	MVI E,00BH  ; load const left
	LDA _GETFILE_KB  ; DO load
	INR A   ; DO update
	CMP E   ; DO <=
	JZ __L00352   ; = 
	JNC __L00351  ; > DO complete
__L00352:     ; 1564
	STA _GETFILE_KB  ; DO assign
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_BFCBA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LXI H,_GETFILE_B   ; assign
	MOV M,E    ; from E
	PUSH D ; save left binary
	LXI H,_GETFILE_KB  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad index MSB
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	LXI H,_GETFILE_F   ; assign
	MOV M,E    ; from E
	MOV C,E  ; inp assign right
	POP D  ; restore left binary
	MOV A,C
	CMP E  ; < 
	JC __L00353
	JZ __L00353
	MVI E,001H  ; rel true left
	JMP __L00354
__L00353:     ; 1595
	MVI E,000H  ; rel false left
__L00354:     ; 1597
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00355  ; skip if
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FINX  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	XCHG    ; from D,E
	SHLD _GETFILE_K ; assign
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LXI H,_GETFILE_FINX  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	PUSH D  ; save left array
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FINX  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	LHLD _GETFILE_K ; load var left
	XCHG    ; to D,E
	PUSH D  ; save left array
	LHLD _GETFILE_M ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	XCHG   ; result to D,E
	LXI H,_GETFILE_FINX  ; store arr
	XCHG
	DAD H  ; index << 1
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	INX H
	MOV M,D
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_L ; assign
	MVI E,00BH  ; load const left
	LXI H,_GETFILE_KB   ; assign
	MOV M,E    ; from E
	JMP __L00359  ; skip else
__L00355:     ; 15fd
	LXI H,_GETFILE_B  ; load var left
	MOV E,M   ; to E
	LXI H,_GETFILE_F  ; load var right
	MOV A,M  ; OPT MOVMCA
	CMP E  ; > 
	JNC __L00356
	MVI E,001H  ; rel true left
	JMP __L00357
__L00356:     ; 160e
	MVI E,000H  ; rel false left
__L00357:     ; 1610
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00358  ; skip if
	MVI E,00BH  ; load const left
	LXI H,_GETFILE_KB   ; assign
	MOV M,E    ; from E
__L00358:     ; 161b
__L00359:     ; 161b
	JMP __L00350  ; END
__L00351:     ; 161e
	JMP __L00346  ; END
__L00347:     ; 1621
	JMP __L00340  ; END
__L00341:     ; 1624
__L00339:     ; 1624
	LXI H,SIZESET  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00361  ; skip if
	LXI D,__L00360  ; load ref left
	CALL PRINT  ; proc call
	JMP __L00362  ; skip else
__L00361:     ; 163a
	CALL CRLF  ; proc call
__L00362:     ; 163d
	LXI D,__L00363  ; load ref left
	CALL PRINTX  ; proc call
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_L ; assign
__L00364:     ; 164a
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LHLD _GETFILE_FCBN ; load var right
	MOV C,L
	MOV B,H ; to B,C
	MOV A,D
	CMP B  ; <
	JZ __L00368   ; =
	JNC __L00366  ; >
	JMP __L00369  ; <
__L00368:     ; 165e
	MOV A,E
	CMP C  ; <
	JNC __L00366 ; >=
__L00369:     ; 1663
	MVI E,001H  ; rel true left
	JMP __L00367
__L00366:     ; 1668
	MVI E,000H  ; rel false left
__L00367:     ; 166a
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00365  ; skip while
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FINX  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	XCHG    ; from D,E
	SHLD _GETFILE_I ; assign
	CALL MULTI16  ; proc call
	CALL CRLF  ; proc call
	LXI D,0005CH  ; OPT MVIED
	PUSH D  ; proc ext arg
	MVI E,010H  ; load const left
	PUSH D  ; save left ref
	LXI D,00000H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load ref right
	DAD D    ; ref offset
	MOV C,L  ; to B,C
	MOV B,H
	POP D  ; restore left ref
	CALL MOVE  ; proc call
	POP H  ; proc ext arg discard
	MVI E,000H  ; load const left
	PUSH D  ; save left array
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	LXI H,SIZESET  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00370  ; skip if
	LXI D,0005CH  ; OPT MVIED
	CALL GETFILESIZE  ; proc call
	LXI H,0007FH  ; load var left
	MOV E,M   ; to E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00372 ; =
	MVI E,001H  ; rel true left
	JMP __L00373
__L00372:     ; 16c9
	MVI E,000H  ; rel false left
__L00373:     ; 16cb
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00374  ; skip if
	LXI D,__L00371  ; load ref left
	CALL PRINTX  ; proc call
	JMP __L00375  ; skip else
__L00374:     ; 16d9
	LHLD 0007DH ; load var left
	XCHG    ; to D,E
	LXI B,02710H  ; load const right
	CALL PDECIMAL  ; proc call
__L00375:     ; 16e3
	CALL PRINTB  ; proc call
__L00370:     ; 16e6
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBR  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	LXI B,02710H  ; load const right
	CALL PDECIMAL  ; proc call
	CALL PRINTB  ; proc call
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBK  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	LXI B,02710H  ; load const right
	CALL PDECIMAL  ; proc call
	MVI E,06BH  ; load const left
	CALL PRINTCHAR  ; proc call
	CALL PRINTB  ; proc call
	LHLD _GETFILE_I ; load var left
	XCHG    ; to D,E
	LXI H,_GETFILE_FCBE  ; load arr left
	XCHG
	DAD H  ; index << 1
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	INX H
	MOV D,M
	LXI B,003E8H  ; load const right
	CALL PDECIMAL  ; proc call
	CALL PRINTB  ; proc call
	MVI E,052H  ; load const left
	CALL PRINTCHAR  ; proc call
	MVI E,02FH  ; load const left
	CALL PRINTCHAR  ; proc call
	LXI D,00009H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI C,001H  ; load const right
__L00376:     ; 1741
	MOV A,E
	RLC  ; ROL
	MOV E,A
	DCR C
	JNZ __L00376  ; more ROL
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00377  ; skip if
	MVI E,04FH  ; load const left
	CALL PRINTCHAR  ; proc call
	JMP __L00378  ; skip else
__L00377:     ; 1759
	MVI E,057H  ; load const left
	CALL PRINTCHAR  ; proc call
__L00378:     ; 175e
	CALL PRINTB  ; proc call
	MVI E,041H  ; load const left
	PUSH D ; save left binary
	CALL CSELECT  ; proc call
	MOV C,E  ; proc ret right to (B),C
	POP D  ; restore left binary
	MOV A,C
	ADD E    ; + left
	MOV E,A  ; result to E
	CALL PRINTCHAR  ; proc call
	MVI E,03AH  ; load const left
	CALL PRINTCHAR  ; proc call
	LXI D,0000AH  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI C,001H  ; load const right
__L00379:     ; 177e
	MOV A,E
	RLC  ; ROL
	MOV E,A
	DCR C
	JNZ __L00379  ; more ROL
	LXI H,_GETFILE_MB   ; assign
	MOV M,E    ; from E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00380  ; skip if
	MVI E,028H  ; load const left
	CALL PRINTCHAR  ; proc call
__L00380:     ; 1797
	CALL PRINTFN  ; proc call
	LXI H,_GETFILE_MB  ; load var left
	MOV E,M   ; to E
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00381  ; skip if
	MVI E,029H  ; load const left
	CALL PRINTCHAR  ; proc call
__L00381:     ; 17ac
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_L ; assign
	JMP __L00364  ; END
__L00365:     ; 17bb
	CALL PRALLOC  ; proc call
__L00334:     ; 17be
	JMP __L00382  ; skip else
__L00333:     ; 17c1
SETFILEATT:     ; 17c1
	LXI D,00000H  ; OPT MVIED
	XCHG    ; from D,E
	SHLD _GETFILE_L ; assign
__L00383:     ; 17c8
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LHLD _GETFILE_FCBN ; load var right
	MOV C,L
	MOV B,H ; to B,C
	MOV A,D
	CMP B  ; <
	JZ __L00387   ; =
	JNC __L00385  ; >
	JMP __L00388  ; <
__L00387:     ; 17dc
	MOV A,E
	CMP C  ; <
	JNC __L00385 ; >=
__L00388:     ; 17e1
	MVI E,001H  ; rel true left
	JMP __L00386
__L00385:     ; 17e6
	MVI E,000H  ; rel false left
__L00386:     ; 17e8
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00384  ; skip while
	CALL BREAK  ; proc call
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00389  ; skip if
	CALL ABORTMSG  ; proc call
	RET  ; proc return
__L00389:     ; 17fd
	LHLD _GETFILE_L ; load var left
	SHLD _GETFILE_I ; assign
	CALL MULTI16  ; proc call
	CALL CRLF  ; proc call
	CALL PRINTFN  ; proc call
	LXI H,_GETFILE_SCASE  ; load var left
	MOV E,M   ; to E
	MVI D,000H  ; zero pad CASE MSB
	LXI H,__L00390  ; CASE table
	XCHG
	DAD H  ; index << 1
	DAD D  ; CASE table offset
	MOV E,M
	INX H
	MOV D,M
	XCHG
	PCHL  ; go to CASE
__L00392:     ; 181e
	LXI D,00009H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,080H  ; OPT MVICA
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D  ; save left array
	LXI D,00009H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; store arr based
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00391  ; end CASE
__L00393:     ; 1837
	LXI D,00009H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,07FH  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	PUSH D  ; save left array
	LXI D,00009H  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; store arr based
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00391  ; end CASE
__L00394:     ; 1850
	LXI D,0000AH  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,080H  ; OPT MVICA
	ORA E    ; | left
	MOV E,A  ; result to E
	PUSH D  ; save left array
	LXI D,0000AH  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; store arr based
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00391  ; end CASE
__L00395:     ; 1869
	LXI D,0000AH  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; load arr based left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,07FH  ; OPT MVICA
	ANA E    ; & left
	MOV E,A  ; result to E
	PUSH D  ; save left array
	LXI D,0000AH  ; OPT MVIED
	LHLD _GETFILE_FCBSA  ; store arr based
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	JMP __L00391  ; end CASE
__L00391:     ; 1882
	LXI D,0005CH  ; OPT MVIED
	PUSH D  ; proc ext arg
	MVI E,010H  ; load const left
	LHLD _GETFILE_FCBSA ; load var right
	MOV C,L
	MOV B,H ; to B,C
	CALL MOVE  ; proc call
	POP H  ; proc ext arg discard
	MVI E,000H  ; load const left
	PUSH D  ; save left array
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; store arr
	DAD D  ; arr offset
	POP D  ; arr restore left
	MOV M,E  ; arr assign from (D),C
	CALL SETIND  ; proc call
	LXI D,__L00396  ; load ref left
	CALL PRINTX  ; proc call
	LXI H,_GETFILE_SCASE  ; load var left
	MOV E,M   ; to E
	MVI C,002H  ; load const right
__L00397:     ; 18ac
	STC
	CMC
	MOV A,E
	RAL  ; SHL
	MOV E,A
	DCR C
	JNZ __L00397  ; more SHL
	MVI D,000H  ; zero pad MSB
	LXI H,_GETFILE_FSTATLIST  ; load ref left
	DAD D    ; ref offset
	XCHG     ; to D,E
	CALL PRINTX  ; proc call
	LHLD _GETFILE_L ; load var left
	XCHG    ; to D,E
	LXI B,00001H  ; OPT MVICB
	XCHG   ; from D,E
	DAD B  ; + left
	SHLD _GETFILE_L ; assign
	JMP __L00383  ; END
__L00384:     ; 18ce
__L00382:     ; 18ce
	RET  ; proc return
SETDRIVESTATUS:     ; 18cf
	CALL SCAN  ; proc call
	CALL SCAN  ; proc call
	LXI D,00000H  ; OPT MVIED
	LXI H,_STATUS_ACCUM  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,03DH  ; OPT MVICA
	CMP E ; =
	JNZ __L00398 ; !=
	MVI E,001H  ; rel true left
	JMP __L00399
__L00398:     ; 18e8
	MVI E,000H  ; rel false left
__L00399:     ; 18ea
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00400  ; skip if
	CALL SCAN  ; proc call
	LXI D,__L00401  ; load ref left
	CALL COMPARE  ; proc call
	MOV A,E
	ANI 001H  ; bool
	MOV E,A   ; left to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00402  ; skip if
	CALL SETDISK  ; proc call
	CALL WRITEPROT  ; proc call
	JMP __L00404  ; skip else
__L00402:     ; 190a
	LXI D,__L00403  ; load ref left
	CALL PRINT  ; proc call
__L00404:     ; 1910
	JMP __L00405  ; skip else
__L00400:     ; 1913
	CALL SETDISK  ; proc call
	LXI D,_STATUS_DEVL  ; load ref left
	MVI C,008H  ; load const right
	CALL MATCH  ; proc call
	MVI A,008H  ; OPT MVICA
	CMP E ; =
	JNZ __L00406 ; !=
	MVI E,001H  ; rel true left
	JMP __L00407
__L00406:     ; 1929
	MVI E,000H  ; rel false left
__L00407:     ; 192b
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00408  ; skip if
	CALL DRIVESTATUS  ; proc call
	JMP __L00409  ; skip else
__L00408:     ; 1936
	CALL GETFILE  ; proc call
__L00409:     ; 1939
__L00405:     ; 1939
	RET  ; proc return
STATUS:     ; 193a
	LXI H,__ENDCOM  ; exit address
	PUSH H
	LXI H,00000H  ; load STACKPTR left
	DAD SP
	SHLD _STATUS_OLDSP ; assign
	LXI D,00010H  ; OPT MVIED
	LXI H,_STATUS_STACK  ; load ref left
	XCHG
	DAD H  ; index << 1
	DAD D    ; ref offset
	SPHL  ; assign STACKPTR
	CALL VERS  ; proc call
	MVI A,020H  ; OPT MVICA
	CMP E  ; < 
	JC __L00411
	JZ __L00411
	MVI E,001H  ; rel true left
	JMP __L00412
__L00411:     ; 1960
	MVI E,000H  ; rel false left
__L00412:     ; 1962
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00413  ; skip if
	LXI D,__L00410  ; load ref left
	CALL PRINT  ; proc call
	JMP __L00414  ; skip else
__L00413:     ; 1970
	MVI E,001H  ; load const left
	LXI H,_STATUS_IBP   ; assign
	MOV M,E    ; from E
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,000H  ; OPT MVICA
	CMP E ; =
	JNZ __L00415 ; !=
	MVI E,001H  ; rel true left
	JMP __L00416
__L00415:     ; 1989
	MVI E,000H  ; rel false left
__L00416:     ; 198b
	PUSH D ; save left binary
	LXI D,00001H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,020H  ; OPT MVICA
	CMP E ; =
	JNZ __L00417 ; !=
	MVI C,001H  ; rel true right
	JMP __L00418
__L00417:     ; 199f
	MVI C,000H  ; rel false right
__L00418:     ; 19a1
	POP D  ; restore left binary
	MOV A,C
	ANA E    ; & left
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00419  ; skip if
	CALL PRSTATUS  ; proc call
	JMP __L00420  ; skip else
__L00419:     ; 19b0
	LXI D,00000H  ; OPT MVIED
	LXI H,0005CH  ; load arr left
	DAD D    ; arr offset
	MOV E,M  ; arr element to (D),E
	MVI A,000H  ; OPT MVICA
	CMP E ; <>
	JZ __L00421 ; =
	MVI E,001H  ; rel true left
	JMP __L00422
__L00421:     ; 19c3
	MVI E,000H  ; rel false left
__L00422:     ; 19c5
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00423  ; skip if
	CALL SETDRIVESTATUS  ; proc call
	JMP __L00424  ; skip else
__L00423:     ; 19d0
	CALL DEVREQ  ; proc call
	MOV A,E
	CMA      ; NOT left
	ANI 001H
	MOV E,A  ; result to E
	XRA A  ; A = 0
	CMP E  ; rel result
	JZ __L00425  ; skip if
	CALL GETFILE  ; proc call
__L00425:     ; 19e0
__L00424:     ; 19e0
__L00420:     ; 19e0
__L00414:     ; 19e0
	LHLD _STATUS_OLDSP ; load var left
	SPHL  ; assign STACKPTR
	RET  ; proc return
	RET  ; program end
__L00390:	DW  __L00392, __L00393, __L00394, __L00395
__L00081	DB  02AH,02AH,020H,041H,062H,06FH,072H,074H,065H,064H,020H,02AH,02AH,000H    ; 19e6
__L00082	DB  041H,063H,074H,069H,076H,065H,020H,055H,073H,065H,072H,020H,03AH,000H    ; 19f4
__L00083	DB  041H,063H,074H,069H,076H,065H,020H,046H,069H,06CH,065H,073H,03AH,000H    ; 1a02
__L00099	DB  020H,020H,020H,020H,000H    ; 1a10
__L00100	DB  020H,044H,072H,069H,076H,065H,020H,043H,068H,061H,072H,061H,063H,074H,065H,072H,069H,073H,074H,069H,063H,073H,000H    ; 1a15
__L00102	DB  036H,035H,035H,033H,036H,03AH,020H,000H    ; 1a2c
__L00113	DB  031H,032H,038H,020H,042H,079H,074H,065H,020H,052H,065H,063H,06FH,072H,064H,020H,043H,061H,070H,061H,063H,069H,074H,079H,000H    ; 1a34
__L00114	DB  04BH,069H,06CH,06FH,062H,079H,074H,065H,020H,044H,072H,069H,076H,065H,020H,020H,043H,061H,070H,061H,063H,069H,074H,079H,000H    ; 1a4d
__L00115	DB  033H,032H,020H,020H,042H,079H,074H,065H,020H,044H,069H,072H,065H,063H,074H,06FH,072H,079H,020H,045H,06EH,074H,072H,069H,065H,073H,000H    ; 1a66
__L00117	DB  043H,068H,065H,063H,06BH,065H,064H,020H,020H,044H,069H,072H,065H,063H,074H,06FH,072H,079H,020H,045H,06EH,074H,072H,069H,065H,073H,000H    ; 1a81
__L00120	DB  052H,065H,063H,06FH,072H,064H,073H,02FH,020H,045H,078H,074H,065H,06EH,074H,000H    ; 1a9c
__L00121	DB  052H,065H,063H,06FH,072H,064H,073H,02FH,020H,042H,06CH,06FH,063H,06BH,000H    ; 1aac
__L00122	DB  053H,065H,063H,074H,06FH,072H,073H,02FH,020H,054H,072H,061H,063H,06BH,000H    ; 1abb
__L00123	DB  052H,065H,073H,065H,072H,076H,065H,064H,020H,054H,072H,061H,063H,06BH,073H,000H    ; 1aca
__L00160	DB  020H,069H,073H,020H,000H    ; 1ada
__L00167	DB  054H,065H,06DH,070H,020H,052H,02FH,04FH,020H,044H,069H,073H,06BH,03AH,020H,064H,03AH,03DH,052H,02FH,04FH,000H    ; 1adf
__L00168	DB  053H,065H,074H,020H,049H,06EH,064H,069H,063H,061H,074H,06FH,072H,03AH,020H,064H,03AH,066H,069H,06CH,065H,06EH,061H,06DH,065H,02EH,074H,079H,070H,020H,024H,052H,02FH,04FH,020H,024H,052H,02FH,057H,020H,024H,053H,059H,053H,020H,024H,044H,049H,052H,000H    ; 1af5
__L00169	DB  044H,069H,073H,06BH,020H,053H,074H,061H,074H,075H,073H,020H,020H,03AH,020H,044H,053H,04BH,03AH,020H,064H,03AH,044H,053H,04BH,03AH,000H    ; 1b27
__L00170	DB  055H,073H,065H,072H,020H,053H,074H,061H,074H,075H,073H,020H,020H,03AH,020H,055H,053H,052H,03AH,000H    ; 1b42
__L00171	DB  049H,06FH,062H,079H,074H,065H,020H,041H,073H,073H,069H,067H,06EH,03AH,000H    ; 1b56
__L00176	DB  020H,03DH,000H    ; 1b65
__L00194	DB  042H,061H,064H,020H,044H,065H,06CH,069H,06DH,069H,074H,065H,072H,000H    ; 1b68
__L00198	DB  049H,06EH,076H,061H,06CH,069H,064H,020H,041H,073H,073H,069H,067H,06EH,06DH,065H,06EH,074H,000H    ; 1b76
__L00211	DB  042H,061H,064H,020H,044H,065H,06CH,069H,06DH,069H,074H,065H,072H,000H    ; 1b89
__L00228	DB  03AH,020H,000H    ; 1b97
__L00229	DB  042H,079H,074H,065H,073H,020H,052H,065H,06DH,061H,069H,06EH,069H,06EH,067H,020H,04FH,06EH,020H,000H    ; 1b9a
__L00237	DB  052H,02FH,000H    ; 1bae
__L00240	DB  02CH,020H,053H,070H,061H,063H,065H,03AH,020H,000H    ; 1bb1
__L00255	DB  049H,06EH,076H,061H,06CH,069H,064H,020H,046H,069H,06CH,065H,020H,049H,06EH,064H,069H,063H,061H,074H,06FH,072H,000H    ; 1bbb
__L00307	DB  02AH,02AH,020H,054H,06FH,06FH,020H,04DH,061H,06EH,079H,020H,046H,069H,06CH,065H,073H,020H,02AH,02AH,000H    ; 1bd2
__L00330	DB  046H,069H,06CH,065H,020H,04EH,06FH,074H,020H,046H,06FH,075H,06EH,064H,000H    ; 1be7
__L00360	DB  020H,053H,069H,07AH,065H,020H,000H    ; 1bf6
__L00363	DB  020H,052H,065H,063H,073H,020H,020H,042H,079H,074H,065H,073H,020H,020H,045H,078H,074H,020H,041H,063H,063H,000H    ; 1bfd
__L00371	DB  036H,035H,035H,033H,036H,000H    ; 1c13
__L00396	DB  020H,073H,065H,074H,020H,074H,06FH,020H,000H    ; 1c19
__L00401	DB  052H,02FH,04FH,020H    ; 1c22
__L00403	DB  049H,06EH,076H,061H,06CH,069H,064H,020H,044H,069H,073H,06BH,020H,041H,073H,073H,069H,067H,06EH,06DH,065H,06EH,074H,000H    ; 1c26
__L00410	DB  057H,072H,06FH,06EH,067H,020H,043H,050H,02FH,04DH,020H,056H,065H,072H,073H,069H,06FH,06EH,020H,028H,052H,065H,071H,075H,069H,072H,065H,073H,020H,032H,02EH,030H,029H,000H    ; 1c3e

__CPMENT	EQU 00005H
MON1:
	MOV A,E			; function code in E
	MOV E,C			; address in B,C
	MOV D,B
	MOV C,A
	JMP __CPMENT
MON2:
	MOV A,E			; function code in E
	MOV E,C			; address in B,C
	MOV D,B
	MOV C,A
	CALL __CPMENT
	MOV E,A			; return value in A
	RET
MON3:
	MOV A,E			; function code in E
	MOV E,C			; address in B,C
	MOV D,B
	MOV C,A
	CALL __CPMENT
	MOV E,A			; return value in B,A
	MOV D,B
	RET

__ENDCOM:
	RET  ; return to caller (CP/M ...)
DPBA	DS  2    ; 0000
SIZESET	DS  1    ; 0000
_MOVE_S	DS  2    ; 0000
_MOVE_D	DS  2    ; 0000
_MOVE_N	DS  1    ; 0000
_STATUS_ALLOCA	DS  2    ; 0000
_PRINTCHAR_CHAR	DS  1    ; 0000
_PRINTX_A	DS  2    ; 0000
_PRINT_A	DS  2    ; 0000
_STATUS_DCNT	DS  1    ; 0000
_SELECT_D	DS  1    ; 0000
_SEARCH_FCB	DS  2    ; 0000
_SETDMA_DMA	DS  2    ; 0000
_GETFILESIZE_FCB	DS  2    ; 0000
_STATUS_OLDSP	DS  2    ; 0000
_STATUS_STACK	DW  16  DUP(?)    ; 0000
_STATUS_BPB	DS  2    ; 0000
_SELECTDISK_D	DS  1    ; 0000
_GETALLOC_I	DS  2    ; 0000
_STATUS_ACCUM	DB  4  DUP(?)    ; 0000
_STATUS_IBP	DS  1    ; 0000
_COMPARE_A	DS  2    ; 0000
_COMPARE_I	DS  1    ; 0000
_SCAN_I	DS  1    ; 0000
_SCAN_B	DS  1    ; 0000
_SETACC_B	DS  1    ; 0000
_PDECIMAL_V	DS  2    ; 0000
_PDECIMAL_PREC	DS  2    ; 0000
_PDECIMAL_ZEROSUP	DS  1    ; 0000
_PDECIMAL_D	DS  1    ; 0000
_ADDBLOCK_AK	DS  2    ; 0000
_ADDBLOCK_AB	DS  2    ; 0000
_COUNT_MODE	DS  1    ; 0000
_COUNT_KA	DS  2    ; 0000
_COUNT_BA	DS  2    ; 0000
_COUNT_I	DS  2    ; 0000
_COUNT_BIT	DS  1    ; 0000
_USERSTATUS_I	DS  1    ; 0000
_USERSTATUS_USER	DB  32  DUP(?)    ; 0000
_DRIVESTATUS_RPB	DS  2    ; 0000
_DRIVESTATUS_RPD	DS  2    ; 0000
_PV_V	DS  2    ; 0000
_DISKSTATUS_LOGIN	DS  2    ; 0000
_DISKSTATUS_D	DS  1    ; 0000
_MATCH_VA	DS  2    ; 0000
_MATCH_VL	DS  1    ; 0000
_MATCH_I	DS  1    ; 0000
_MATCH_J	DS  1    ; 0000
_MATCH_MATCH	DS  1    ; 0000
_MATCH_SYNC	DS  1    ; 0000
_DEVREQ_I	DS  1    ; 0000
_DEVREQ_J	DS  1    ; 0000
_DEVREQ_IOBYTE	DS  1    ; 0000
_DEVREQ_ITEMS	DS  1    ; 0000
_PRNAME_A	DS  2    ; 0000
_PVALUE_D	DS  1    ; 0000
_PVALUE_ZERO	DS  1    ; 0000
_PVALUE_K	DS  2    ; 0000
_PVALUE_V	DS  2    ; 0000
_PRSTATUS_LOGIN	DS  2    ; 0000
_PRSTATUS_RODISK	DS  2    ; 0000
_PRSTATUS_D	DS  1    ; 0000
_GETFILE_FCBN	DS  2    ; 0000
_GETFILE_FINX	DW  512  DUP(?)    ; 0000
_GETFILE_FCBE	DW  512  DUP(?)    ; 0000
_GETFILE_FCBB	DW  512  DUP(?)    ; 0000
_GETFILE_FCBK	DW  512  DUP(?)    ; 0000
_GETFILE_FCBR	DW  512  DUP(?)    ; 0000
_GETFILE_BFCBA	DS  2    ; 0000
_GETFILE_FCBSA	DS  2    ; 0000
_GETFILE_I	DS  2    ; 0000
_GETFILE_L	DS  2    ; 0000
_GETFILE_K	DS  2    ; 0000
_GETFILE_M	DS  2    ; 0000
_GETFILE_KB	DS  1    ; 0000
_GETFILE_LB	DS  1    ; 0000
_GETFILE_MB	DS  1    ; 0000
_GETFILE_B	DS  1    ; 0000
_GETFILE_F	DS  1    ; 0000
_GETFILE_MATCHED	DS  1    ; 0000
_GETFILE_SCASE	DS  1    ; 0000
_PRINTFN_K	DS  1    ; 0000
_PRINTFN_LB	DS  1    ; 0000
MEMORY:
