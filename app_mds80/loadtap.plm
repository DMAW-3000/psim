LOAD:
DO;

DECLARE
LOADJMP BYTE DATA(0C3H),
LOADADR ADDRESS DATA(.LOADCOM);

MON1: PROCEDURE(F,A) EXTERNAL;
    DECLARE F BYTE, A ADDRESS;
    END MON1;
	
MON2: PROCEDURE(F,A) BYTE EXTERNAL;
	DECLARE F BYTE, A ADDRESS;
    END MON2;
	
DECLARE SP ADDRESS;

BOOT: PROCEDURE;
    STACKPTR = SP;
    END BOOT;
	
LOADCOM: PROCEDURE;
	DECLARE FCB(33) BYTE AT 005CH;
	DECLARE BUFFER(128) BYTE AT 0080H;
	
PRINTCHAR: PROCEDURE(CHAR);
    DECLARE CHAR BYTE;
    CALL MON1(2,CHAR);
    END PRINTCHAR;

CRLF: PROCEDURE;
    CALL PRINTCHAR(13);
    CALL PRINTCHAR(10);
    END CRLF;

PRINTNIB: PROCEDURE(N);
    DECLARE N BYTE;
        IF N > 9 THEN CALL PRINTCHAR(N+'A'-10); ELSE
        CALL PRINTCHAR(N+'0');
    END PRINTNIB;
	
PRINTHEX: PROCEDURE(B);
    DECLARE B BYTE;
        CALL PRINTNIB(SHR(B,4)); CALL PRINTNIB(B AND 0FH);
    END PRINTHEX;

PRINTADDR: PROCEDURE(A);
    DECLARE A ADDRESS;
    CALL PRINTHEX(HIGH(A)); CALL PRINTHEX(LOW(A));
    END PRINTADDR;

PRINTM: PROCEDURE(A);
    DECLARE A ADDRESS;
    CALL MON1(9,A);
    END PRINTM;

PRINT: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* PRINT THE STRING STARTING AT ADDRESS A UNTIL THE
    NEXT DOLLAR SIGN IS ENCOUNTERED WITH PRECEDING CRLF */
    CALL CRLF;
    CALL PRINTM(A);
    END PRINT;
	
DECLARE LA ADDRESS;

PERROR: PROCEDURE(A);
	DECLARE A ADDRESS;
	/* PRINT ERROR MESSAGE */
	CALL PRINT(.('ERROR: $'));
	CALL PRINTM(A);
	CALL PRINTM(.(', LOAD ADDRESS $'));
	CALL PRINTADDR(LA); CALL CRLF;
	CALL BOOT;
	END PERROR;
	
DECLARE DCNT BYTE;

OPEN: PROCEDURE(FCB);
	DECLARE FCB ADDRESS;
	DCNT = MON2(15,FCB);
	END OPEN;
	
MAKE: PROCEDURE(FCB);
	DECLARE FCB ADDRESS;
	DCNT = MON2(22,FCB);
	END MAKE;
	
CLOSE: PROCEDURE(FCB);
	DECLARE FCB ADDRESS;
	DCNT = MON2(16,FCB);
	END CLOSE;

DELETE: PROCEDURE(FCB);
	DECLARE FCB ADDRESS;
	CALL MON1(19,FCB);
	END DELETE;
	
DISKWRITE: PROCEDURE(FCB) BYTE;
	DECLARE FCB ADDRESS;
	RETURN MON2(21,FCB);
	END DISKWRITE;
	
MOVE: PROCEDURE(S,D,N);
	DECLARE (S,D) ADDRESS, N BYTE;
	DECLARE A BASED S BYTE, B BASED D BYTE;
	DO WHILE (N := N-1) <> 255;
		B = A; S=S+1; D=D+1;
		END;
	END MOVE;
	
GETCHAR: PROCEDURE BYTE;
	/* GET NEXT CHARACTER */
	RETURN MON2(3,0);
	END GETCHAR;
	
RELOC: PROCEDURE;
	DECLARE (RL, CS, RT) BYTE;
	DECLARE (TA, SA, FA, NB) ADDRESS;
	DECLARE MBUFF(256) BYTE,
	P BYTE,
	L ADDRESS;
	
	SETMEM: PROCEDURE(B);
		/* SET MBUFF TO B AT LOCATION LA MOD LENGTH(MBUFF) */
		DECLARE (B,I) BYTE;
		IF LA < L THEN
			CALL PERROR(.('INVERTED LOAD ADDRESS'));
		DO WHILE LA > L + LAST(MBUFF);
			DO I = 0 TO 127;
				BUFFER(I) = MBUFF(LOW(L)); L = L + 1;
				END;
			/* WRITE BUFFER ONTO DISK */
			P = P + 1;
			IF DISKWRITE(.FCB) <> 0 THEN
				DO; CALL PERROR(.('DISK WRITE$'));
				END;
			END;
		MBUFF(LOW(LA)) = B;
		END SETMEM;
		
	DIAGNOSE: PROCEDURE;
	
	DECLARE M BASED TA BYTE;
	
	NEWLINE: PROCEDURE;
		CALL CRLF; CALL PRINTADDR(TA); CALL PRINTCHAR(':');
		CALL PRINTCHAR(' ');
		END NEWLINE;
		
	/* PRINT DIAGNOSTIC INFORMATION AT THE CONSOLE */
		CALL PRINT(.('LOAD ADDRESS  $')); CALL PRINTADDR(TA);
		CALL PRINT(.('ERROR ADDRESS $')); CALL PRINTADDR(LA);
		
		CALL PRINT(.('BYTES READ:$')); CALL NEWLINE;
		DO WHILE TA < LA;
			IF (LOW(TA) AND 0FH) = 0 THEN CALL NEWLINE;
			CALL PRINTHEX(MBUFF(TA-L)); TA=TA+1;
			CALL PRINTCHAR(' ');
			END;
		CALL CRLF;
		CALL BOOT;
		END DIAGNOSE;
	
	READHEX: PROCEDURE BYTE;
		/* READ ONE HEX CHARACTER FROM THE INPUT */
		DECLARE H BYTE;
		IF (H := GETCHAR) - '0' <= 9 THEN RETURN H - '0';
		IF H - 'A' > 5 THEN
			DO; CALL PRINT(.('INVALID HEX DIGIT$'));
			CALL DIAGNOSE;
			END;
		RETURN H - 'A' + 10;
		END READHEX;
	
	READBYTE: PROCEDURE BYTE;
		/* READ TWO HEX DIGITS */
		RETURN SHL(READHEX,4) OR READHEX;
		END READBYTE;
	
	READCS: PROCEDURE BYTE;
		/* READ BYTE WHILE COMPUTING CHECKSUM */
		DECLARE B BYTE;
		CS = CS + (B := READBYTE);
		RETURN B;
		END READCS;

	MAKE$DOUBLE: PROCEDURE(H,L) ADDRESS;
		/* CREATE A DOUBLE BYTE VALUE FROM TWO SINGLE BYTES */
		DECLARE (H,L) BYTE;
		RETURN SHL(DOUBLE(H),8) OR L;
		END MAKE$DOUBLE;
		
	/* INITALIZE */
	SA, FA, NB = 0;
	P = 0;
	TA, L = 0100H;
	
	/* READ RECORDS UNTIL :00XXXX IS ENCOUNTERED */
	
	DO WHILE 1;
		/* SCAN THE : */
		DO WHILE GETCHAR <> ':';
		END;
		
	/* SET THE CHECK SUM TO ZERO, AND SAVE THE RECORD LENGTH */
	CS = 0;
	/* MAY BE THE END OF TAPE */
	IF (RL := READCS) = 0 THEN
		GO TO FIN;
	NB = NB + RL;
	
	TA,LA = MAKE$DOUBLE(READCS,READCS);
	IF SA = 0 THEN SA = LA;
	
	/* READ THE RECORD TYPE (NOT CURRENTLY USED */
	RT = READCS;
	
	/* PROCESS EACH BYTE */
	DO WHILE (RL := RL - 1) <> 255;
		CALL SETMEM(READCS); LA = LA + 1;
		END;
	IF LA > FA THEN FA = LA - 1;
		
	/* NOW DO CHECKSUM AND COMPARE */
	IF CS + READBYTE <> 0 THEN
		DO; CALL PRINT(.('CHECK SUM ERROR$'));
		CALL DIAGNOSE;
		END;
		
	END;
	
FIN:
	/* EMPTY THE BUFFERS */
	TA = LA;
	DO WHILE L < TA;
		CALL SETMEM(0); LA = LA+1;
		END;
	/* PRINT FINAL STATISTICS */
	CALL PRINT(.('FIRST ADDRESS $')); CALL PRINTADDR(SA);
	CALL PRINT(.('LAST  ADDRESS $')); CALL PRINTADDR(FA);
	CALL PRINT(.('BYTES READ    $')); CALL PRINTADDR(NB);
	CALL PRINT(.('RECORDS WRITTEN $')); CALL PRINTHEX(P);
	CALL CRLF;
	
END RELOC;
	
DECLARE STACK(16) ADDRESS;
	
/* LOADCOM ENTRY */
SP = STACKPTR; STACKPTR = .STACK(LENGTH(STACK));
LA = 0100H;

/* SETUP THE FILE */
CALL MOVE(.('COM'), 005CH + 9, 3);
	
/* REMOVE ANY EXISTING FILE BY THIS NAME */
CALL DELETE(.FCB);

/* THEN OPEN A NEW FILE */
CALL MAKE(.FCB); CALL OPEN(.FCB);
IF DCNT = 255 THEN CALL PERROR(.('NO MORE DIRECTORY SPACE$')); ELSE
	DO; CALL RELOC;
	CALL CLOSE(.FCB);
	IF DCNT = 255 THEN CALL PERROR(.('CANNOT CLOSE FILE$'));
	END;
CALL CRLF;

CALL BOOT;
END LOADCOM;

END;

