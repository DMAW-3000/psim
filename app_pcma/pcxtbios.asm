;
; I/O ports
;
DMA			EQU		0000H
DMA08		EQU		0008H

INTA00		EQU		0020H
INTA01		EQU		0021H

TIMER		EQU		0040H
TIMER0		EQU		0040H
TIM_CTL		EQU		0043H

PORT_A		EQU		0060H
KBD_IN		EQU		0060H
PORT_B		EQU		0061H
PORT_C		EQU		0062H
CMD_PORT	EQU		0063H

EOI			EQU		20H

;
; MEMORY ADDRESSES OF BIOS DATA 
;
DATA_BASE		EQU		0000H
NMI_PTR			EQU		0008H	; INT02
INT5_PTR		EQU		0014H	; INT05
INT_PTR			EQU		0020H	; INT08
VIDEO_INT		EQU		0040H	; INT10
DISK_POINTER	EQU		0074H   ; DW

; 
; THESE ARE OFFSETS INTO THE BIOS DATA SEGMENT 0040

RS232_BASE		EQU		0400H	; DW * 4
PRINTER_BASE	EQU		0408H	; DW * 4
EQUIP_FLAG		EQU		0410H	; DW
MFG_TST			EQU		0412H	; DB
MEMORY_SIZE		EQU		0413H	; DW
CRT_MODE_SET    EQU		0415H	; DB
KB_FLAG			EQU		0417H	; DB
KB_FLAG_1       EQU     0418H	; DB
ALT_INPUT		EQU		0419H	; DB
BUFFER_HEAD		EQU		041AH	; DW
BUFFER_TAIL		EQU		041CH	; DW
KB_BUFFER		EQU		041EH	; DB x 32
SEEK_STATUS		EQU		043EH	; DB
MOTOR_STATUS	EQU		043FH	; DB
MOTOR_COUNT		EQU		0440H	; DB
DISKETTE_STATUS	EQU		0441H	; DB
NEC_STATUS		EQU		0442H	; DB x 7
CRT_MODE		EQU		0449H	; DB
CRT_COLS		EQU		044AH	; DW
CRT_LEN			EQU		044CH	; DW
CRT_START   	EQU		044EH	; DW	
CURSOR_POSN		EQU		0450H	; DW x 8
ACTIVE_PAGE		EQU		0462H	; DB
ADDR_6845   	EQU		0463H	; DW
CRT_PALETTE		EQU		0466H
IO_ROM_INIT		EQU		0467H
IO_ROM_SEG		EQU		0469H
INTR_FLAG		EQU		046BH	; DB
TIMER_LOW		EQU		046CH	; DW
TIMER_HIGH		EQU		046EH	; DW
TIMER_OFL		EQU		0470H	; DB
BIOS_BREAK		EQU		0471H	; DB
RESET_FLAG		EQU		0472H	; DW
PRINT_TIM_OUT	EQU		0478H	; DB x 8
BUFFER_START	EQU		0480H	; DW
BUFFER_END		EQU		0482H	; DW
CURSOR_MODE 	EQU		0485H	; DW
PARM_PTR		EQU		04A8H	; DD
MFG_ERR_FLAG	EQU		04AEH	; DB

BOOT_LOCN		EQU		7C00H


; SEGMENTS
DATA		EQU		0000H
STACK		EQU		0030H
TOS			EQU		0100H


MAGIC	EQU	0ABCDH

;	CODE OF ROM BIOS IS STARTING HERE AT F000:E000 (8 KB)
;	-----------------------------------------------------
	ORG	0E000H
	DB	'1501512 COPR. IBM 1981'	;COPYRIGHT NOTICE PC XT

;-------------------------------------------
;	INITIAL RELIABILITY TESTS -- PHASE 1
;-------------------------------------------

;------------------------
;	DATA DEFINITIONS
;------------------------

C1	DW	C11			; RETURN ADDRESS
C2	DW	C24			; RETURN ADDRESS FOR DUMMY STACK

F3B	DB	' KB OK',13		; KB FOR MEMORY SIZE

;------------------------------------------------------------------------
;	LOAD A BLOCK OF TEST CODE THROUGH THE KEYBOARD PORT 		:
;	FOR MANUFACTURING TEST.						:
;	THIS ROUTINE WILL LOAD A TEST (MAX LENGTH=FAFFH) THROUGH	:
;	THE KEYBOARD PORT. CODE WILL BE LOADED AT LOCATION		:
;	0000:0500. AFTER LOADING, CONTROL WILL BE TRANSFERRED		:
;	TO LOCATION 0000:0500. STACK WILL BE LOCATED JUST BELOW		:
;	THE TEST CODE. THIS ROUTINE ASSUMES THAT THE FIRST 2		:
;	BYTES TRANSFERRED CONTAIN THE COUNT OF BYTES TO BE LOADED	:
;	(BYTE 1=COUNT LOW, BYTE 2=COUNT HI.) 				:
;------------------------------------------------------------------------

;----- FIRST, GET THE COUNT

MFG_BOOT:
	CALL	SP_TEST			; GET COUNT LOW
	MOV	BH,BL			; MOVE IT
	CALL	SP_TEST			; GET COUNT HI
	MOV	CH,BL
	MOV	CL,BH			; CX NOW HAS COUNT
	CLD				; SET DIR FLAG TO INCREMENT
	CLI
	MOV	DI,0500H		; SET TARGET OFFSET (DS=0000)
	MOV	AL,0FDH			; UNMASK K/B INTERRRUPT
	OUT	INTA01,AL
	MOV	AL,0AH			; SEND READ INT.REQUEST REG. CMD
	OUT	INTA00,AL
	MOV	DX,61H			; SET UP PORT B ADDRESS
	MOV	BX,4CCCH		; CONTROL BITS FOR PORT B
	MOV	AH,02H			; K/B REQUEST PENDING MASK
TST:
	MOV	AL,BL
	OUT	DX,AL			; TOGGLE K/B CLOCK
	MOV	AL,BH
	OUT	DX,AL
	DEC	DX			; POINT DX AT ADDR 60 (KB DATA)
TST1:
	IN	AL,INTA00		; GET IRR REG
	AND	AL,AH			; KB REQUEST PENDING?
	JZ	TST1			; LOOP TILL DATA PRESENT
	IN	AL,DX			; GET DATA
	STOSB				; STORE IT
	INC	DX			; POINT DX BACK AT PORT B (61)
	LOOP	TST			; LOOP TILL ALL BYTES READ

	;JMP	MFG_TEST_RTN		; FAR JUMP TO CODE THAT WAS JUST
	; TODO - figure out where MFG_TEST_RTN is supposed to go?
	HLT
					; LOADED
	DB	2 DUP(0FFH)		; DUMMY ******

;----------------------------------------
;	8088 PROCESSOR TEST		:
; DESCRIPTION				:
;	VERIFY 8088 FLAGS, REGISTERS	:
;	AND CONDITIONAL JUMPS		:
;----------------------------------------

RESET:
START:	CLI				; DISABLE INTERRUPTS
	MOV	AH,0D5H			; SET SF, CF, ZF, AND AF FLAGS ON
	SAHF
	JNC	ERR01			; GO TO ERR ROUTINE IF CF NOT SET
	JNZ	ERR01			; GO TO ERR ROUTINE IF ZF NOT SET
	JNP	ERR01			; GO TO ERR ROUTINE IF PF NOT SET
	JNS	ERR01			; GO TO ERR ROUTINE IF SF NOT SET
	LAHF				; LOAD FLAG IMAGE TO AH
	MOV	CL,5			; LOAD CNT REG WITH SHIFT CNT
	SHR	AH,CL			; SHIFT AF INTO CARRY BIT POS
	JNC	ERR01			; GO TO ERR ROUTINE IF AF NOT SET
	MOV	AL,40H			; SET THE OF FLAG ON
	SHL	AL,1			; SETUP FOR TESTING
	JNO	ERR01			; GO TO ERR ROUTINE IF OF NOT SET
	XOR	AH,AH			; SET AH = 0
	SAHF				; CLEAR SF, CF, ZF, AND PF
	JBE	ERR01			; GO TO ERR ROUTINE IF CF ON
					; GO TO ERR ROUTINE IF ZF ON
	JS	ERR01			; GO TO ERR ROUTINE IF SF ON
	JP	ERR01			; GO TO ERR ROUTINE IF PF ON
	LAHF				; LOAD FLAG IMAGE TO AH
	MOV	CL,5			; LOAD CNT REG WITH SHIFT CNT
	SHR	AH,CL			; SHIFT AF' INTO CARRY BIT POS
	JC	ERR01			; GO TO ERR ROUTINE IF ON
	SHL	AH,1			; CHECK THAT OF' IS CLEAR
	JO	ERR01			; GO TO ERR ROUTINE IF ON
	
;----- READ/WRITE THE 8088 GENERAL AND SEGMENTATION REGISTERS

;----- WITH ALL ONE'S AND ZEROES'S.

	MOV	AX,0FFFFH		; SETUP ONE'S PATTERN IN AX
	STC
C8:	MOV	DS,AX			; WRITE PATTERN TO ALL REGS
	MOV	BX,DS
	MOV	ES,BX
	MOV	CX,ES
	MOV	SS,CX
	MOV	DX,SS
	MOV	SP,DX
	MOV	BP,SP
	MOV	SI,BP
	MOV	DI,SI
	JNC	C9			; TST1A
	XOR	AX,DI			; PATTERN MAKE IT THRU ALL REGS
	JNZ	ERR01			; NO - GO TO ERR ROUTINE
	CLC
	JMP	C8
C9:					; TST1A
	OR	AX,DI			; ZERO PATTERN MAKE IT THRU?
	JZ	C10			; YES - GO TO NEXT TEST
ERR01:	HLT				; HALT SYSTEM
;----------------------------------------
;	ROS CHECKSUM TEST I		:
; DESCRIPTION				:
;	A CHECKSUM IS DONE FOR THE 8K	:
;	ROS MODULE CONTAINING POWER ON	:
;	DIAGNOSTIC (POD) AND BIOS.	:
;----------------------------------------
C10:				; ZERO IN AL ALREADY
	OUT	0A0H,AL			; DISABLE NMI INTERRUPTS
	OUT	83H,AL			; INITIALIZE DMA PAGE REGS
	MOV	DX,3D8H
	OUT	DX,AL			; DISABLE COLOR VIDEO
	INC	AL
	MOV	DL,0B8H
	OUT	DX,AL			; DISABLE B/W VIDEO,EN HIGH RES
	MOV	AL,89H			; SET 8255 FOR B,A=OUT, C=IN
	OUT	CMD_PORT,AL
	MOV	AL,10100101B
					; ENABLE PARITY CHECKERS AND
	OUT	PORT_B,AL		; PULL KB CLOCK HI, TRI-STATE
					; KEYBOARD INPUTS,ENABLE HIGH
					; BANK OF SWITCHES->PORT C(0-3)
	MOV	AL,01H			; ************************
	OUT	PORT_A,AL		; ****  CHECKPOINT 1  ****
					; ************************
	MOV	AX,CS			; SETUP SS REG
	MOV	SS,AX
	MOV	DS,AX			; SET UP DATA SEG TO POINT TO
					; ROM ADDRESS
	CLD				; SET DIRECTION FLAG TO INC.

	MOV	BX,0E000H		; SETUP STARTING ROS ADDR
	MOV	SP, C1		; SETUP RETURN ADDRESS
	JMP	ROS_CHECKSUM
C11:
	;JNE	ERR01			; HALT SYSTEM IF ERROR
;--------------------------------------------------------
;	8237 DMA INITIALIZATION CHANNEL REGISTER TEST	:
; DESCRIPTION						:
;	DISABLE THE 8237 DMA CONTROLLER. VERIFY THAT	:
;	TIMER 1 FUNCTIONS OK. WRITE/READ THE CURRENT	:
;	ADDRESS AND WORD COUNT REGISTERS FOR ALL	:
;	CHANNELS.  INITIALIZE AND START DMA FOR MEMORY	:
;	REFRESH.					:
;--------------------------------------------------------

;----- DISABLE DMA CONTROLLER

	MOV	AL,02H			; ************************
	OUT	PORT_A,AL		; ****  CHECKPOINT 2  ****
					; ************************
	MOV	AL,04			; DISABLE DMA CONTROLLER
	OUT	DMA08,AL

;----- VERIFY THAT TIMER 1 FUNCTIONS OK

	MOV	AL,54H			; SEL TIMER 1,LSB,MODE 2
	OUT	TIMER+3,AL
	MOV	AL,0FFH			; SET INITIAL TIMER CNT TO 0
	OUT	TIMER+1,AL
C12:					; TIMER1_BITS_ON
	MOV	AL,40H			; LATCH TIMER 1 COUNT
	OUT	TIMER+3,AL
	CMP	BL,0FFH			; YES - SEE IF ALL BITS GO OFF
	JE	C13			; TIMER1_BITS_OFF
	IN	AL,TIMER+1		; READ TIMER 1 COUNT
	OR	BL,AL			; ALL BITS ON IN TIMER
	LOOP	C12			; TIMER1_BITS_ON
	HLT				; TIMER 1 FAILURE, HALT SYS
C13:					; TIMER1_BITS_OFF
	MOV	AL,BL			; SET TIMER 1 CNT
	SUB	CX,CX
	OUT	TIMER+1,AL
C14:					; TIMER_LOOP
	MOV	AL,40H			; LATCH TIMER 1 COUNT
	OUT	TIMER+3,AL
	NOP				; DELAY FOR TIMER
	NOP
	IN	AL,TIMER+1		; READ TIMER 1 COUNT
	AND	BL,AL
	JZ	C15			; WRAP_DMA_REG
	LOOP	C14			; TIMER_LOOP
	HLT				; HALT SYSTEM

;----- INITIALIZE TIMER 1 TO REFRESH MEMORY

C15:
	MOV	AL,03H			; ************************
	OUT	PORT_A,AL		; ****  CHECKPOINT 3  ****
					; ************************
					; WRAP DMA REG
	OUT	DMA+0DH,AL		; SEND MASTER CLEAR TO DMA

;----- WRAP DMA CHANNELS ADDRESS AND COUNT REGISTERS

	MOV	AL,0FFH			; WRITE PATTERN FF TO ALL REGS
C16:	MOV	BL,AL			; SAVE PATTERN FOR COMPARE
	MOV	BH,AL
	MOV	CX,8			; SETUP LOOP CNT
	MOV	DX,DMA			; SETUP I/O PORT ADDR OF REG
C17:	OUT	DX,AL			; WRITE PATTERN TO REG, LSB
	PUSH	AX			; SATISFY 8237 I/O TIMINGS
	OUT	DX,AL			; MSB OF 16 BIT REG
	MOV	AL,01H			; AL TO ANOTHER PAT BEFORE RD
	IN	AL,DX			; READ 16-BIT DMA CH REG, LSB
	MOV	AH,AL			; SAVE LSB OF 16-BIT REG
	IN	AL,DX			; READ MSB OF DMA CH REG
	CMP	BX,AX			; PATTERN READ AS WRITTEN?
	JE	C18			; YES - CHECK NEXT REG
	HLT				; NO - HALT THE SYSTEM
C18:					; NXT_DMA_CH
	INC	DX			; SET I/O PORT TO NEXT CH REG
	LOOP	C17			; WRITE PATTERN TO NEXT REG
	INC	AL			; SET PATTERN TO 0
	JZ	C16			; WRITE TO CHANNEL REGS

;----- INITIALIZE AND START DMA FOR MEMORY REFRESH

	MOV	DS,BX			; SET UP ABS0 INTO DS AND ES
	MOV	ES,BX
	MOV	AL,0FFH			; SET CNT OF 64K FOR REFRESH
	OUT	DMA+1,AL
	PUSH	AX
	OUT	DMA+1,AL
	MOV	AL,058H			; SET DMA MODE,CH 0,RD.,AUTOINT
	OUT	DMA+0BH,AL		; WRITE DMA MODE REG
	MOV	AL,0			; ENABLE DMA CONTROLLER
	MOV	CH,AL			; SET COUNT HIGH=00
	OUT	DMA+8,AL		;SETUP DMA COMMAND REG
	PUSH	AX
	OUT	DMA+10,AL		; ENABLE DMA CH 0
	MOV	AL,18			; START TIMER 1
	OUT	TIMER+1,AL
	MOV	AL,41H			; SET MODE FOR CHANNEL 1
	OUT	DMA+0BH,AL
	PUSH	AX
	IN	AL,DMA+08		; GET DMA STATUS
	AND	AL,00010000B		; IS TIMER REQUEST THERE?
	JZ	C18C			; (IT SHOULD'T BE)
	HLT				; HALT SYS.(HOT TIMER 1 OUTPUT)
C18C:	MOV	AL,42H			; SET MODE FOR CHANNEL 2
	OUT	DMA+0BH,AL
	MOV	AL,43H			; SET MODE FOR CHANNEL 3
	OUT	DMA+0BH,AL
;------------------------------------------------
;	BASE 16K READ/WRITE STORAGE TEST	:
; DESCRIPTION					:
;	WRITE/READ/VERIFY DATA PATTERNS		:
;	AA,55,FF,01, AND 00 TO 1ST 32K OF	:
;	STORAGE. VERIFY STORAGE ADDRESSABILITY	:
;------------------------------------------------

;----- DETERMINE MEMORY SIZE AND FILL MEMORY WITH DATA

	MOV	DX,0213H		; ENABLE I/O EXPANSION BOX
	MOV	AL,01H
	OUT	DX,AL

	MOV	BX,[RESET_FLAG-DATA_BASE]
					; SAVE 'RESET_FLAG' IN BX
	MOV	CX,2000H		; SET FOR 16K WORDS
	CMP	BX, MAGIC	; WARM START?
	JE	CLR_STG
	MOV	SP, C2
	JMP	STGTST_CNT
C24:
	JE	HOW_BIG			; STORAGE OKAY, DETERMINE SIZE
	MOV	BL,AL			; SAVE FAILING BIT PATTERN
	MOV	AL,04H			; ************************
C24A:	OUT	PORT_A,AL		; ****  CHECKPOINT 4  ****
					; ************************
	SUB	CX,CX			; BASE RAM FAILURE - HANG
C24B:	LOOP	C24B			; FLIPPING BETWEEN 04 AND
	XCHG	BL,AL			; FAILING BIT PATTERN
	JMP	C24A
CLR_STG:
	SUB	AX,AX			; MAKE AX=0000
	REP	STOSW			; STORE 8K WORDS OF 0000

HOW_BIG:
	MOV	[RESET_FLAG-DATA_BASE],BX
					; RESTORE RESET_FLAG
	MOV	DX,0400H		; SET POINTER TO JUST>16KB
	MOV	BX,16			; BASIC COUNT OF 16K
FILL_LOOP:
	MOV	ES,DX			; SET SEG. REG.
	SUB	DI,DI
	MOV	AX,0AA55H		; TEST PATTERN
	MOV	CX,AX			; SAVE PATTERN
	MOV	ES:[DI],AX		; SEND PATTERN TO MEM.
	MOV	AL,0FH			; PUT SOMETHING IN AL
	MOV	AX,ES:[DI]		; GET PATTERN
	XOR	AX,CX			; COMPARE PATTERNS
	JNZ	HOW_BIG_END		; GO END IF NO COMPARE
	MOV	CX,2000H		; SET COUNT FOR 8K WORDS
	REP	STOSW			; FILL 8K WORDS
	ADD	DX,400H			; POINT TO NEXT 16KB BLOCK
	ADD	BX,16			; BUMP COUNT BY 16KB
	CMP	DH,0A0H			; TOP OF RAM AREA YET?
	JNZ	FILL_LOOP
HOW_BIG_END:
	MOV	[MEMORY_SIZE-DATA_BASE],BX
					; SAVE MEMORY SIZE

;----- SET UP STACK SEG AND SP

	MOV	AX,STACK		; GET STACK VALUE
	MOV	SS,AX			; SET THE STACK UP
	MOV	SP,TOS		; STACK IS READY TO GO
;--------------------------------------------------------
;	INITIALIZE THE 8295 INTERRUPT CONTROLLER CHIP	:
;--------------------------------------------------------
	MOV	AL,13H			; ICW1 - EDGE, SNGL, ICW4
	OUT	INTA00,AL
	MOV	AL,8			; SETUP ICW2 - INT TYPE 8 (8-F)
	OUT	INTA01,AL
	MOV	AL,9			; SETUP ICW4 - BUFFRD,8086 MODE
	OUT	INTA01,AL
	MOV	AL,0FFH			; MASK ALL INTS OFF
	OUT	INTA01,AL		; (VIDEO ROUTINE ENABLES INTS.)

;----- SET UP THE INTERRUPT VECTORS TO TEMP INTERRUPT

	PUSH	DS
	MOV	CX,32			; FILL ALL 32 INTERRUPTS
	SUB	DI,DI			; FIRST INTERRUPT LOCATION
	MOV	ES,DI			; SET ES=0000 ALSO
D3:	MOV	AX,D11		; MOVE ADDR OF INTR PROC TO TABLE
	STOSW
	MOV	AX,CS			; GET ADDR OF INTR PROC SEG
	STOSW
	LOOP	D3			; VECTBL0
	
;----- ESTABLISH BIOS SUBROUTINE CALL INTERRUPT VECTORS

	MOV	DI,VIDEO_INT	; SETUP ADDR TO INTR AREA
	PUSH	CS
	POP	DS			; SETUP ADDR OF VECTOR TABLE
	MOV	AX,DS			; SET AX=SEGMENT
	MOV	SI,VECTOR_TABLE+16	; START WITH VIDEO ENTRY
	NOP				; DUMMY ********
	MOV	CX,16
D3A:	MOVSW				; MOVE VECTOR TABLE TO RAM
	INC	DI			; SKIP SEGMENT POINTER
	INC	DI
	LOOP	D3A
;------------------------------------------------
;	DETERMINE CONFIGURATION AND MFG. MODE	:
;------------------------------------------------
CT:
	POP	DS
	PUSH	DS			; RECOVER DATA SEG
	IN	AL,PORT_C		; GET SWITCH INFO
	AND	AL,00001111B		; ISOLATE SWITCHES
	MOV	AH,AL			; SAVE
	MOV	AL,10101101B		; ENABLE OTHER BANK OF SWITCH
	OUT	PORT_B,AL
	NOP
	IN	AL,PORT_C
	MOV	CL,4
	ROL	AL,CL			; ROTATE TO HIGH NIBBLE
	AND	AL,11110000B		; ISOLATE
	OR	AL,AH			; COMBINE WITH OTHER BANK
	SUB	AH,AH
	MOV	[EQUIP_FLAG-DATA_BASE],AX
					; SAVE SWITCH INFO
	MOV	AL,99H
	OUT	CMD_PORT,AL
	CALL	KBD_RESET		; SEE IF MFG JUMPER IN
	CMP	BL,0AAH			; KEYBOARD PRESENT?
	JE	E6
	CMP	BL,065H			; LOAD MFG. TEST REQUEST?
	JNE	D3B
	JMP	MFG_BOOT		; GO TO BOOTSTRAP IF SO
D3B:	MOV	AL,38H
	OUT	PORT_B,AL
	NOP
	NOP
	IN	AL,PORT_A
	AND	AL,0FFH			; WAS DATA LINE GROUNDED
	JNZ	E6
	INC	BYTE PTR [MFG_TST-DATA_BASE]
					; SET MANUFACTURING TEST FLAG
;--------------------------------------------------------
;	INITIALIZE AND START CRT CONTROLLER (6845)	:
;	TEST VIDEO READ/WRITE STORAGE			:
; DESCRIPTION						:
;	RESET THE VIDEO ENABLE SIGNAL			:
;	SELECT ALPHANUMERIC MODE, 40 * 25, B & W.	:
;	READ/WRITE DATA PATTERNS TO STG. CHECK STG	:
;	ADDRESSABILITY.					:
; ERROR = 1 LONG AND 2 SHORT BEEPS			:
;--------------------------------------------------------
E6:
	MOV WORD PTR [PARM_PTR], VIDEO_PARMS
	PUSH CS
	POP WORD PTR [PARM_PTR + 2]
	MOV	AX,[EQUIP_FLAG-DATA_BASE]
					; GET SENSE SWITCH INFO
	PUSH	AX			; SAVE IT
	MOV	AL,30H
	MOV	[EQUIP_FLAG-DATA_BASE],AX
	SUB	AH,AH
	INT	10H			; SEND INIT TO B/W CARD
	MOV	AL,20H
	MOV	[EQUIP_FLAG-DATA_BASE],AX
	SUB	AH,AH			; AND INIT COLOR CARD
	INT	10H
	POP	AX			; RECOVER REAL SWITCH INFO
	MOV	[EQUIP_FLAG-DATA_BASE],AX ;RESTORE IT
					; AND CONTINUE
	AND	AL,30H			; ISOLATE VIDEO SWS
	JNZ	E7			; VIDEO SWS SET TO 0?
	MOV	DI,VIDEO_INT	; SET INT10H TO DUMMY
	MOV	WORD PTR [DI], DUMMY_RETURN ; RETURN IF NO VIDEO CARD
	JMP	E18_1			; BYPASS VIDEO TEST
E7:					; TEST_VIDEO:
	CMP	AL,30H			; B/W CARD ATTACHED?
	JE	E8			; YES, SET MODE FOR B/W CARD
	INC	AH			; SET COLOR MODE FOR COLOR CARD
	CMP	AL,20H			; 80X25 MODE SELECTED?
	JNE	E8			; NO, SET MODE FOR 40X25
	MOV	AH,3			; SET MODE FOR 80X25
E8:	XCHG	AH,AL			; SET_MODE:
	PUSH	AX			; SAVE VIDEO MODE ON STACK
	SUB	AH,AH			; INITIALIZE TO ALPHANUMERIC MD
	INT	10H			; CALL VIDEO_IO
	POP	AX			; RESTORE VIDEO SENSE SWS IN AH
	PUSH	AX			; RESAVE VALUE
	MOV	BX,0B000H		; BEG VIDEO RAM ADDR B/W CD
	MOV	DX,3B8H			; MODE REG FOR B/W
	MOV	CX,2048			; RAM WORD CNT FOR B/W CD
	MOV	AL,1			; SET MODE FOR B/W CARD
	CMP	AH,30H			; B/W VIDEO CARD ATTACHED?
	JE	E9			; YES - GO TEST VIDEO STG
	MOV	BH,0B8H			; BEG VIDEO RAM ADDRCOLOR CD
	MOV	DX,3D8H			; MODE REG FOR COLOR CD
	MOV	CH,20H			; RAM WORD CNT FOR COLOR CD
	DEC	AL			; SET MODE TO 0 FOR COLOR CD
E9:					; TEST_VIDEO_STG:
	OUT	DX,AL			; DISABLE VIDEO FOR COLOR CD
	CMP	WORD PTR [RESET_FLAG-DATA_BASE], MAGIC
					; POD INIT BY KBD RESET?
	MOV	ES,BX			; POINT ES TO VIDEO RAM STG
	JE	E10			; YES - SKIP VIDEO RAM TEST
	MOV	DS,BX			; POINT DS TO VIDEO RAM STG
	CALL	STGTST_CNT		; GO TEST VIDEO R/W STG
	JNE	E17			; R/W STG FAILURE - BEEP SPK
;------------------------------------------------
;	SETUP VIDEO DATA ON SCREEN FOR VIDEO	:
;	LINE TEST.				:
; DESCRIPTION					:
;	ENABLE VIDEO SIGNAL AND SET MODE.	:
;	DISPLAY A HORIZONTAL BAR ON SCREEN.	:
;------------------------------------------------
E10:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	PUSH	AX			; SAVE IT
	MOV	AH,0			; ENABLE VIDEO AND SET MODE
	INT	10H			; VIDEO
	MOV	AX,7020H		; WRT BLANKS IN REVERSE VIDEO

	JMP	E10A
;-------
	DB	14 DUP(0FFH)		; DUMMY *******
	JMP	NMI_INT			;IBM PC COMPATIBILITY
;-------
E10A:
	SUB	DI,DI			; SETUP STARTING LOC
	MOV	CX,40			; NO. OF BLANKS TO DISPLAY
	REP	STOSW			; WRITE VIDEO STORAGE
;----------------------------------------
;	CRT INTERFACE LINES TEST	:
; DESCRIPTION				:
;	SENSE ON/OFF TRANSITION OF THE	:
;	VIDEO ENABLE AND HORIZONTAL	:
;	SYNC LINES.			:
;----------------------------------------
	POP	AX			; GET VIDEO SENSE SW INFO
	PUSH	AX			; SAVE IT
	CMP	AH,30H			; B/W CARD ATTACHED?
	MOV	DX,03BAH		; SETUP ADDR OF STATUS PORT
	JE	E11			; YES - GO TEST LINES
	MOV	DX,03DAH		; COLOR CARD IS ATTACHED
E11:					; LINE_TST:
	MOV	AH,8
E12:					; OFLOOP_CNT:
	SUB	CX,CX
E13:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JNZ	E14			; ITS ON - CHECK IF IT GOES OFF
	LOOP	E13			; LOOP TILL ON OR TIMEOUT
	JMP	 E17		; GO PRINT ERROR MSG
E14:
	SUB	CX,CX
E15:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JZ	E16			; ITS ON - CHECK NEXT LINE
	LOOP	E15			; LOOP IF OFF TILL IT GOES ON
E17:					; CRT_ERR:
	CALL DDS
					; *****************************
	MOV	BYTE PTR DS:[MFG_ERR_FLAG],06H	; ****  CRT ERR CHKPT. 06  ****
					; *****************************
	MOV	DX,102H
	CALL	ERR_BEEP		; GO BEEP SPEAKER
	JMP	 E18
E16:					; NEXT LINE:
	MOV	CL,3			; GET NEXT BIT TO CHECK
	SHR	AH,CL
	JNZ	E12			; GO CHECK HORIZONTAL LINE
E18:					; DISPLAY_CURSOR:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	MOV	AH,0			; SET MODE AND DISPLAY CURSOR
	INT	10H			; CALL VIDEO I/O PROCEDURE
E18_1:
	MOV	DX,0C000H		; SEE IF ADVANCED VIDEO CARD
E18A:
	MOV	DS,DX			; IS PRESENT (VIDEO ROM AREA)
	SUB	BX,BX
	MOV	AX,[BX]			; GET FIRST 2 LOCATIONS
	PUSH	BX
	POP	BX			; LET BUS SETTLE
	CMP	AX,0AA55H		; PRESENT?
	JNZ	E18B			; NO? GO LOOK FOR OTHER MODULES
	CALL	ROM_CHECK		; GO SCAN MODULE
	JMP	E18C
E18B:
	ADD	DX,0080H		; POINT TO NEXT 2K BLOCK
E18C:
	CMP	DX,0C800H		; TOP OF VIDEO ROM AREA YET?
	JL	E18A			; GO SCAN FOR ANOTHER MODULE
;--------------------------------------------------------
;	8259 INTERRUPT CONTROLLER TEST			:
; DESCRIPTION						:
;	READ/WRITE THE INTERRUPT MASK REGISTER (IMR)	:
;	WITH ALL ONES AND ZEROES. ENABLE SYSTEM		:
;	INTERRUPTS.  MASK DEVICE INTERRUPTS OFF. CHECK	:
;	FOR HOT INTERRUPTS (UNEXPECTED).		:
;--------------------------------------------------------
	POP	DS

;----- TEST THE IMR REGISTER

	MOV	BYTE PTR [MFG_ERR_FLAG-DATA_BASE],05H
					; ************************
					; ****  CHECKPOINT 5  ****
					; ************************
	MOV	AL,0			; SET IMR TO ZERO
	OUT	INTA01,AL
	IN	AL,INTA01		; READ IMR
	OR	AL,AL			; IMR = 0?
	JNZ	D6			; GO TO ERR ROUTINE IF NOT 0
	MOV	AL,0FFH			; DISABLE DEVICE INTERRUPTS
	OUT	INTA01,AL		; WRITE TO IMR
	IN	AL,INTA01		; READ IMR
	ADD	AL,1			; ALL IMR BIT ON?
	JNZ	D6			; NO - GO TO ERR ROUTINE

;----- CHECK FOR HOT INTERRUPTS

;----- INTERRUPTS ARE MASKED OFF.  CHECK THAT NO INTERRUPTS OCCUR.

	MOV	[INTR_FLAG-DATA_BASE],AL
					; CLEAR INTERRUPT FLAG
	STI				; ENABLE EXTERNAL INTERRUPTS
	SUB	CX,CX			; WAIT 1 SEC FOR ANY INTRS THAT
D4:
	LOOP	D4			; MIGHT OCCUR
D5:
	LOOP	D5
	CMP	BYTE PTR [INTR_FLAG-DATA_BASE],00H
					; DID ANY INTERRUPTS OCCUR?
	JZ	D7			; NO - GO TO NEXT TEST
D6:
	MOV	SI, E0		; DISPLAY 101 ERROR
	NOP				; DUMMY *********************
	CALL	E_MSG
	CLI
	HLT				; HALT THE SYSTEM
;--------------------------------------------------------
;	8253 TIMER CHECKOUT				:
; DESCRIPTION						:
;	VERIFY THAT THE SYSTEM TIMER (0) DOESN'T COUNT	:
;	TOO FAST OR TOO SLOW.				:
;--------------------------------------------------------
D7:
	MOV	BYTE PTR [MFG_ERR_FLAG-DATA_BASE],02H
	
	;--------------------------------------
	; TODO - skipping timer test for now
	;        issue is interrupt rate
	;--------------------------------------
	JMP TIM_INIT
					; ********************************
					; ****  TIMER CHECKPOINT (2)  ****
					; ********************************
	MOV	AL,0FEH			; MASK ALL INTRS EXCEPT LVL 0
	OUT	INTA01,AL		; WRITE THE 8259 IMR
	MOV	AL,00010000B		; SEL TIM 0, LSB, MODE 0,BINARY
	OUT	TIM_CTL,AL		; WRITE TIMER CONTROL MODE REG
	MOV	CX,16H			; SET PGM LOOP CNT
	MOV	AL,CL			; SET TIMER 0 CNT REG
	OUT	TIMER0,AL		; WRITE TIMER 0 CNT REG
	ADD CX,100H
D8:
	TEST	BYTE PTR [INTR_FLAG-DATA_BASE],01H
					; DID TIMER 0 INTERRUPT OCCUR?
	JNZ	D9			; YES - CHECK TIMER OP FOR SLOW TIME
	LOOP	D8			; WAIT FOR INTR FOR SPECIFIED TIME
	JMP	D6			; TIMER 0 INTR DIDN'T OCCUR - ERR
D9:
	MOV	CX,12			; SET PGM LOOP CNT
	MOV	AL,0FFH			; WRITE TIMER 0 CNT REG
	OUT	TIMER0,AL
	MOV	BYTE PTR [INTR_FLAG-DATA_BASE],0
					; RESET INTR RECEIVED FLAG
	MOV	AL,0FEH			; REENABLE TIMER 0 INTERRUPTS
	OUT	INTA01,AL
D10:
	TEST	BYTE PTR [INTR_FLAG-DATA_BASE],01H
					; DID TIMER 0 INTERRUPT OCCUR?
	JNZ	D6			; YES - TIMER CNTING TOO FAST, ERR
	LOOP	D10			; WAIT FOR INTR FOR SPECIFIED TIME

;----- SETUP TIMER 0 TO MODE 3

TIM_INIT:
	MOV	AL,0FFH			; DISABLE ALL DEVICE INTERRUPTS
	OUT	INTA01,AL
	MOV	AL,36H			; SEL TIM 0,LSB,MSB,MODE 3
	OUT	TIMER+3,AL		; WRITE TIMER MODE REG
	MOV	AL,0FFH
	OUT	TIMER,AL		; WRITE LSB TO TIMER 0 REG
	OUT	TIMER,AL		; WRITE MSB TO TIMER 0 REG
;------------------------------------------------
;	KEYBOARD TEST				:
; DESCRIPTION					:
;	RESET THE KEYBOARD AND CHECK THAT SCAN	:
;	CODE 'AA' IS RETURNED TO THE CPU.	:
;	CHECK FOR STUCK KEYS.			:
;------------------------------------------------
	
	MOV	AL,99H			; SET 8255 MODE A,C=IN B=OUT
	OUT	CMD_PORT,AL
	MOV	AL,[EQUIP_FLAG-DATA_BASE]
	AND	AL,01			; TEST CHAMBER?
	JZ	F7			; BYPASS IF SO
	CMP	BYTE PTR [MFG_TST-DATA_BASE],1
					; MANUFACTURING TEST MODE?
	JE	F7			; YES - SKIP KEYBOARD TEST
	CALL	KBD_RESET		; ISSUE RESET TO KEYBOARD
	JCXZ	F6			; PRINT ERR MSG IF NO INTERRUPT
	MOV	AL,49H			; ENABLE KEYBOARD
	OUT	PORT_B,AL
	CMP	BL,0AAH			; SCAN CODE AS EXPECTED?
	JNE	F6			; NO - DISPLAY ERROR MSG

;----- CHECK FOR STUCK KEYS

	MOV	AL,0C8H			; CLR KBD, SET CLK LINE HIGH
	OUT	PORT_B,AL
	MOV	AL,48H			; ENABLE KBD,CLK IN NEXT BYTE
	OUT	PORT_B,AL
	SUB	CX,CX
F5:					; KBD_WAIT:
	LOOP	F5			; DELAY FOR A WHILE
	
	IN	AL,KBD_IN		; CHECK FOR STUCK KEYS
	CMP	AL,0			; SCAN CODE = 0?
	JE	F7			; YES - CONTINUE TESTING
	CALL	XPC_BYTE		; CONVERT AND PRINT
F6:
	MOV	SI, F1		; GET MSG ADDR
	NOP				; DUMMY *********************
	CALL	E_MSG			; PRINT MSG ON SCREEN
;------------------------------------------------
;	SETUP HARDWARE INT. VECTOR TABLE	:
;------------------------------------------------
F7:
	PUSH	DS			; SETUP_INT_TABLE:
	SUB	AX,AX
	MOV	ES,AX
	MOV	CX,08			; GET VECTOR CNT
	PUSH	CS			; SETUP DS SEG REG
	POP	DS
	MOV	SI,VECTOR_TABLE
	NOP				; DUMMY *********************
	MOV	DI,INT_PTR
F7A:
	MOVSW
	INC	DI			; SKIP OVER SEGMENT
	INC	DI
	LOOP	F7A
	POP	DS

;----- SET UP OTHER INTERRUPTS AS NECESSARY

	MOV	WORD PTR NMI_PTR, NMI_INT	; NMI INTERRUPT
	MOV	WORD PTR INT5_PTR, PRINT_SCREEN	; PRINT SCREEN
	;MOV	BASIC_PTR+2,0F600H	; SEGMENT FOR CASSETTE BASIC
	; TODO - BASIC address?

;----- SETUP TIMER 0 TO BLINK LED IF MANUFACTURING TEST MODE

	CMP	BYTE PTR [MFG_TST-DATA_BASE],01H ; MFG TEST MODE?
	JNZ	EXP_IO
	MOV	WORD PTR DS:[1CH*4], BLINK_INT; SETUP TIMER INTR
 					    ;  TO BLINK LED
	MOV	AL,0FEH			; ENABLE TIMER INTERRUPT
	OUT	INTA01,AL
;----------------------------------------------------------------
; EXPANSION I/O BOX TEST					:
;	CHECK TO SEE IF EXPANSION BOX PRESENT - IF INSTALLED,	:
;	TEST DATA AND ADDRESS BUSES TO I/O BOX			:
;  ERROR='1801'							:
;----------------------------------------------------------------

;----- DETERMINE IF BOX IS PRESENT

EXP_IO:
	MOV	DX,0210H		; CONTROL PORT ADDRESS
	MOV	AX,5555H		; SET DATA PATTERN
	OUT	DX,AL
	MOV	AL,01H			; MAKE AL DIFFERENT
	IN	AL,DX			; RECOVER DATA
	CMP	AL,AH			; REPLY?
	JNE	E19			; NO RESPONSE, GO TO NEXT TEST
	NOT	AX			; MAKE DATA=AAAA
	OUT	DX,AL
	MOV	AL,01H
	IN	AL,DX			; RECOVER DATA
	CMP	AL,AH
	JNE	E19

;----- CHECK ADDRESS BUS

	MOV	BX,0001H
	MOV	DX,0215H		; LOAD HI ADDR. REG ADDRESS
	MOV	CX,0016			; GO ACROSS 16 BITS
EXP3:
	MOV	CS:[BX],AL		; WRITE ADDRESS F0000+BX
	NOP
	IN	AL,DX			; READ ADDR. HIGH
	CMP	AL,BH
	JNE	EXP_ERR			; GO ERROR IF MISCOMPARE
	INC	DX			; DX=216H (ADDR. LOW REG)
	IN	AL,DX
	CMP	AL,BL			; COMPARE TO LOW ADDRESS
	JNE EXP_ERR
	DEC	DX			; DX BACK TO 215H
	SHL	BX,1
	LOOP	EXP3			; LOOP TILL '1' WALKS ACROSS BX

;----- CHECK DATA BUS

	MOV	CX,0008			; DO 8 TIMES
	MOV	AL,01
	DEC	DX			; MAKE DX=214H (DATA BUS REG)
EXP4:
	MOV	AH,AL			; SAVE DATA BUS VALUE
	OUT	DX,AL			; SEND VALUE TO REG
	MOV	AL,01H
	IN	AL,DX			; RETRIEVE VALUE FROM REG
	CMP	AL,AH			; = TO SAVED VALUE
	JNE	EXP_ERR
	SHL	AL,1			; FROM NEW DATA PATTERN
	LOOP	EXP4			; LOOP TILL BIT WALKS ACROSS AL
	JMP	 E19		; GO ON TO NEXT TEST
EXP_ERR:
	MOV	SI, F3C
	NOP				; DUMMY **********************
	CALL	E_MSG
;--------------------------------------------------------
;	ADDITIONAL READ/WRITE STORAGE TEST		:
; DESCRIPTION						:
;	WRITE/READ DATA PATTERNS TO ANY READ/WRITE	:
;	STORAGE AFTER THE FIRST 32K.  STORAGE		:
;	ADDRESSABILITY IS CHECKED.			:
;--------------------------------------------------------

E19:
	CALL	DDS
	PUSH	DS
	CMP	WORD PTR [RESET_FLAG],MAGIC	; WARM START?
	JNE	E20A			; CONTINUE TEST IF NOT
	JMP	ROM_SCAN		; GO TO NEXT ROUTINE IF SO
E20A:
	MOV	AX,16			; STARTING AMT. OF MEMORY OK
	JMP	PRT_SIZ		; POST MESSAGE
E20B:
	MOV	BX,[MEMORY_SIZE]		; GET MEM. SIZE WORD
	SUB	BX,16			; 1ST 16K ALREADY DONE
	MOV	CL,04H
	SHR	BX,CL			; DIVIDE BY 16
	MOV	CX,BX			; SAVE COUNT OF 16K BLOCKS
	MOV	BX,0400H		; SET PTR. TO RAM SEGMENT>16K
E21:
	MOV	DS,BX			; SET SEG. REG
	MOV	ES,BX
	ADD	BX,0400H		; POINT TO NEXT 16K
	PUSH	DX
	PUSH	CX			; SAVE WORK REGS
	PUSH	BX
	PUSH	AX
	MOV	CX,2000H		; SET COUNT FOR 8K WORDS
	CALL	STGTST_CNT
	JNZ	E21A			; GO PRINT ERROR
	POP	AX			; RECOVER TESTED MEM NUMBER
	ADD	AX,16
PRT_SIZ:
	PUSH	AX
	MOV	BX,10			; SET UP FOR DECIMAL CONVERT
	MOV	CX,3			; OF 3 NIBBLES
DECIMAL_LOOP:
	XOR	DX,DX
	DIV	BX			; DIVIDE BY 10
	OR	DL,30H			; MAKE INTO ASCII
	PUSH	DX			; SAVE
	LOOP	DECIMAL_LOOP
	MOV	CX,3
PRT_DEC_LOOP:
	POP	AX			; RECOVER A NUMBER
	CALL	PRT_HEX
	LOOP	PRT_DEC_LOOP
	MOV	CX,7
	MOV	SI, F3B		; PRINT ' KB OK'
KB_LOOP:
	MOV	AL,CS:[SI]
	INC	SI
	CALL	PRT_HEX
	LOOP	KB_LOOP
	POP	AX			; RECOVER WORK REGS
	CMP	AX,16			; FIRST PASS?
	JE	E20B
	POP	BX
	POP	CX
	POP	DX
	LOOP	E21			; LOOP TILL ALL MEM. CHECKED
	MOV	AL,10
	CALL	PRT_HEX			; LINE FEED
	
;----- DMA TC0 SHOULD BE ON BY NOW - SEE IF IT IS

	IN	AL,DMA+08H
	AND	AL,00000001B		; TC0 STATUS BIT ON?
	JNZ	ROM_SCAN		; GO ON WITH NEXT TEST IF OK
	POP	DS
	MOV	BYTE PTR [MFG_ERR_FLAG],03H	; ***************************
	JMP	D6			; POST 101 ERROR MSG AND HALT
					; ***************************

;----- PRINT FAILING ADDRESS AND XOR'ED PATTERN IF DATA COMPARE ERROR

E21A:	MOV	CH,AL			; SAVE FAILING BIT PATTERN
	MOV	AL,13			; CARRAGE RETURN
	CALL	PRT_HEX
	MOV	AL,10
	CALL	PRT_HEX
	POP	AX 		; RECOVER AMT. OF MEM.
	ADD	SP,6			; BALANCE STACK
	MOV	DX,DS			; GET FAILING SEGMENT
	POP	DS
	PUSH	DS
	MOV	[MEMORY_SIZE],AX		; LOAD MEM. SIZE WORD TO SHOW
					; HOW MUCH MEM. WORKING
	MOV	[MFG_ERR_FLAG],DH		; **************************
					; **  CHECKPOINTS 08->A0  **
					; **************************
	CALL	PRT_SEG			; PRINT IT
	MOV	AL,CH			; GET FAILING BIT PATTERN
	CALL	XPC_BYTE		; CONVERT AND PRINT CODE
	MOV	SI, E1		; SETUP ADDRESS OF ERROR MSG
	NOP				; DUMMY *********************
	CALL	E_MSG			; PRINT ERROR MSG
;-------------------------------------------------------------------
; CHECK FOR OPTIONAL ROM FROM C8000 -> F4000 IN 2K BLOCKS
;	(A VALID MODULE HAS '55AA' IN THE FIRST 2 LOCATIONS,
;	LENGTH INDICATOR (LENGTH/512) IN THE 3RD LOCATION AND
;	TEST/INIT. CODE STARTING IN THE 4TH LOCATION.)
;-------------------------------------------------------------------
ROM_SCAN:
	MOV	DX,0C800H		; SET BEGINNING ADDRESS
ROM_SCAN_1:
	MOV	DS,DX
	SUB	BX,BX			; SET BX=0000
	MOV	AX,[BX]			; GET 1ST WORD FROM MODULE
	PUSH	BX
	POP	BX			; BUS SETTLING
	CMP	AX,0AA55H		; = TO ID WORD?
	JNZ	NEXT_ROM		; PROCEED TO NEXT ROM IF NOT
	CALL	ROM_CHECK		; GO CHECK OUT MODULE
	JMP	ARE_WE_DONE		; CHECK FOR END OF ROM SPACE
NEXT_ROM:
	ADD	DX,0080H		; POINT TO NEXT 2K ADDRESS
ARE_WE_DONE:
	CMP	DX,0F600H		; AT F6000 YET?
	JL	ROM_SCAN_1		; GO CHECK ANOTHER ADD. IF NOT	

;--------------------------------------------------------------------
;	DISKETTE ATTACHMENT TEST
; DESCRIPTION
;	CHECK IF IPL DISKETTE DRIVE IS ATTACHED TO SYSTEM.
;	IF ATTACHED, VERIFY STATUS OF NEC FDC AFTER A RESET.
;	ISSUE A RECAL AND SEEK CMD TO FDC AND CHECK STATUS.
;	COMPLETE SYSTEM INITIALIZATION THEN PASS CONTROL TO
;	THE BOOT LOADER PROGRAM.
;--------------------------------------------------------------------

	POP	DS
;----- RESET THE DISK PARAMETER TABLE VECTOR

	MOV	WORD PTR [DISK_POINTER], DISK_BASE
	MOV	WORD PTR [DISK_POINTER+2],CS
	
	MOV	AL,[EQUIP_FLAG]; DISKETTE PRESENT?
	AND	AL,01H			; NO - BYPASS DISKETTE TEST
	JZ	F15
					; DISK_TEST:
	IN	AL,INTA01
	AND	AL,0BFH			; ENABLE DISKETTE INTERRUPTS
	OUT	INTA01,AL
	MOV	AH,0			; RESET NEC FDC
	MOV	DL,AH			; SET FOR DRIVE 0
	INT	13H			; VERIFY STATUS AFTER RESET
	TEST	AH,0FFH			; STATUS OK?
	JNZ	F13			; NO - FDC FAILED

;----- TURN DRIVE 0 MOTOR ON

	MOV	DX,03F2H		; GET ADDR OF FDC CARD
	MOV	AL,1CH			; TURN MOTOR ON, EN DMA/INT
	OUT	DX,AL			; WRITE FDC CONTROL REG
	SUB	CX,CX
F11:					; MOTOR_WAIT:
	LOOP	F11			; WAIT FOR 1 SECOND
F12:					; MOTOR_WAIT1:
	LOOP	F12
	XOR	DX,DX			; SELECT DRIVE 0
	MOV	CH,1			; SELECT TRACK 1
	MOV	[SEEK_STATUS],DL
	CALL	SEEK			; RECALIBRATE DISKETTE
	JC	F13			; GO TO ERR SUBROUTINE IF ERR
	MOV	CH,34			; SELECT TRACK 34
	CALL	SEEK			; SEEK TO TRACK 34
	JNC	F14			; OK, TURN MOTOR OFF
F13:					; DSK_ERR:
	MOV	SI, F3		; GET ADDR OF MSG
	NOP				; DUMMY *********************
	CALL	E_MSG			; GO PRINT ERROR MSG

;----- TURN DRIVE 0 MOTOR OFF

F14:					; DR0_OFF:
	MOV	AL,0CH			; TURN DRIVE 0 MOTOR OFF
	MOV	DX,03F2H		; FDC CTL ADDRESS
	OUT	DX,AL

;----- SETUP PRINTER AND RS232 BASE ADDRESSES IF DEVICE ATTACHED

F15:
	MOV	BYTE PTR [INTR_FLAG],00H		; SET STRAY INTERRUPT FLAG = 00
	MOV	SI, KB_BUFFER ; SETUP KEYBOARD PARAMETERS
	MOV	[BUFFER_HEAD],SI
	MOV	[BUFFER_TAIL],SI
	MOV	[BUFFER_START],SI
	ADD	SI,32			; DEFAULT BUFFER OF 32 BYTES
	MOV	[BUFFER_END],SI
	MOV	DI, PRINT_TIM_OUT	; SET DEFAULT PRINTER TIMEOUT
	PUSH	DS
	POP	ES
	MOV	AX,1414H		; DEFAULT=20
	STOSW
	STOSW
	MOV	AX,0101H		; RS232 DEFAULT=01
	STOSW
	STOSW
	IN	AL,INTA01
	AND	AL,0FCH			; ENABLE TIMER AND KB INTS
	OUT	INTA01,AL
	CMP	BP,0000H		; CHECK FOR BP= NON-ZERO
					; (ERROR HAPPENED)
	JE	F15A_0			; CONTINUE IF NO ERROR
	MOV	DX,2			; 2 SHORT BEEPS (ERROR)
	CALL	ERR_BEEP
	MOV	SI, F3D		; LOAD ERROR MSG
	NOP				; DUMMY *********************
	CALL	P_MSG
ERR_WAIT:
	MOV	AH,00
	INT	16H			; WAIT FOR 'F1' KEY
	CMP	AH,3BH
	JNE	ERR_WAIT
	JMP	F15A			; BYPASS ERROR
F15A_0:
	CMP	BYTE PTR [MFG_TST],1		; MFG MODE
	JE	F15A			; BYPASS BEEP
	MOV	DX,1			; 1 SHORT BEEP (NO ERRORS)
	CALL	ERR_BEEP
F15A:
	MOV	AL,BYTE PTR [EQUIP_FLAG]	; GET SWITCHES
	AND	AL,00000001B		; 'LOOP POST' SWITCH ON
	JNZ	F15B			; CONTINUE WITH BRING-UP
	JMP	START
F15B:
 SUB	AH,AH
	MOV	AL,[CRT_MODE]
	INT	10H			; CLEAR SCREEN
	MOV	BP, F4		; PRT_SRC_TBL
	NOP				; DUMMY ***********************
	MOV	SI,0
F16:					; PRT_BASE:
	MOV	DX,CS:[BP]		; GET PRINTER BASE ADDR
	MOV	AL,0AAH			; WRITE DATA TO PORT A
	OUT	DX,AL
	PUSH	DS			; BUS SETTLING
	IN	AL,DX			; READ PORT A
	POP	DS
	CMP	AL,0AAH			; DATA PATTERN SAME
	JNE	F17			; NO - CHECK NEXT PRT CD
	MOV	PRINTER_BASE[SI],DX
					; YES - STORE PRT BASE ADDR
	INC	SI 			; INCREMENT TO NEXT WORD
	INC	SI
F17:
	INC	BP			; POINT TO NEXT BASE ADDR
	INC	BP
	CMP	BP, F4E		; ALL POSSIBLE ADDRS CHECKED?
	JNE	F16			; PRT_BASE

	MOV	BX,0			; POINTER TO RS232 TABLE
	MOV	DX,3FAH			; CHECK IF RS232 CD 1 ATTCH?
	IN	AL,DX			; READ INTR ID REG
	TEST	AL,0F8H
	JNZ	F18
	MOV	WORD PTR RS232_BASE[BX],3F8H ; SETUP RS232 CD #1 ADDR
	INC	BX
	INC	BX
F18:
	MOV	DX,2FAH			; CHECK IF RS232 CD 2 ATTCH
	IN	AL,DX			; READ INTERRUPT ID REG
	TEST	AL,0F8H
	JNZ	F19			; BASE_END
	MOV	WORD PTR RS232_BASE[BX],2F8H ; SETUP RS232 CD #2 ADDR
	INC	BX
	INC	BX

;----- SET UP EQUIP FLAG TO INDICATE NUMBER OF PRINTERS AND RS232 CARDS

F19:					; BASE_END:
	MOV	AX,SI			; SI HAS 2* NUMBER OF RS232
	MOV	CL,3			; SHIFT COUNT
	ROR	AL,CL			; ROTATE RIGHT 3 POSITIONS
	OR	AL,BL			; OR IN THE PRINTER COUNT
	MOV	BYTE PTR [EQUIP_FLAG+1],AL ; STORE AS SECOND BYTE
	MOV	DX,201H			; CHECK IF GAME CARD ATTACHED
	IN	AL,DX
	NOP
	NOP
	NOP
	TEST	AL,0FH
	JNZ	F20			; NO GAME CARD
	OR	BYTE PTR [EQUIP_FLAG+1],16
F20:					; NO GAME CARD:

;----- ENABLE NMI INTERRUPTS

	IN	AL,PORT_B		; RESET CHECK ENABLES
	OR	AL,30H
	OUT	PORT_B,AL
	AND	AL,0CFH
	OUT	PORT_B,AL
	MOV	AL,80H			; ENABLE NMI INTERRUPTS
	OUT	0A0H,AL
					; LOAD_BOOT_STRAP:
	INT	19H			; GO TO THE BOOT LOADER

	
;--------------------------------------------------------------------
; THIS SUBROUTINE PERFORMS A READ/WRITE STORAGE TEST ON A BLOCK
;	OF STORAGE.
; ENTRY REQUIREMENTS:
;	ES = ADDRESS OF STORAGE SEGMENT BEING TESTED
;	DS = ADDRESS OF STORAGE SEGMENT BEING TESTED
;	CX = WORD COUNT OF STORAGE BLOCK TO BE TESTED
; EXIT PARAMETERS:
;	ZERO FLAG = 0 IF STORAGE ERROR (DATA COMPARE OR PARITY
;	CHECK. AL=0 DENOTES A PARITY CHECK. ELSE AL=XOR'ED
;	BIT PATTERN OF THE EXPECTED DATA PATTERN VS THE ACTUAL
;	DATA READ.
; AX,BX,CX,DX,DI, AND SI ARE ALL DESTROYED.
;--------------------------------------------------------------------

STGTST_CNT:
	CLD				; SET DIR FLAG TO INCREMENT
	SUB	DI,DI			; SET DI=OFFSET 0 REL TO ES REG
	SUB	AX,AX			; SETUP FOR 0->FF PATTERN TEST
C2_1:
	MOV	[DI],AL			; ON FIRST BYTE
	MOV	AL,[DI]
	XOR	AL,AH			; OK?
	JNZ	C7			; GO ERROR IF NOT
	INC	AH
	MOV	AL,AH
	JNZ	C2_1			; LOOP TILL WRAP THROUGH FF
	MOV	BX,CX			; SAVE WORD COUNT OF BLOCK TO TEST
	SHL	BX,1			; CONVERT TO A BYTE COUNT
	MOV	AX,0AAAAH		; GET INITIAL DATA PATTERN TO WRITE
	MOV	DX,0FF55H		; SETUP OTHER DATA PATTERNS TO USE

	REP	STOSW			; FILL STORAGE LOCATIONS IN BLOCK
CT1:
	IN	AL,PORT_B
	OR	AL,00110000B		; TOGGLE PARITY CHECK LATCHES
	OUT	PORT_B,AL
	NOP
	AND	AL,11001111B
	OUT	PORT_B,AL
C3:
	DEC	DI			; POINT TO LAST BYTE JUST WRITTEN
	STD				; SET DIR FLAGS TO GO BACKWARDS
C4:
	MOV	SI,DI			; INITIALIZE DESTINATION POINTER
	MOV	CX,BX			; SETUP BYTE COUNT FOR LOOP
C5:					;	INNER TEST LOOP
	LODSB				; READ OLD TEST BYTE FROM STORAGE [SI]
	XOR	AL,AH			; DATA READ EXPECTED ?
	JNE	C7			; NO - GO TO ERROR ROUTINE
	MOV	AL,DL			; GET NEXT DATA PATTERN TO WRITE
	STOSB				; WRITE INTO LOC JUST READ [DI]+
	LOOP	C5 		; DECREMENT BYTE COUNT AND LOOP  CX

	AND	AH,AH			; ENDING ZERO PATTERN WRITTEN TO STG?
	JZ	C6X			; YES - RETURN TO CALLER WITH AL=0
	MOV	AH,AL			; SETUP NEW VALUE FOR COMPARE
	XCHG	DH,DL			; MOVE NEXT DATA PATTERN TO DL
	AND	AH,AH			; READING ZERO PATTERN THIS PASS?
	JNZ	C6			; CONTINUE TEST SEQUENCE TILL ZERO DATA
	MOV	DL,AH			; ELSE SET FOR END READ PATTERN
	JMP	C3			; AND MAKE FINAL BACKWARDS PASS
C6:
	CLD				; SET DIR FLAG TO GO FORWARD
	INC	DI			; SET POINTER TO BEG LOCATION
	JZ	C4			; READ/WRITE FORWARD IN STG
	DEC	DI 		; ADJUST POINTER
	MOV	DX,00001H		; SETUP 1 FOR PARITY BIT AND 0 FOR END
	JMP	C3			; READ/WRITE BACKWARD IN STG
C6X:
	IN	AL,PORT_C		; DID A PARITY ERROR OCCUR?
	AND	AL,0C0H			; ZERO FLAG WILL BE OFF PARITY ERROR
	MOV	AL,000H			; AL=0 DATA COMPARE OK
C7:
	CLD				; SET DIRECTION FLAG TO INC
	RET
	
CASSETTE_IO:
	STC				; CARRY INDICATOR=1
	MOV	AH,86H			; 'INVALID COMMAND'
	RET	2

;------------------------------------------------
; THESE ARE THE VECTORS WHICH ARE MOVED INTO	:
; THE 8086 INTERRUPT AREA DURING POWER ON.	:
; ONLY THE OFFSETS ARE DISPLAYED HERE, CODE	:
; SEGMENT WILL BE ADDED FOR ALL OF THEM, EXCEPT	:
; WHERE NOTED.					:
;------------------------------------------------
	
VECTOR_TABLE:		; VECTOR TABLE FOR MOVE TO INTERRUPTS
	DW	TIMER_INT	; INTERRUPT 8
	DW	KB_INT		; INTERRUPT 9
	DW	D11			; INTERRUPT A
	DW	D11			; INTERRUPT B
	DW	D11			; INTERRUPT C
	DW	D11			; INTERRUPT D
	DW	DISK_INT	; INTERRUPT E
	DW	D11			; INTERRUPT F
	DW	VIDEO_IO		; INTERRUPT 10H
	DW	EQUIPMENT		; INTERRUPT 11H
	DW	MEMORY_SIZE_DET	; INTERRUPT 12H
	DW	DISKETTE_IO		; INTERRUPT 13H
	DW	RS232_IO		; INTERRUPT 14H
	DW	CASSETTE_IO		; INTERRUPT 15H(FORMER CASSETTE IO)
	DW	KEYBOARD_IO 	; INTERRUPT 16H
	DW	PRINTER_IO		; INTERRUPT 17H

	DW	0000H			; INTERRUPT 18H
;	DW	0F600H			;  MUST BE INSERTED INTO TABLE LATER

	DW	BOOT_STRAP		; INTERRUPT 19H
	DW	TIME_OF_DAY		; INTERRUPT 1AH -- TIME OF DAY
	DW	DUMMY_RETURN	; INTERRUPT 1BH -- KEYBOARD BREAK ADDR
	DW	DUMMY_RETURN	; INTERRUPT 1CH -- TIMER BREAK ADDR
	DW	VIDEO_PARMS		; INTERRUPT 1DH -- VIDEO PARAMETERS
	DW	DISK_BASE		; INTERRUPT 1EH -- DISK PARAMETERS
	DW	0000H			; INTERRUPT 1FH -- POINTER TO VIDEO EXT
	
;--------------------------------------------------------
; TEMPORARY INTERRUPT SERVICE ROUTINE			:
;	THIS ROUTINE IS ALSO LEFT IN PLACE AFTER THE	:
;	POWER ON DIAGNOSTCS TO SERVICE UNUSED		:
;	INTERRUPT VECTORS. LOCATION 'INTR_FLAG' WILL	:
;	CONTAIN EITHER:					:
;	1. LEVEL OF HARDWARE INT. THAT CAUSED CODE	:
;	   TO BE EXEC.					:
;	2. 'FF' FOR NON-HARDWARE INTERRUPTS THAT WAS	:
;	   EXECUTED ACCIDENTLY.				:
;--------------------------------------------------------
D11:
	PUSH	DS
	PUSH	DX
	PUSH	AX			; SAVE REG AX CONTENTS
	CALL	DDS
	MOV	AL,0BH			; READ IN-SERVICE REG
	OUT	INTA00,AL		; (FIND OUT WHAT LEVEL BEING
	NOP				; SERVICED)
	IN	AL,INTA00		; GET LEVEL
	MOV	AH,AL			; SAVE IT
	OR	AL,AH			; 00? (NO HARDWARE ISR ACTIVE)
	JNZ	HW_INT
	MOV	AH,0FFH
	JMP	SET_INTR_FLAG	; SET FLAG TO FF IF NON-HDWARE
HW_INT:
	IN	AL,INTA01		; GET MASK VALUE
	OR	AL,AH			; MASK OF LVL BEING SERVICED
	OUT	INTA01,AL
	MOV	AL,EOI
	OUT	INTA00,AL
SET_INTR_FLAG:
	MOV	BYTE PTR INTR_FLAG,AH		; SET FLAG
	POP	AX			; RESTORE REG AX CONTENTS
	POP	DX
	POP	DS
DUMMY_RETURN:				; NEED IRET FOR VECTOR TABLE
	IRET
	
;--- INT 11 -----------------------------------------------------
; EQUIPMENT DETERMINATION					:
;	THIS ROUTINE ATTEMPTS TO DETERMINE WHAT OPTIONAL	:
;	DEVICES ARE ATTACHED TO THE SYSTEM.			:
; INPUT								:
;	NO REGISTERS						:
;	THE EQUIP_FLAG VARIABLE IS SET DURING THE POWER ON	:
;	DIAGNOSTICS USING THE FOLLOWING HARDWARE ASSUMPTIONS:	:
;	PORT 60  =  LOW ORDER BYTE OF EQUIPMENT			:
;	PORT 3FA = INTERRUPT ID REGISTER OF 8250		:
;		BITS 7-3 ARE ALWAYS 0.				:
;	PORT 378 = OUTPUT PORT OF PRINTER -- 8250 PORT THAT	:
;		CAN BE READ AS WELL AS WRITTEN.			:
; OUTPUT							:
;	(AX) IS SET, BIT SIGNIFICANT, TO INDICATE ATTACHED I/O	:
;	BIT 15,14 = NUMBER OF PRINTERS ATTACHED			:
;	BIT 13 NOT USED						:
;	BIT 12 = GAME I/O ATTACHED				:
;	BIT 11,10,9 = NUMBER OF RS232 CARDS ATTACHED		:
;	BIT 8 UNUSED						:
;	BIT 7,6 = NUMBER OF DISKETTE DRIVES			:	:
;		00=1, 01=2, 10=3, 11=4 ONLY IF BIT 0 = 1	:
;	BIT 5,4 = INITIAL VIDEO MODE				:
;		00 - UNUSED					:
;		01 - 40X25 BW USING COLOR CARD			:
;		10 - 80X25 BW USING COLOR CARD			:
;		11 - 80X25 BW USING BW CARD			:
;	BIT 3,2 = PLANARRAM SIZE (00=16K,01=32K,10=48K,11=64K)	:
;	BIT 1 NOT USED						:
;	BIT 0 = IPL FROM DISKETTE -- THIS BIT INDICATES THAT	:
;		THERE ARE DISKETTE DRIVES ON THE SYSTEM		:
;								:
;	NO OTHER REGISTERS AFFECTED				:
;----------------------------------------------------------------
	
EQUIPMENT:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			;SAVE SEGMENT REGISTER
	CALL	DDS
	MOV	AX,[EQUIP_FLAG]		; GET THE CURRENT SETTINGS
	POP	DS			; RECOVER SEGMENT
	IRET				; RETURN TO CALLER
	
;--- INT 12 -------------------------------------------------------------
; MEMORY_SIZE_DET							:
;	THIS ROUTINE DETERMINES THE AMOUNT OF MEMORY IN THE SYSTEM	:
;	AS REPRESENTED BY THE SWITCHES ON THE PLANAR. NOTE THAT THE	:
;	SYSTEM MAY NOT BE ABLE TO USE I/O MEMORY UNLESS THERE IS A FULL	:
;	COMPLEMENT OF 64K BYTES ON THE PLANAR.				:
; INPUT								:
;	NO REGISTERS							:
;	THE MEMORY_SIZE VARIABLE IS SET DURING POWER ON DIAGNOSTICS	:
;	ACCORDING TO THE FOLLOWING HARDWARE ASSUMPTIONS:		:
;	PORT 60 BITS 3,2 = 00 - 16K BASE RAM				:
;			   01 - 32K BASE RAM				:
;			   10 - 48K BASE RAM				:
;			   11 - 64K BASE RAM				:
;	PORT 62 BITS 3-0 INDICATE AMOUNT OF I/O RAM IN 32K INCREMENTS	:
;		E.G. 0000 - NO RAM IN I/O CHANNEL			:
;		     0010 - 64K RAM IN I/O CHANNEL, ETC			:
; OUTPUT								:
;	(AX) = NUMBER OF CONTIGUOUS 1K BLOCKS OF MEMORY			:
;------------------------------------------------------------------------

MEMORY_SIZE_DET:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; SAVE SEGMENT
	CALL	DDS
	MOV	AX,[MEMORY_SIZE]		; GET VALUE
	POP	DS			; RECOVER SEGMENT
	IRET				; RETURN TO CALLER
	
;----- INT 19 ------------------------------------------------
; BOOT STRAP LOADER
;	TRACK 0, SECTOR 1 IS READ INTO THE
;	BOOT LOCATION (SEGMENT 0, OFFSET 7C00)
;	AND CONTROL IS TRANSFERRED THERE.
;
;	IF THERE IS A HARDWARE ERROR CONTROL IS
;	TRANSFERRED TO THE ROM BASIC ENTRY POINT.
;-------------------------------------------------------------

BOOT_STRAP:
	STI			;ENABLE INTERRUPTS
	SUB	AX,AX		;ESTABLISH ADDRESSING
	MOV	DS,AX

;----- RESET THE DISK PARAMETER TABLE VECTOR

	MOV	WORD PTR [DISK_POINTER], DISK_BASE
	MOV	WORD PTR [DISK_POINTER+2],CS

;----- LOAD SYSTEM FROM DISKETTE -- CX HAS RETRY COUNT

	MOV	CX,4		;SET RETRY COUNT
H1:				;IPL_SYSTEM
	PUSH	CX		;SAVE RETRY COUNT
	MOV	AH,0		;RESET THE DISKETTE SYSTEM
	INT	13H		;DISKETTE_IO
	JC	H2		;IF ERROR, TRY AGAIN
	MOV	AX,0201H	;READ IN THE SINGLE SECTOR
	SUB	DX,DX		; TO THE BOOT LOCATION
	MOV	ES,DX
	MOV	BX, BOOT_LOCN
				;DRIVE 0, HEAD 0
	MOV	CX,1		;SECTOR 1, TRACK 0
	INT	13H		;DISKETTE_IO
H2:
	POP	CX		;RECOVER RETRY COUNT
	JNC	H4		;CF SET BY UNSUCCESSFUL READ
	LOOP	H1		;DO IT FOR RETRY TIMES

;----- UNABLE TO IPL FROM THE DISKETTE

	HLT
	INT	18H		;GO TO RESIDENT BASIC

;----- IPL WAS SUCCESSFUL

H4:
	;GO ON WITH BOOT RECORD JUST READ IN
	JMPF 0000H:7C00H

	
;--- INT 10 -------------------------------------------------------------
; VIDEO_IO 								:
;	THESE ROUTINES PROVIDE THE CRT INTERFACE 			:
;	THE FOLLOWING FUNCTIONS ARE PROVIDED: 				:
;	(AH)=0	SET MODE. AL CONTAINS MODE VALUE 			:
;		(AL)=0 40X25 BW (POWER ON DEFAULT) 			:
;		(AL)=1 40X25 COLOR		 			:
;		(AL)=2 80X25 BW 					:
;		(AL)=3 80X25 COLOR		 			:
;		GRAPHICS MODES 						:
;		(AL)=4 320X200 COLOR		 			:
;		(AL)=5 320X200 BW		 			:
;		(AL)=6 640X200 BW		 			:
;		CRT MODE=7 80X25 B&W CARD (USED INTERNAL TO VIDEO ONLY)	:
;		*** NOTE: BW MODES OPERATE SAME AS COLOR MODES, BUT	:
;			COLOR BURST IS NOT ENABLED.			:
;	(AH)=1	SET CURSOR TYPE 					:
;		(CH) =  BITS 4-0 = START LINE FOR CURSOR		:
;			** HARDWARE WILL ALWAYS CAUSE BLINKING		:
;			** SETTING BIT 5 OR 6 WILL CAUSE ERRATIC	:
;			   BLINKING OR NO CURSOR AT ALL.		:
;		(CL) =	BITS 4-0 = END LINE FOR CURSOR.			:
;	(AH)=2	SET CURSOR POSITION					:
;		(DH,DL) = ROW,COLUMN; (0,0) IS UPPER LEFT.		:
;		(BH) = PAGE NUMBER (MUST BE 0 FOR GRAPHICS MODES)	:
;	(AH)=3	READ CURSOR POSITION					:
;		(BH) = PAGE NUMBER (MUST BE 0 FOR GRAPHICS MODES)	:
;		ON EXIT (DH,DL) = ROW,COLUMN OF CURRENT CURSOR		:
;			(CH,CL) = CURSOR MODE CURRENTLY SET		:
;	(AH)=4	READ LIGHT PEN POSITION					:
;		ON EXIT:						:
;		(AH) = 0 -- LIGHT PEN SWITCH NOT DOWN/NOT TRIGGERED	:
;		(AH) = 1 -- VALID LIGHT PEN VALUE IN REGISTERS		:
;			(DH,DL) = ROW,COLUMN OF CHARACTER LP POSN	:
;			(CH) = RASTER LINE (0-199)			:
;			(BX) = PIXEL COLUMN (0-319,639)			:
;	(AH)=5	SELECT ACTIVE DISPLAY PAGE (VALID ONLY FOR ALPHA MODES)	:
;		(AL)=NEW PAGE VAL (0-7 FOR MODES 0&1, 0-3 FOR MODES 2&3):
;	(AH)=6	SCROLL ACTIVE PAGE UP					:
;		(AL) = NUMBER OF LINES, INPUT LINES BLANKED AT BOTTOM	:
;		       OF WINDOW.					:
;			AL = 0 MEANS BLANK ENTIRE WINDOW.		:
;		(CH,CL) = ROW,COLUMN OF UPPER LEFT CORNER OF SCROLL	:
;		(DH,DL) = ROW,COLUMN OF LOWER RIGHT CORNER OF SCROLL	:
;		(BH) = ATTRIBUTE TO BE USED ON BLANK LINE		:
;	(AH)=7	SCROLL ACTIVE PAGE DOWN 				:
;		(AL) = NUMBER OF LINES, INPUT LINES BLANKED AT TOP	:
;		       OF WINDOW.	 				:
;			AL = 0 MEANS BLANK ENTIRE WINDOW.		:
;		(CH,CL) = ROW,COLUMN OF UPPER LEFT CORNER OF SCROLL	:
;		(DH,DL) = ROW,COLUMN OF LOWER RIGHT CORNER OF SCROLL	:
;		(BH) = ATTRIBUTE TO BE USED ON BLANK LINE		:
; 									:
;  CHARACTER HANDLING ROUTINES					:
;	(AH)=8	READ ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION	:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		ON EXIT:						:
;		(AL) = CHAR READ					:
;		(AH) = ATTRIBUTE OF CHARACTER READ (ALPHA MODES ONLY)	:
;	(AH)=9	WRITE ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION	:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		(CX) = COUNT OF CHARACTERS TO WRITE			:
;		(AL) = CHAR TO WRITE					:
;		(BL) = ATTRIBUTE OF CHARACTER (ALPHA)/COLOR OF CHAR	:
;			(GRAPHICS)					:
;			SEE NOTE ON WRITE DOT FOR BIT 7 OF BL = 1.	:
;	(AH)=10	WRITE CHARACTER ONLY AT CURRENT CURSOR POSITION		:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		(CX) = COUNT OF CHARACTERS TO WRITE			:
;		(AL) = CHAR TO WRITE					:
;	FOR READ/WRITE CHARACTER INTERFACE WHILE IN GRAPHICS MODE, THE	:
;		CHARACTERS ARE FORMED FROM A CHARACTER GENERATOR IMAGE	:
;		MAINTAINED IN THE SYSTEM ROM.  ONLY THE 1ST 128 CHARS	:
;		ARE CONTAINED THERE.  TO READ/WRITE THE SECOND 128	:
;		CHARS, THE USER MUST INITIALIZE THE POINTER AT		:
;		INTERRUPT 1FH (LOCATION 0007CH) TO POINT TO THE 1K BYTE	:
;		TABLE CONTAINING THE CODE POINTS FOR THE SECOND		:
;		128 CHARS (128-255).					:
;	FOR WRITE CHARACTER INTERFACE IN GRAPHICS MODE, THE REPLICATION	:
;		FACTOR CONTAINED IN (CX) ON ENTRY WILL PROVIDE VALID	:
;		RESULTS ONLY FOR CHARACTERS CONTAINED ON THE SAME ROW.	:
;		CONTINUATION TO SUCCEEDING LINES WILLL NOT PRODUCE	:
;		CORRECTLY.						:
; 									:
;  GRAPHICS INTERFACE 						:
;	(AH)=11	SET COLOR PALETTE 					:
;		(BH) = PALETTE COLOR ID BEING SET (0-127)		:
;		(BL) = COLOR VALUE TO BE USED WITH THAT COLOR ID	:
;		   NOTE: FOR THE CURRENT COLOR CARD, THIS ENTRY POINT	:
;			HAS MEANING ONLY FOR 320X200 GRAPHICS.		:
;		      COLOR ID = 0 SELECTS THE BACKGROUND COLOR (0-15)	:
;		      COLOR ID = 1 SELECTS THE PALETTE TO BE USED:	:
;				0 = GREEN(1)/RED(2)/YELLOW(3)		:
;				1 = CYAN(1)/MAGENTA(2)/WHITE(3)		:
;		      IN 40X25 OR 80X25 ALPHA MODES, THE VALUE SET	:
;				FOR PALETTE COLOR 0 INDICATES THE	:
;				BORDER COLOR TO BE USED (VALUES 0-31),	:
;				WHERE 16-31 SELECT THE HIGH INTENSITY	:
;				BACKGROUND SET.				:
;	(AH)=12	WRITE DOT						:
;		(DX) = ROW NUMBER					:
;		(CX) = COLUMN NUMBER					:
;		(AL) = COLOR VALUE					:
;			IF BIT 7 OF AL = 1, THEN THE COLOR VALUE IS	:
;			EXCLUSIVE OR'D WITH THE CURRENT CONTENTS OF	:
;			THE DOT.					:
;	(AH)=13	READ DOT						:
;		(DX) = ROW NUMBER					:
;		(CX) = COLUMN NUMBER					:
;		(AL) = RETURNS THE DOT READ				:
; 									:
;  ASCII TELETYPE ROUTINE FOR OUTPUT					:
;	(AH)=14	WRITE TELETYPE TO ACTIVE PAGE				:
;		(AL) = CHAR TO WRITE					:
;		(BL) = FOREGROUND COLOR IN GRAPHICS MODE                :
;		NOTE -- SCREEN WIDTH IS CONTROLLED BY PREVIOUS MODE SET	:
;									:
;	(AH)=15	CURRENT VIDEO STATE					:
;		RETURNS THE CURRENT VIDEO STATE				:
;		(AL) = MODE CURRENTLY SET ( SEE AH=0 FOR EXPLANATION)	:
;		(AH) = NUMBER OF CHARACTER COLUMNS ON SCREEN		:
;		(BH) = CURRENT ACTIVE DISPLAY PAGE			:
;									:
;	CS,SS,DS,ES,BX,CX,DX PRESERVED DURING CALL			:
;	ALL OTHERS DESTROYED.						:
;------------------------------------------------------------------------

M1:		;TABLE OF ROUTINES WITHIN VIDEO I/O
	DW	SET_MODE
	DW	VIDEO_RETURN ;	SET_CTYPE
	DW	SET_CPOS
	DW	READ_CURSOR
	DW	VIDEO_RETURN ;	READ_LPEN
	DW	VIDEO_RETURN ;	ACT_DISP_PAGE
	DW	SCROLL_UP
	DW	VIDEO_RETURN ;	SCROLL_DOWN
	DW	READ_AC_CURRENT
	DW	VIDEO_RETURN ;	WRITE_AC_CURRENT
	DW	WRITE_C_CURRENT
	DW	VIDEO_RETURN ;	SET_COLOR
	DW	VIDEO_RETURN ;	WRITE_DOT
	DW	VIDEO_RETURN ;	READ_DOT
	DW	WRITE_TTY
	DW	VIDEO_RETURN ;	VIDEO_STATE
M1L	EQU	$-M1

VIDEO_IO:
	STI			;INTERRUPTS BACK ON
	CLD			;SET DIRECTION FORWARD
	PUSH	ES
	PUSH	DS		;SAVE SEGMENT REGISTERS
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	SI
	PUSH	DI
	PUSH	AX		;SAVE AX VALUE
	MOV	AL,AH		;GET INTO LOW BYTE
	XOR	AH,AH		;ZERO TO HIGH BYTE
	SAL	AX,1		;*2 FOR TABLE LOOKUP
	MOV	SI,AX		;PUT INTO SI FOR BRANCH
	CMP	AX,M1L		;TEST FOR WITHIN RANGE
	JB	M2		;BRANCH AROUND BRANCH
	POP	AX		;THROW AWAY THE PARAMETER
	JMP	VIDEO_RETURN	;DO NOTHING IF NOT IN RANGE
M2:
	CALL	DDS
	MOV	AX,0B800H	;SEGMENT FOR COLOR CARD
	MOV	DI,[EQUIP_FLAG]	;GET EQUIPMENT SETTING
	AND	DI,30H		;ISOLATE CRT SWITCHES
	CMP	DI,30H		;IS SETTING FOR BW CARD?
	JNE	M3
	MOV	AH,0B0H		;SEGMENT FOR BW CARD
M3:
	MOV	ES,AX		;SET UP TO POINT AT VIDEO RAM AREAS
	POP	AX		;RECOVER VALUE
	MOV	AH,[CRT_MODE]	;GET CURRENT MODE INTO AH
	JMP	WORD PTR CS:[SI+ M1]
	
;--------------------------------------------------
; SET_MODE
;	THIS ROUTINE INITIALIZES THE ATTACHMENT TO
;	THE SELECTED MODE. THE SCREEN IS BLANKED.
; INPUT
;	(AL) = MODE SELECTED (RANGE 0-9)
; OUTPUT
;	NONE
;--------------------------------------------------

;------ TABLES FOR USE IN SETTING OF MODE

VIDEO_PARMS:
	
;------ INIT_TABLE

	DB	38H,28H,2DH,0AH,1FH,6,19H	;SET UP FOR 40X25
	DB	1CH,2,7,6,7
	DB	0,0,0,0
M4	EQU	$-VIDEO_PARMS
	DB	71H,50H,5AH,0AH,1FH,6,19H	;SET UP FOR 80X25
	DB	1CH,2,7,6,7
	DB	0,0,0,0
	DB	38H,28H,2DH,0AH,7FH,6,64H	;SET UP FOR GRAPHICS
	DB	70H,2,1,6,7
	DB	0,0,0,0
	DB	61H,50H,52H,0FH,19H,6,19H	;SET UP FOR 80X25 BW CARD
	DB	19H,2,0DH,0BH,0CH
	DB	0,0,0,0
M5:		;TABLE OF REGEN LENGTH
	DW	2048		;40X25
	DW	4096		;80X25
	DW	16384		;GRAPHICS
	DW	16384

;------ COLUMNS

M6:
	DB	40,40,80,80,40,40,80,80

;------ C_REG_TAB

M7:		;TABLE OF MODE SETS
	DB	2CH,28H,2DH,29H,2AH,2EH,1EH,29H

SET_MODE:
	MOV	DX,03D4H	;ADDRESS OF COLOR CARD
	MOV	BL,0		;MODE SET FOR COLOR CARD
	CMP	DI,30H		;IS BW CARD INSTALLED
	JNE	M8		;OK WITH COLOR
	MOV	AL,7		;INDICATE BW CARD MODE
	MOV	DL,0B4H		;ADDRESS OF BW CARD (384)
	INC	BL		;MODE SET FOR BW CARD
M8:
	MOV	AH,AL		;SAVE MODE IN AH
	MOV	[CRT_MODE],AL	;SAVE IN GLOBAL VARIABLE
	MOV	[ADDR_6845],DX	;SAVE ADDRESS OF BASE
	PUSH	DS		;SAVE POINTER TO DATA SEGMENT
	PUSH	AX		;SAVE MODE
	PUSH	DX		;SAVE OUTPUT FOR VALUE
	ADD	DX,4		;POINT TO CONTROL REGISTER
	MOV	AL,BL		;GET MODE SET FOR CARD
	OUT	DX,AL		;RESET VIDEO
	POP	DX		;BACK TO BASE REGISTER
	SUB	AX,AX		;SET UP FOR ABS0 SEGMENT
	MOV	DS,AX		;ESTABLISH VECTOR TABLE ADDRESSING
	LDS	BX,[PARM_PTR]	;GET POINTER TO VIDEO PARMS
	POP	AX		;RECOVER PARMS
	MOV	CX,M4		;LENGTH OF EACH ROW OF TABLE
	CMP	AH,2		;DETERMINE WHICH ONE TO USE
	JC	M9		;MODE IS 0 OR 1
	ADD	BX,CX		;MOVE TO NEXT ROW OF INIT TABLE
	CMP	AH,4
	JC	M9		;MODE IS 2 OR 3
	ADD	BX,CX		;MOVE TO GRAPHICS ROW OF INIT TABLE
	CMP	AH,7
	JC	M9		;MODE IS 4,5, OR 6
	ADD	BX,CX		;MOVE TO BW CARD OF INIT TABLE

;------ BX POINTS TO CORRECT ROW OF INITIALIZATION TABLE

M9:
	PUSH	AX		;SAVE MODE IN AH
	XOR	AH,AH		;AH WILL SERVE AS REGISTER
				;NUMBER DURING LOOP

;------ LOOP THROUGH TABLE, OUTPUTTING REG ADDRESS, THEN VALUE FROM TABLE

M10:				;INIT LOOP
	MOV	AL,AH		;GET 6845 REGISTER NUMBER
	OUT	DX,AL
	INC	DX		;POINT TO DATA PORT
	INC	AH		;NEXT REGISTER VALUE
	MOV	AL,[BX]		;GET TABLE VALUE
	OUT	DX,AL		;OUT TO CHIP
	INC	BX		;NEXT IN TABLE
	DEC	DX		;BACK TO POINTER REGISTER
	LOOP	M10		;DO THE WHOLE TABLE
	POP	AX		;GET MODE BACK
	POP	DS		;RECOVER SEGMENT VALUE

;------ FILL REGEN AREA WITH BLANK

	XOR	DI,DI		;SET UP POINTER FOR REGEN
	MOV	WORD PTR [CRT_START],DI	; START ADDRESS SAVED IN GLOBAL
	MOV	BYTE PTR [ACTIVE_PAGE],0	; SET PAGE VALUE
	MOV	CX,8192		; NUMBER OF WORDS IN COLOR CARD
	CMP	AH,4		; TEST FOR GRAPHICS
	JC	M12		; NO_GRAPHICS_INIT
	CMP	AH,7		; TEST FOR BW CARD
	JE	M11		; BW_CARD_INIT
	XOR	AX,AX		; FILL FOR GRAPHICS MODE
	JMP	M13	; CLEAR_BUFFER
M11:				; BW_CARD_INIT
	MOV	CH,08H		; BUFFER SIZE ON BW CARD
M12:				; NO_GRAPHICS_INIT
	MOV	AX,' '+7*256	; FILL CHAR FOR ALPHA
M13:				; CLEAR_BUFFER
	REP	STOSW		; FILL THE REGEN BUFFER WITH BLANKS

;----- ENABLE VIDEO AND CORRECT PORT SETTING

	MOV	WORD PTR [CURSOR_MODE],607H ; SET CURRENT CURSOR MODE
	MOV	AL,[CRT_MODE]	; GET THE MODE
	XOR	AH,AH		; INTO AX REGISTER
	MOV	SI,AX		; TABLE POINTER, INDEXED BY MODE
	MOV	DX,[ADDR_6845]	; PREPARE TO OUTPUT TO
				; VIDEO ENABLE PORT
	ADD	DX,4
	MOV	AL,CS:[SI+ M7]
	OUT	DX,AL		; SET VIDEO ENABLE PORT
	MOV	[CRT_MODE_SET],AL	; SAVE THAT VALUE

;----- DETERMINE NUMBER OF COLUMNS, BOTH FOR ENTIRE DISPLAY

;----- AND THE NUMBER TO BE USED FOR TTY INTERFACE

	MOV	AL,CS:[SI+ M6]
	XOR	AH,AH
	MOV	[CRT_COLS],AX	; NUMBER OF COLUMNS IN THIS SCREEN

;----- SET CURSOR POSITIONS

	AND	SI,0EH		; WORD OFFSET INTO CLEAR LENGTH TABLE
	MOV	CX,CS:[SI+ M5] ; LENGTH TO CLEAR
	MOV	[CRT_LEN],CX	; SAVE LENGTH OF CRT -- NOT USED FOR BW
	MOV	CX,8		; CLEAR ALL CURSOR POSITIONS
	MOV	DI, CURSOR_POSN
	PUSH	DS		; ESTABLISH SEGMENT
	POP	ES		;   ADDRESSING
	XOR	AX,AX
	REP	STOSW		; FILL WITH ZEROES

;----- SET UP OVERSCAN REGISTER

	INC	DX		; SET OVERSCAN PORT TO A DEFAULT
	MOV	AL,30H		; VALUE OF 30H FOR ALL MODES
				;  EXCEPT 640X200
	CMP	BYTE PTR [CRT_MODE],6	; SEE IF THE MODE IS 640X200 BW
	JNZ	M14		; IF IT ISNT 640X200, THEN GOTO REGULAR
	MOV	AL,3FH		; IF IT IS 640X200, THEN PUT IN 3FH
M14:
	OUT	DX,AL		; OUTPUT THE CORRECT VALUE TO 3D9 PORT
	MOV	[CRT_PALETTE],AL	; SAVE THE VALUE FOR FUTURE USE

;----- NORMAL RETURN FROM ALL VIDEO RETURNS

VIDEO_RETURN:
	POP	DI
	POP	SI
	POP	BX
M15:				; VIDEO_RETURN_C
	POP	CX
	POP	DX
	POP	DS
	POP	ES		; REVOVER SEGMENTS
	IRET			; ALL DONE
	
;----- THIS ROUTINE OUTPUTS THE CX REGISTER TO THE 6845 REGS NAMED IN AH

M16:
	MOV	DX,[ADDR_6845]		; ADDRESS REGISTER
	MOV	AL,AH			; GET VALUE
	OUT	DX,AL			; REGISER SET
	INC	DX			; DATA REGISTER
	MOV	AL,CH			; DATA
	OUT	DX,AL
	DEC	DX
	MOV	AL,AH
	INC	AL			; POINT TO OTHER DATA REGISTER
	OUT	DX,AL			; SET FOR SECOND REGISTER
	INC	DX
	MOV	AL,CL			; SECOND DATA VALUE
	OUT	DX,AL
	RET	
	
;------------------------------------------------
; SET_CPOS					:
;	THIS ROUTINE SETS THE CURRENT CURSOR	:
;	POSITION TO THE NEW X-Y VALUES PASSED	:
; INPUT					:
;	DX - ROW, COLUMN OF NEW CURSOR		:
;	BH - DISPLAY PAGE OF CURSOR		:
; OUTPUT					:
;	CURSOR IS SET AT 6845 IF DISPLAY PAGE	:
;	IS CURRENT DISPLAY			:
;------------------------------------------------
SET_CPOS:
	MOV	CL,BH
	XOR	CH,CH			; ESTABLISH LOOP COUNT
	SAL	CX,1			; WORD OFFSET
	MOV	SI,CX			; USE INDEX REGISTER
	MOV	[SI+CURSOR_POSN-DATA_BASE],DX ; SAVE THE POINTER
	CMP	[ACTIVE_PAGE],BH
	JNZ	M17			; SET _CPOS_RETURN
	MOV	AX,DX			; GET ROW/COLUMN TO AX
	CALL	M18			; CURSOR_SET
M17:					; SET_CPOS_RETURN
	JMP	VIDEO_RETURN

;----- SET CURSOR POSITION, AX HAS ROW/COLUMN FOR CURSOR

M18:
	CALL	POSITION		;DETERMINE LOCATION IN REGEN BUFFER
	MOV	CX,AX
	ADD	CX,[CRT_START]		; ADD THE START ADDR FOR THIS PAGE
	SAR	CX,1			; DIVIDE BY 2 FOR CHAR ONLY COUNT
	MOV	AH,14			; REGISTER NUMBER FOR CURSOR
	CALL	M16			; OUTPUT THE VALUE TO THE 6845
	RET
	
;----------------------------------------------------------------
; READ_CURSOR							:
;	THIS ROUTINE READS THE CURRENT CURSOR VALUE FROM THE	:
;	6845, FORMATS IT, AND SENDS IT BACK TO THE CALLER	:
; INPUT								:
;	BH - PAGE OF CURSOR					:
; OUTPUT							:
;	DX - ROW, COLUMN OF THE CURRENT CURSOR POSITION		:
;	CX - CURRENT CURSOR MODE				:
;----------------------------------------------------------------
READ_CURSOR:
	MOV	BL,BH
	XOR	BH,BH
	SAL	BX,1			; WORD OFFSET
	MOV	DX,[BX+CURSOR_POSN-DATA_BASE]
	MOV	CX,[CURSOR_MODE]
	POP	DI
	POP	SI
	POP	BX
	POP	AX			; DISCARD SAVED CX AND DX
	POP	AX
	POP	DS
	POP	ES
	IRET
	
;--------------------------------------------------------
; READ_AC_CURRENT						:
;	THIS ROUTINE TH ATTRIBUTE AND CHARACTER		:
;	AT THE CURRENT CURSOR POSITION AND RETURNS THEM	:
;	TO THE CALLER					:
; INPUT							:
;	(AH) = CURRENT CRT MODE				:
;	(BH) = DISPLAY PAGE ( ALPHA MODES ONLY )	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN SEGMENT				:
; OUTPUT						:
;	(AL) = CHAR READ				:
;	(AH) = ATTRIBUTE READ				:
;--------------------------------------------------------

READ_AC_CURRENT:
	CMP	AH,4			; IS THIS GRAPHICS ?
	JC	P1
	CMP	AH,7			; IS THIS BW CARD ?
	JE	P1
	JMP	GRAPHICS_READ
P1:					; READ_AC_CONTINUE
	CALL	FIND_POSITION
	MOV	SI,BX			; ESTABLISH ADDRESSING IN SI

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,[ADDR_6845]		; GET BASE ADDRESS
	ADD	DX,6			; POINT AT STATUS PORT
	PUSH	ES
	POP	DS			; GET SEGMENT FOR QUICK ACCESS
P2:					; WAIT FOR RETRACE LOW
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS HORZ RETRACE LOW ?
	JNZ	P2			; WAIT UNTIL IT IS
	CLI				; NO MORE INTERRUPTS
P3:					; WAIT FOR RETRACE HIGH
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT HIGH ?
	JZ	P3			; WAIT UNTIL IT IS
	LODSW				; GET THE CHAR/ATTR
	JMP	VIDEO_RETURN
	
;------------------------------------------------
; WRITE_C_CURRENT				:
;	THIS ROUTINE WRITES THE CHARACTER AT	:
;	THE CURRENT CURSOR POSITION, ATTRIBUTE	:
;	UNCHANGED				:
; INPUT						:
;	(AH) = CURRENT CRT MODE			:
;	(BH) = DISPLAY PAGE			:
;	(CX) = COUNT OF CHARACTERS TO WRITE	:
;	(AL) = CHAR TO WRITE			:
;	(DS) = DATA SEGMENT			:
;	(ES) = REGEN SEGMENT			:
; OUTPUT					:
;	NONE					:
;------------------------------------------------
WRITE_C_CURRENT:
	CMP	AH,4			; IS THIS GRAPHICS ?
	JC	P10
	CMP	AH,7			; IS THIS BW CARD ?
	JE	P10
	JMP	GRAPHICS_WRITE
P10:
	PUSH	AX			; SAVE ON STACK
	PUSH	CX			; SAVE WRITE COUNT
	CALL	FIND_POSITION
	MOV	DI,BX			; ADDRESS TO DI
	POP	CX			; WRITE COUNT
	POP	BX			; BL HAS CHAR TO WRITE
P11:					; WRITE_LOOP

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,[ADDR_6845]		; GET BASE ADDRESS
	ADD	DX,6			; POINT AT STATUS PORT
P12:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS HORZ RETRACE LOW ?
	JNZ	P12			; WAIT UNTIL IT IS
	CLI				; NO MORE INTERRUPTS
P13:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT HIGH ?
	JZ	P13			; WAIT UNTIL IT IS
	MOV	AL,BL			; RECOVER CHAR
	STOSB				; PUT THE CHAR/ATTR
	STI				; INTERRUPTS BACK ON
	INC	DI			; BUMP POINTER PAST ATTRIBUTE
	LOOP	P11			;  AS MANY TIMES AS REQUESTED
	JMP	VIDEO_RETURN
	
; TODO - graphics
GRAPHICS_WRITE:
GRAPHICS_READ:
GRAPHICS_UP:
	HLT
	
;--------------------------------------------------------
; POSITION						:
;	THIS SERVICE ROUTINE CALCULATES THE REGEN	:
;	BUFFER ADDRESS OF A CHARACTER IN THE ALPHA MODE	:
; INPUT							:
;	AX = ROW, COLUMN POSITION			:
; OUTPUT						:
;	AX = OFFSET OF CHAR POSITION IN REGEN BUFFER	:
;--------------------------------------------------------
POSITION:
	PUSH	BX			; SAVE REGISTER
	MOV	BX,AX
	MOV	AL,AH			; ROWS TO AL
	MUL	BYTE PTR [CRT_COLS]	; DETERMINE BYTES TO ROW
	XOR	BH,BH
	ADD	AX,BX			; ADD IN COLUMN VALUE
	SAL	AX,1			; *2 FOR ATTRIBUTE BYTES
	POP	BX
	RET
	
FIND_POSITION:
	MOV	CL,BH			; DISPLAY PAGE TO CX
	XOR	CH,CH
	MOV	SI,CX			; MOVE TO SI FOR INDEX
	SAL	SI,1			; * 2 FOR WORD OFFSET
	MOV	AX,[SI+CURSOR_POSN-DATA_BASE]
					; GET ROW/COLUMN OF THAT PAGE
	XOR	BX,BX			; SET START ADDRESS TO ZERO
	JCXZ	P5			; NO_PAGE
P4:					; PAGE_LOOP
	ADD	BX,[CRT_LEN]		; LENGTH OF BUFFER
	LOOP	P4
P5:					; NO_PAGE
	CALL	POSITION		; DETERMINE LOCATION IN REGEN
	ADD	BX,AX			; ADD TO START OF REGEN
	RET
	
;--------------------------------------------------------
; SCROLL_UP						:
;	THIS ROUTINE MOVES A BLOCK OF CHARACTERS UP	:
;	ON THE SCREEN					:
; INPUT							:
;	(AH) = CURRENT CRT MODE				:
;	(AL) = NUMBER OF ROWS TO SCROLL			:
;	(CX) = ROW/COLUMN OF UPPER LEFT CORNER		:
;	(DX) = ROW/COLUMN OF LOWER RIGHT CORNER		:
;	(BH) = ATTRIBUTE TO BE USED ON BLANKED LINE	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN BUFFER SEGMENT			:
; OUTPUT						:
;	NONE -- THE REGEN BUFFER IS MODIFIED		:
;--------------------------------------------------------
	
SCROLL_UP:
	MOV	BL,AL			; SAVE LINE COUNT IN BL
	CMP	AH,4			; TEST FOR GRAPHICS MODE
	JC	N1			; HANDLE SEPARATELY
	CMP	AH,7			; TEST FOR BW CARD
	JE	N1
	JMP	GRAPHICS_UP
N1:					; UP_CONTINUE
	PUSH	BX			; SAVE FILL ATTRIBUTE IN BH
	MOV	AX,CX			; UPPER LEFT POSITION
	CALL	SCROLL_POSITION		; DO SETUP FOR SCROLL
	JZ	N7			; BLANK_FIELD
	ADD	SI,AX			; FROM ADDRESS
	MOV	AH,DH			; # ROWS IN BLOCK
	SUB	AH,BL			; # ROWS TO BE MOVED
N2:					; ROW_LOOP
	CALL	N10			; MOVE ONE ROW
	ADD	SI,BP
	ADD	DI,BP			; POINT TO NEXT LINE IN BLOCK
	DEC	AH			; COUNT OF LINES TO MOVE
	JNZ	N2			; ROW_LOOP
N3:					; CLEAR_ENTRY
	POP	AX			; RECOVER ATTRIBUTE IN AH
	MOV	AL,' '			; FILL WITH BLANKS
N4:					; CLEAR_LOOP
	CALL	N11			; CLEAR THE ROW
	ADD	DI,BP			; POINT TO NEXT LINE
	DEC	BL			; COUNTER OF LINES TO SCROLL
	JNZ	N4			; CLEAR_LOOP
N5:					; SCROLL_END
	CALL	DDS
	CMP	BYTE PTR [CRT_MODE],7		; IS THIS THE BLACK AND WHITE CARD ?
	JE	N6			; IF SO, SKIP THE MODE RESET
	MOV	AL,[CRT_MODE_SET]		; GET THE VALUE OF THE MODE SET
	MOV	DX,03D8H		; ALWAYS SET COLOR CARD PORT
	OUT	DX,AL
N6:					; VIDEO_RET_HERE
	JMP	VIDEO_RETURN
N7:					; BLANK_FIELD
	MOV	BL,DH			; GET ROW COUNT
	JMP	N3			; GO CLEAR THAT AREA


;---- HANDLE COMMON SCROLL SET UP HERE

SCROLL_POSITION:
	CMP	BYTE PTR [CRT_MODE],2		; TEST FOR SPECIAL CASE HERE
	JB	N9			; HAVE TO HANDLE 80X25 SEPARATELY
	CMP	BYTE PTR [CRT_MODE],3
	JA	N9

;----- 80X25 COLOR CARD SCROLL

	PUSH	DX
	MOV	DX,3DAH			; GUARANTEED TO BE COLOR CARD HERE
	PUSH	AX
N8:					; WAIT_DISP_ENABLE
	IN	AL,DX			; GET PORT
	TEST	AL,8			; WAIT FOR VERTICAL RETRACE
	JZ	N8			; WAIT_DISP_ENABLE
	MOV	AL,25H
	MOV	DL,0D8H			; DX=3D8
	OUT	DX,AL			; TURN OFF VIDEO
	POP	AX			; DURING VERTICAL RETRACE
	POP	DX
N9:
	CALL	POSITION		; CONVERT TO REGEN POINTER
	ADD	AX,[CRT_START]		; OFFSET OF ACTIVE PAGE
	MOV	DI,AX			; TO ADDRESS FOR SCROLL
	MOV	SI,AX			; FROM ADDRESS FOR SCROLL
	SUB	DX,CX			; DX = # ROWS, # COLS IN BLOCK
	INC	DH
	INC	DL			; INCREMENT FOR 0 ORIGIN
	XOR	CH,CH			; SET HIGH BYTE OF COUNT TO ZERO
	MOV	BP,[CRT_COLS]		; GET NUMBER OF COLUMNS IN DISPLAY
	ADD	BP,BP			; TIMES 2 FOR ATTRIBUTE BYTE
	MOV	AL,BL			; GET LINE COUNT
	MUL	BYTE PTR [CRT_COLS]	; DETERMINE OFFSET TO FROM ADDRESS
	ADD	AX,AX			; *2 FOR ATTRIBUTE BYTE
	PUSH	ES			; ESTABLISH ADDRESSING TO REGEN BUFFER
	POP	DS			; FOR BOTH POINTERS
	CMP	BL,0			; 0 SCROLL MEANS BLANK FIELD
	RET				; RETURN WITH FLAGS SET

;----- MOVE_ROW

N10:
	MOV	CL,DL			; GET # OF COLS TO MOVE
	PUSH	SI
	PUSH	DI			; SAVE START ADDRESS
	REP	MOVSW			; MOVE THAT LINE ON SCREEN
	POP	DI
	POP	SI			; RECOVER ADDRESSES
	RET

;----- CLEAR_ROW

N11:
	MOV	CL,DL			; GET # COLUMNS TO CLEAR
	PUSH	DI
	REP	STOSW			; STORE THE FILL CHARACTER
	POP	DI
	RET
	
;------------------------------------------------------------------------
; WRITE_TTY								:
;	THIS INTERFACE PROVIDES A TELETYPE LIKE INTERFACE TO THE VIDEO	:
;	CARD. THE INPUT CHARACTER IS WRITTEN TO THE CURRENT CURSOR	:
;	POSITION, AND THE CURSOR IS MOVED TO THE NEXT POSITION. IF THE	:
;	CURSOR LEAVES THE LAST COLUMN OF THE FIELD, THE COLUMN IS SET	:
;	TO ZERO, AND THE ROW VALUE IS INCREMENTED. IF THE ROW VALUE	:
;	LEAVES THE FIELD, THE CURSOR IS PLACED ON THE LAST ROW, FIRST	:
;	COLUMN, AND THE ENTIRE SCREEN IS SCROLLED UP ONE LINE. WHEN	:
;	THE SCREEN IS SCROLLED UP, THE ATTRIBUTE FOR FILLING THE NEWLY	:
;	BLANKED LINE IS READ FROM THE CURSOR POSITION ON THE PREVIOUS	:
;	LINE BEFORE THE SCROLL, IN CHARACTER MODE. IN GRAPHICS MODE,	:
;	THE 0 COLOR IS USED.						:
; ENTRY									:
;	(AH) = CURRENT CRT MODE						:
;	(AL) = CHARACTER TO BE WRITTEN					:
;	NOTE THAT BACK SPACE, CAR RET, BELL AND LINE FEED ARE HANDLED	:
;	AS COMMANDS RATHER THAN AS DISPLAYABLE GRAPHICS			:
;	(BL) = FOREGROUND COLOR FOR CHAR WRITE IF CURRENTLY IN A	:
;	GRAPHICS MODE
; EXIT									:
;	ALL REGISTERS SAVED						:
;------------------------------------------------------------------------

WRITE_TTY:
	PUSH	AX			; SAVE REGISTERS
	PUSH	AX			; SAVE CHAR TO WRITE
	MOV	AH,3
	MOV	BH,[ACTIVE_PAGE]		; GET THE CURRENT ACTIVE PAGE
	INT	10H			; READ THE CURRENT CURSOR POSITION
	POP	AX			; RECOVER CHAR

;----- DX NOW HAS THE CURRENT CURSOR POSITION

	CMP	AL,8			; IS IT A BACKSPACE ?
	JE	U8			;  BACK_SPACE
	CMP	AL,0DH			; IS IT A CARRIAGE RETURN ?
	JE	U9			; CAR_RET
	CMP	AL,0AH			; IS IT A LINE FEED ?
	JE	U10			; LINE_FEED
	CMP	AL,07H			; IS IT A BELL ?
	JE	U11			; BELL

;----- WRITE THE CHAR TO THE SCREEN

	MOV	AH,10			; WRITE CHAR ONLY
	MOV	CX,1			; ONLY ONE CHAR
	INT	10H			; WRITE THE CHAR

;----- POSITION THE CURSOR FOR THE NEXT CHAR

	INC	DL
	CMP	DL,BYTE PTR [CRT_COLS]	; TEST FOR COLUMN OVERFLOW
	JNZ	U7			; SET_CURSOR
	MOV	DL,0			; COLUMN FOR CURSOR
	CMP	DH,24
	JNZ	U6			; SET_CURSOR_INC

;----- SCROLL REQUIRED

U1:
	MOV	AH,2
	INT	10H			; SET THE CURSOR

;----- DETERMINE VALUE TO FILL WITH DURING SCROLL

	MOV	AL,[CRT_MODE]		; GET THE CURRENT MODE
	CMP	AL,4
	JC	U2			; READ_CURSOR
	CMP	AL,7
	MOV	BH,0			; FILL WITH BACKGROUND
	JNE	U3			; SCROLL_UP
U2:					; READ_CURSOR
	MOV	AH,8
	INT	10H			; READ CHAR/ATTR AT CURRENT CURSOR
	MOV	BH,AH			; STORE IN BH
U3:					; SCROLL_UP
	MOV	AX,601H			; SCROLL ONE LINE
	SUB	CX,CX			; UPPER LEFT CORNER
	MOV	DH,24			; LOWER RIGHT ROW
	MOV	DL,BYTE PTR [CRT_COLS]	;LOWER RIGHT COLUMN
	DEC	DL
U4:					; VIDEO_CALL_RETURN
	INT	10H			; SCROLL UP THE SCREEN
U5:					; TTY_RETURN
	POP	AX			; RESTORE THE CHARACTER
	JMP	VIDEO_RETURN		; RETURN TO CALLER
U6:					; SET_CURSOR_INC
	INC	DH			; NEXT ROW
U7:					; SET_CURSOR
	MOV	AH,2
	JMP	U4			; ESTABLISH THE NEW CURSOR

;----- BACK SPACE FOUND

U8:
	CMP	DL,0			; ALREADY AT END OF LINE ?
	JE	U7			; SET_CURSOR
	DEC	DL			; NO -- JUST MOVE IT BACK
	JMP	U7			; SET_CURSOR

;----- CARRIAGE RETURN FOUND

U9:
	MOV	DL,0			; MOVE TO FIRST COLUMN
	JMP	U7			; SET_CURSOR

;----- LINE FEED FOUND

U10:
	CMP	DH,24			; BOTTOM OF SCREEN  ?
	JNE	U6			; NO, JUST SET THE CURSOR
	JMP	U1			; YES, SCROLL THE SCREEN

;------ BELL FOUND

U11:
	MOV	BL,2			; SET UP COUNT FOR BEEP
	CALL	BEEP			; SOUND THE POD BELL
	JMP	U5			; TTY_RETURN
	
;-- INT 13 --------------------------------------------------
; DISKETTE I/O
;	THIS INTERFACE PROVIDES ACCESS TO THE 5 1/4 DISKETTE DRIVES
; INPUT
;	(AH)=0  RESET DISKETTE SYSTEM
;		HARD RESET TO NEC, PREPARE COMMAND, RECAL REQUIRED
;		ON ALL DRIVES
;	(AH)=1  READ THE STATUS OF THE SYSTEM INTO (AL)
;		DISKETTE STATUS FROM LAST OPERATION IS USED
;
; REGISTERS FOR READ/WRITE/VERIFY/FORMAT
;	(DL) - DRIVE NUMBER (0-3 ALLOWED, VALUE CHECKED)
;	(DH) - HEAD NUMBER (0-1 ALLOWED, NOT VALUE CHECKED)
;	(CH) - TRACK NUMBER (0-39, NOT VALUE CHECKED)
;	(CL) - SECTOR NUMBER (1-8, NOT VALUE CHECKED,
;				NOT USED FOR FORMAT)
;	(AL) - NUMBER OF SECTORS (MAX=8, NOT VALUE CHECKED,
;				NOT USED FOR FORMAT)
;	(ES:BX) - ADDRESS OF BUFFER (NOT REQUIRED FOR VERIFY)
;
;	(AH)=2  READ THE DESIRED SECTORS INTO MEMORY
;	(AH)=3  WRITE THE DESIRED SECTORS FROM MEMORY
;	(AH)=4	VERIFY THE DESIRED SECTORS
;	(AH)=5	FORMAT THE DESIRED TRACK
;		FOR THE FORMAT OPERATION, THE BUFFER POINTER (ES,BX)
;		MUST POINT TO THE COLLECTION OF DESIRED ADDRESS FIELDS
;		FOR THE TRACK. EACH FIELD IS COMPOSED OF 4 BYTES,
;		(C,H,R,N), WHERE C=TRACK NUMBER, H=HEAD NUMBER,
;		R=SECTOR NUMBER, N=NUMBER OF BYTES PER SECTOR
;		(00=128, 01=256, 03=1024). THERE MUST BE ONE
;		ENTRY FOR EVERY SECTOR ON THE TRACK. THIS INFORMATION
;		IS USED TO FIND THE REQUESTED SECTOR DURING READ/WRITE
;		ACCESS.
;
; DATA VARIABLE -- DISK_POINTER
;	DOUBLE WORD POINTER TO THE CURRENT SET OF DISKETTE PARAMETERS
; OUTPUT
;	AH = STATUS OF OPERATION
;		STATUS BITS ARE DEFINED IN THE EQUATES BELOW.
;	CY =0	SUCCESSFUL OPERATION (AH=0 ON RETURN)
;	CY =1	FAILED OPERATION (AH HAS ERROR REASON)
;	FOR READ/WRITE/VERIFY
;		DS,BX,DX,CH,CL PRESERVED
;		AL = NUMBER OF SECTORS ACTUALLY READ
;		***** AL MAY NOT BE CORRECT IF TIME OUT ERROR OCCURS
;	NOTE:	IF AN ERROR IS REPORTED BY THE DISKETTE CODE, THE
;		APPROPRIATE ACTION IS TO RESET THE DISKETTE, THEN RETRY
;		THE OPERATION. ON READ ACCESSS, NO MOTOR START DELAY
;		IS TAKEN, SO THAT THREE RETRIES ARE REQUIRED ON READS
;		TO ENSURE THAT THE PROBLEM IS NOT DUE TO MOTOR
;		START-UP.
;
;	DISKETTE STATUS BITS:
;
;	TIME_OUT	EQU	80H ;ATTACHMENT FAILED TO RESPOND
;	BAD_SEEK	EQU	40H ;SEEK OPERATION FAILED
;	BAD_NEC		EQU	20H ;NEC CONTROLLER HAS FAILED
;	BAD_CRC		EQU	10H ;BAD CRC ON DISKETTE READ
;	DMA_BOUNDARY	EQU	09H ;ATTEMPT TO DMA ACROSS 64K BOUNDARY
;	BAD_DMA     	EQU	08H ;DMA OVERRUN ON OPERATION
;	RECORD_NOT_FND 	EQU	04H ;REQUESTED SECTOR NOT FOUND
;	WRITE_PROTECT  	EQU	03H ;WRITE ATTEMPTED ON WRITE PROT DISK
;	BAD_ADDR_MARK  	EQU	02H ;ADDRESS MARK NOT FOUND
;	BAD_CMD        	EQU	01H ;BAD COMMAND PASSED TO DISKETTE I/O
;------------------------------------------------------------

BAD_CMD			EQU		01H
BAD_ADDR_MARK   EQU		02H
WRITE_PROTECT   EQU     03H
RECORD_NOT_FND  EQU		04H
BAD_DMA			EQU		08H
DMA_BOUNDARY	EQU		09H
BAD_CRC			EQU		10H
BAD_NEC 		EQU 	20H
BAD_SEEK		EQU		40H
TIME_OUT		EQU		80H	

INT_FLAG		EQU		80H
INT_FLAG_NOT	EQU		7FH
	
DISKETTE_IO:
	STI			;INTERRUPTS BACK ON
	PUSH	BX		;SAVE ADDRESS
	PUSH	CX
	PUSH	DS		;SAVE SEGMENT REGISTER VALUE
	PUSH	SI		;SAVE ALL REGISTERS DURING OPERATION
	PUSH	DI
	PUSH	BP
	PUSH	DX
	MOV	BP,SP		;SET UP POINTER TO HEAD PARM
	CALL	DDS
	CALL	J1		;CALL THE REST TO ENSURE DS RESTORED
	MOV	BX,4		;GET THE MOTOR WAIT PARAMETER
	CALL	GET_PARM
	MOV	[MOTOR_COUNT],AH	;SET THE TIMER COUNT FOR THE MOTOR
	MOV	AH,[DISKETTE_STATUS] ;GET STATUS OF OPERATION
	CMP	AH,1		;SET THE CARRY FLAG TO INDICATE
	CMC			; SUCCESS OR FAILURE
	POP	DX		;RESTORE ALL REGISTERS
	POP	BP
	POP	DI
	POP	SI
	POP	DS
	POP	CX
	POP	BX		;RECOVER ADDRESS
	RETF 2		; IGNORE PUSHED FLAGS
	
J1:
	MOV	DH,AL		;SAVE # SECTORS IN DH
	AND	BYTE PTR [MOTOR_STATUS],07FH ;INDICATE A READ OPERATION
	OR	AH,AH		;AH=0
	JZ	DISK_RESET
	DEC	AH		;AH=1
	JZ	DISK_STATUS
	MOV	BYTE PTR [DISKETTE_STATUS],0 ;RESET THE STATUS INDICATOR
	CMP	DL,4		;TEST FOR DRIVE IN 0-3 RANGE
	JAE	J3		;ERROR IF ABOVE
	DEC	AH		;AH=2
	JZ	DISK_READ
	DEC	AH		;AH=3
	JNZ	J2		;TEST_DISK_VERF
	JMP	DISK_WRITE
J2:				;TEST_DISK_VERF
	DEC	AH		;AH=4
	JZ	DISK_VERF
	DEC	AH		;AH=5
	JZ	DISK_FORMAT
J3:				;BAD_COMMAND
	MOV	BYTE PTR [DISKETTE_STATUS],BAD_CMD ;ERROR CODE, NO SECTORS TRANSFERRED
	RET			;UNDEFINED OPERATION
	
;-------------- RESET THE DISKETTE SYSTEM

DISK_RESET:
	MOV	DX,03F2H	;ADAPTER CONTROL PORT
	CLI			;NO INTERRUPTS
	MOV	AL,[MOTOR_STATUS]	;WHICH MOTOR IS ON
	MOV	CL,4		;SHIFT COUNT
	SAL	AL,CL		;MOVE MOTOR VALUE TO HIGH NYBBLE
	TEST	AL,20H		;SELECT CORRESPONDING DRIVE
	JNZ	J5		;JUMP IF MOTOR ONE IS ON
	TEST	AL,40H
	JNZ	J4		;JUMP IF MOTOR TWO IS ON
	TEST	AL,80H
	JZ	J6		;JUMP IF MOTOR ZERO IS ON
	INC	AL
J4:
	INC	AL
J5:
	INC	AL
J6:
	OR	AL,8		;TURN ON INTERRUPT ENABLE
	OUT	DX,AL		;RESET THE ADAPTER
	MOV	BYTE PTR [SEEK_STATUS],0	;SET RECAL REQUIRED ON ALL DRIVES
	MOV	BYTE PTR [DISKETTE_STATUS],0 ;SET OK STATUS FOR DISKETTE
	OR	AL,4		;TURN OFF RESET
	OUT	DX,AL		;TURN OFF THE RESET
	STI			;REENABLE THE INTERRUPTS
	CALL	CHK_STAT_2	;DO SENSE INTERRUPT STATUS
				; FOLLOWING RESET
	MOV	AL,[NEC_STATUS]	;IGNORE ERROR RETURN AND DO OWN TEST
	CMP	AL,0C0H		;TEST FOR DRIVE READY TRANSITION
	JZ	J7		;EVERYTHING OK
	OR	BYTE PTR [DISKETTE_STATUS],BAD_NEC ;SET ERROR CODE
	RET

;-------------- SEND SPECIFY COMMAND TO NEC

J7:				;DRIVE_READY
	MOV	AH,03H		;SPECIFY COMMAND
	CALL	NEC_OUTPUT	;OUTPUT THE COMMAND
	MOV	BX,1		;FIRST BYTE PARM IN BLOCK
	CALL	GET_PARM	; TO THE NEC CONTROLLER
	MOV	BX,3		;SECOND BYTE PARM IN BLOCK
	CALL	GET_PARM	; TO THE NEC CONTROLLER
				;RESET_RET
	RET			;RETURN TO CALLER

;-------------- DISKETTE STATUS ROUTINE

DISK_STATUS:
	MOV	AL,[DISKETTE_STATUS]
	RET

;-------------- DISKETTE READ

DISK_READ:
	MOV	AL,046H		;READ COMMAND FOR DMA
J9:				;DISK_READ_CONT
	CALL	DMA_SETUP	;SET UP THE DMA
	MOV	AH,0E6H		;SET UP RD COMMAND FOR NEC CONTROLLER
	JMP	RW_OPN	;GO TO THE OPERATION

;-------------- DISKETTE VERIFY

DISK_VERF:
	; TODO - disk verify
	RET

;-------------- DISKETTE FORMAT

DISK_FORMAT:
	OR	BYTE PTR [MOTOR_STATUS],80H ;INDICATE WRITE OPERATION
	MOV	AL,04AH		;WILL WRITE TO THE DISKETTE
	CALL	DMA_SETUP	;SET UP THE DMA
	MOV	AH,04DH		;ESTABLISH THE FORMAT COMMAND
	JMP	RW_OPN	;DO THE OPERATION
J10:				;CONTINUATION OF RW_OPN FOR FMT
	MOV	BX,7		;GET THE
	CALL	GET_PARM	; BYTES/SECTOR VALUE TO NEC
	MOV	BX,9		;GET THE
	CALL	GET_PARM	; SECTORS/TRACK VALUE TO NEC
	MOV	BX,15		;GET THE
	CALL	GET_PARM	; GAP LENGTH VALUE TO NEC
	MOV	BX,17		;GET THE FILLER BYTE
	JMP	J16		; TO THE CONTROLLER


;-------------- DISKETTE WRITE ROUTINE

DISK_WRITE:
	OR	BYTE PTR [MOTOR_STATUS],80H ;INDICATE WRITE OPERATION
	MOV	AL,04AH		;DMA WRITE COMMAND
	CALL	DMA_SETUP
	MOV	AH,0C5H		;NEC COMMAND TO WRITE TO DISKETTE
	
;-------------- ALLOW WRITE ROUTINE TO FALL INTO RW_OPN

;------------------------------------------------------
; RW_OPN
;	THIS ROUTINE PERFORMS THE READ/WRITE/VERIFY OPERATION
;------------------------------------------------------------
RW_OPN:
	JNC	J11		;TEST FOR DMA ERROR
	MOV	BYTE PTR [DISKETTE_STATUS],DMA_BOUNDARY ;SET ERROR
	MOV	AL,0		;NO SECTORS TRANSFERRED
	RET			;RETURN TO MAIN ROUTINE
J11:				;DO_RW_OPN
	PUSH	AX		;SAVE THE COMMAND

;-------------- TURN ON THE MOTOR AND SELECT DRIVE

	PUSH	CX		;SAVE THE T/S PARMS
	MOV	CL,DL		;GET DRIVE NUMBER AS SHIFT COUNT
	MOV	AL,1		;MASK FOR DETERMINING MOTOR BIT
	SAL	AL,CL		;SHIFT THE MASK BIT
	CLI			;NO INTERRUPTS WHILE DETERMINING
				; MOTOR STATUS
	MOV	BYTE PTR [MOTOR_COUNT],0FFH ;SET LARGE COUNT DURING OPERATION
	TEST AL, BYTE PTR [MOTOR_STATUS]	;TEST THAT MOTOR FOR OPERATION
	JNZ	J14		;IF RUNNING, SKIP THE WAIT
	AND	BYTE PTR [MOTOR_STATUS],0F0H ;TURN OFF ALL MOTOR BITS
	OR	BYTE PTR [MOTOR_STATUS],AL	;TURN ON THE CURRENT MOTOR
	STI			;INTERRUPTS BACK ON
	MOV	AL,10H		;MASK BIT
	SAL	AL,CL		;DEVELOP BIT MASK FOR MOTOR ENABLE
	OR	AL,DL		;GET DRIVE SELECT BITS IN
	OR	AL,0CH		;NO RESET, ENABLE DMA/INT
	PUSH	DX		;SAVE REG
	MOV	DX,03F2H	;CONTROLL PORT ADDRESS
	OUT	DX,AL
	POP	DX		;RECOVER REGISTERS

;-------------- WAIT FOR MOTOR IF WRITE OPERATION

	TEST	BYTE PTR [MOTOR_STATUS],80H ;IS THIS A WRITE
	JZ	J14		;NO, CONTINUE WITHOUT WAIT
	MOV	BX,20		;GET THE MOTOR WAIT
	CALL	GET_PARM	; PARAMETER
	OR	AH,AH		;TEST FOR NO WAIT
J12:				;TEST_WAIT_TIME
	JZ	J14		;EXIT WITH TIME EXPIRED
	SUB	CX,CX		;SET UP 1/8 SECOND LOOP TIME
J13:
	LOOP	J13		;WAIT FOR THE REQUIRED TIME
	DEC	AH		;DECREMENT TIME VALUE
	JMP	J12		;ARE WE DONE YET
J14:				;MOTOR RUNNING
	STI			;INTERRUPTS BACK ON FOR BYPASS WAIT
	POP	CX

;-------------- DO THE SEEK OPERATION

	CALL	SEEK		;MOVE TO CORRECT TRACK
	POP	AX		;RECOVER COMMAND
	MOV	BH,AH		;SAVE COMMAND IN BH
	MOV	DH,0		;SET NO SECTORS READ IN CASE OF ERROR
	JC	J17		;IF ERROR, THEN EXIT AFTER MOTOR OFF
	MOV	SI, J17	;DUMMY RETURN ON STACK FOR NEC_OUTPUT
	NOP		;********************************************
	PUSH	SI		; SO THAT IT WILL RETURN TO MOTOR OFF
				; LOCATION

;-------------- SEND OUT THE PARAMETERS TO THE CONTROLLER

	CALL	NEC_OUTPUT	;OUTPUT THE OPERATION COMMAND
	MOV	AH,[BP+1]	;GET THE CURRENT HEAD NUMBER
	SAL	AH,1		;MOVE IT TO BIT 2
	SAL	AH,1
	AND	AH,4		;ISOLATE THAT BIT
	OR	AH,DL		;OR IN THE DRIVE NUMBER
	CALL	NEC_OUTPUT

;-------------- TEST FOR FORMAT COMMAND

	CMP	BH,04DH		;IS THIS A FORMAT OPERATION
	JNE	J15		;NO, CONTINUE WITH R/W/V
	JMP	J10		;IF SO, HANDLE SPECIAL
J15:
	MOV	AH,CH		;CYLINDER NUMBER
	CALL	NEC_OUTPUT
	MOV	AH,[BP+1]	;HEAD NUMBER FROM STACK
	CALL	NEC_OUTPUT
	MOV	AH,CL		;SECTOR NUMBER
	CALL	NEC_OUTPUT
	MOV	BX,7		;BYTES/SECTOR PARM FROM BLOCK
	CALL	GET_PARM	; TO THE NEC
	MOV	BX,9		;EOT PARM FROM BLOCK
	CALL	GET_PARM	; TO THE NEC
	MOV	BX,11		;GAP LENGTH PARM FROM BLOCK
	CALL GET_PARM		; TO THE NEC
	MOV	BX,13		;DTL PARM FROM BLOCK
J16:				;RW_OPN_FINISH
	CALL	GET_PARM	; TO THE NEC
	POP	SI		;CAN NOW DISCARD THAT DUMMY
				; RETURN ADDRESS

;-------------- LET THE OPERATION HAPPEN

	CALL	WAIT_INT	;WAIT FOR THE INTERRUPT
J17:				;MOTOR_OFF
	JC	J21		;LOOK FOR ERROR
	CALL	RESULTS		;GET THE NEC STATUS
	JC	J20		;LOOK FOR ERROR

;-------------- CHECK THE RESULTS RETURNED BY THE CONTROLLER
	
	CLD			;SET THE CORRECT DIRECTION
	MOV	SI, NEC_STATUS ;POINT TO STATUS FIELD
	LODSB	;GET ST0
	AND	AL,0C0H		;TEST FOR NORMAL TERMINATION
	JZ	J22		;OPN_OK
	CMP	AL,040H		;TEST FOR ABNORMAL TERMINATION
	JNZ	J18		;NOT ABNORMAL, BAD NEC

;-------------- ABNORMAL TERMINATION, FIND OUT WHY

	LODSB	;GET ST1
	SAL	AL,1		;TEST FOR EOT FOUND
	MOV	AH,RECORD_NOT_FND
	JC	J19		;RW_FAIL
	SAL	AL,1
	SAL	AL,1		;TEST FOR CRC ERROR
	MOV	AH,BAD_CRC
	JC	J19		;RW_FAIL
	SAL	AL,1		;TEST FOR DMA OVERRUN
	MOV	AH,BAD_DMA
	JC	J19		;RW_FAIL
	SAL	AL,1
	SAL	AL,1		;TEST FOR RECORD NOT FOUND
	MOV	AH,RECORD_NOT_FND
	JC	J19		;RW_FAIL
	SAL	AL,1
	MOV	AH,WRITE_PROTECT ;TEST FOR WRITE_PROTECT
	JC	J19		;RW_FAIL
	SAL	AL,1		;TEST MISSING ADDRESS MARK
	MOV	AH,BAD_ADDR_MARK
	JC	J19		;RW_FAIL

;-------------- NEC MUST HAVE FAILED
J18:				;RW_NEC_FAIL
	MOV	AH,BAD_NEC
J19:				;RW_FAIL
	OR	BYTE PTR [DISKETTE_STATUS],AH
	CALL	NUM_TRANS	;HOW MANY WERE REALLY TRANSFERRED
J20:				;RW_ERR
	RET			;RETURN TO CALLER
J21:				;RW_ERR_RES
	CALL	RESULTS		;FLUSH THE RESULTS BUFFER
	RET

;-------------- OPERATION WAS SUCCESSFUL

J22:				;OPN_OK
	CALL	NUM_TRANS	;HOW MANY GOT MOVED
	XOR	AH,AH		;NO ERRORS
	RET
	
;---------------------------------------------------------------------
; NEC_OUTPUT
;	THIS ROUTINE SENDS A BYTE TO THE NEC CONTROLLER AFTER TESTING
;	FOR CORRECT DIRECTION AND CONTROLLER READY THIS ROUTINE WILL
;	TIME OUT IF THE BYTE IS NOT ACCEPTED WITHIN A REASONABLE
;	AMOUNT OF TIME, SETTING THE DISKETTE STATUS ON COMPLETION.
; INPUT
;	(AH)	BYTE TO BE OUTPUT
; OUTPUT
;	CY =0	SUCCESS
;	CY =1	FAILURE -- DISKETTE STATUS UPDATED
;		IF A FAILURE HAS OCCURED, THE RETURN IS MADE ONE LEVEL
;		HIGHER THAN THE CALLER OF NEC_OUTPUT.
;		THIS REMOVES THE REQUIREMENT OF TESTING AFTER EVERY
;		CALL OF NEC_OUTPUT.
;	(AL) DESTROYED
;---------------------------------------------------------------------
NEC_OUTPUT:
	PUSH	DX		;SAVE REGISTERS
	PUSH	CX
	MOV	DX,03F4H	;STATUS PORT
	XOR	CX,CX		;COUNT FOR TIME OUT
J23:
	IN	AL,DX		;GET STATUS
	TEST	AL,040H		;TEST DIRECTION BIT
	JZ	J25		;DIRECTION OK
	LOOP	J23
J24:				;TIME_ERROR
	OR	BYTE PTR [DISKETTE_STATUS],TIME_OUT
	POP	CX
	POP	DX		;SET ERROR CODE AND RESTORE REGS
	POP	AX		;DISCARD THE RETURN ADDRESS
	STC			;INDICATE ERROR TO CALLER
	RET
J25:
	XOR	CX,CX		;RESET THE COUNT
J26:
	IN	AL,DX		;GET THE STATUS
	TEST	AL,080H		;IS IT READY
	JNZ	J27		;YES, GO OUTPUT
	LOOP	J26		;COUNT DOWN AND TRY AGAIN
	JMP	J24		;ERROR CONDITION
J27:				;OUTPUT
	MOV	AL,AH		;GET BYTE TO OUTPUT
	MOV	DL,0F5H		;DATA PORT (3F5)
	OUT	DX,AL		;OUTPUT THE BYTE
	POP	CX		;RECOVER REGISTERS
	POP	DX
	RET			;CY =0 FROM TEST INSTRUCTION
	
;------------------------------------------------------------
; GET_PARM
;	THIS ROUTINE FETCHES THE INDEXED POINTER FROM THE DISK_BASE
;	BLOCK POINTED AT BY THE DATA VARIABLE DISK_POINTER. A BYTE FROM
;	THAT TABLE IS THEN MOVED INTO AH, THE INDEX OF THAT BYTE BEING
;	THE PARM IN BX.
; ENTRY
;	BX = INDEX OF BYTE TO BE FETCHED * 2
;		IF THE LOW BIT OB BX IS ON, THE BYTE IS IMMEDIATELY
;		OUTPUT TO THE NEC CONTROLLER
; EXIT
;	AH = THAT BYTE FROM BLOCK
;------------------------------------------------------------
GET_PARM:
	PUSH	ES		;SAVE SEGMENT
	LES	SI,[DISK_POINTER]	;POINT TO BLOCK
	SHR	BX,1		;DIVIDE BX BY 2, AND SET FLAG
				; FOR EXIT
	MOV	AH,ES:[SI+BX]	;GET THE WORD
	POP	ES		;RESTORE SEGMENT
	JC	NEC_OUTPUT	;IF FLAG SET, OUTPUT TO CONTROLLER
	RET			;RETURN TO CALLER
	
;-----------------------------------------------------------------
; SEEK
;	THIS ROUTINE WILL MOVE THE HEAD ON THE NAMED DRIVE TO THE
;	NAMED TRACK. IF THE DRIVE HAS NOT BEEN ACCESSED SINCE THE
;	DRIVE RESET COMMAND WAS ISSUED, THE DRIVE WILL BE RECALIBRATED.
; INPUT
;	(DL) = DRIVE TO SEEK ON
;	(CH) = TRACK TO SEEK ON
; OUTPUT
;	CY = 0 SUCCESS
;	CY = 1 FAILURE -- DISKETTE_STATUS SET ACCORDINGLY
;	(AX) DESTROYED
;-----------------------------------------------------------------
SEEK:
	MOV	AL,1		;ESTABLISH MASK FOR RECAL TEST
	PUSH	CX		;SAVE INPUT VALUES
	MOV	CL,DL		;GET DRIVE VALUE INTO CL
	ROL	AL,CL		;SHIFT IT BY THE DRIVE VALUE
	POP	CX		;RECOVER TRACK VALUE
	TEST	AL,[SEEK_STATUS]	;TEST FOR RECAL REQUIRED
	JNZ	J28		;NO_RECAL
	OR	[SEEK_STATUS],AL	;TURN ON THE NO RECAL BIT IN FLAG
	MOV	AH,07H		;RECALIBRATE COMMAND
	CALL	NEC_OUTPUT
	MOV	AH,DL
	CALL	NEC_OUTPUT	;OUTPUT THE DRIVE NUMBER
	CALL	CHK_STAT_2	;GET THE INTERRUPT AND SENSE INT STATUS
	JC	J32		;SEEK_ERROR

;-------------- DRIVE IS IN SYNCH WITH CONTROLLER, SEEK TO TRACK

J28:
	MOV	AH,0FH		;SEEK COMMAND TO NEC
	CALL	NEC_OUTPUT
	MOV	AH,DL		;DRIVE NUMBER
	CALL	NEC_OUTPUT
	MOV	AH,CH		;TRACK NUMBER
	CALL	NEC_OUTPUT
	CALL	CHK_STAT_2	;GET ENDING INTERRUPT AND
				; SENSE STATUS

;-------------- WAIT FOR HEAD SETTLE

	PUSHF			;SAVE STATUS FLAGS
	MOV	BX,18		;GET HEAD SETTLE PARAMETER
	CALL	GET_PARM
	PUSH	CX		;SAVE REGISTER
J29:				;HEAD SETTLE
	MOV	CX,550		;1 MS LOOP
	OR	AH,AH		;TEST FOR TIME EXPIRED
	JZ	J31
J30:
	LOOP	J30		;DELAY FOR 1 MS
	DEC	AH		;DECREMENT THE COUNT
	JMP	J29		;DO IT SOME MORE
J31:
	POP	CX		;RECOVER STATE
	POPF
J32:				;SEEK_ERROR
	RET			;RETURN TO CALLER
	
;-------------------------------------------------------------
; DMA_SETUP
;	THIS ROUTINE SETS UP THE DMA FOR READ/WRITE/VERIFY OPERATIONS.
; INPUT
;	(AL) = MODE BYTE FOR THE DMA
;	(ES:BX) - ADDRESS TO READ/WRITE THE DATA
; OUTPUT
;	(AX) DESTROYED
;-------------------------------------------------------------
DMA_SETUP:
	PUSH	CX		;SAVE THE REGISTER
	CLI			;NO MORE INTERRUPTS
	OUT	DMA+12,AL	;SET THE FIRST/LAST F/F
	PUSH	AX
	POP	AX
	OUT	DMA+11,AL	;OUTPUT THE MODE BYTE
	MOV	AX,ES		;GET THE ES VALUE
	MOV	CL,4		;SHIFT COUNT
	ROL	AX,CL		;ROTATE LEFT
	MOV	CH,AL		;GET HIGHEST NYBBLE OF ES TO CH
	AND	AL,0F0H		;ZERO THE LOW NYBBLE FROM SEGMENT
	ADD	AX,BX		;TEST FOR CARRY FROM ADDITION
	JNC	J33
	INC	CH		;CARRY MEANS HIGH 4 BITS MUST BE INC
J33:
	PUSH	AX		;SAVE START ADDRESS
	OUT	DMA+4,AL	;OUTPUT LOW ADDRESS
	MOV	AL,AH
	OUT	DMA+4,AL	;OUTPUT HIGH ADDRESS
	MOV	AL,CH		;GET HIGH 4 BITS
	AND	AL,0FH
	OUT	081H,AL		;OUTPUT THE HIGH 4 BITS TO
				; THE PAGE REGISTER

;-------------- DETERMINE COUNT

	MOV	AH,DH		;NUMBER OF SECTORS
	SUB	AL,AL		; TIMES 256 INTO AX
	SHR	AX,1		;SECTORS * 128 INTO AX
	PUSH	AX
	MOV	BX,6		;GET THE BYTES/SECTOR PARM
	CALL	GET_PARM
	MOV	CL,AH		;USE AS SHIFT COUNT (0=128, 1=256 ETC)
	POP	AX
	SHL	AX,CL		;MULTIPLY BY CORRECT AMOUNT
	DEC	AX		;-1 FOR DMA VALUE
	PUSH	AX		;SAVE COUNT VALUE
	OUT	DMA+5,AL	;LOW BYTE OF COUNT
	MOV	AL,AH
	OUT	DMA+5,AL	;HIGH BYTE OF COUNT
	STI			;INTERRUPTS BACK ON
	POP	CX		;RECOVER COUNT VALUE
	POP	AX		;RECOVER ADDRESS VALUE
	ADD	AX,CX		;ADD, TEST FOR 64K OVERFLOW
	POP	CX		;RECOVER REGISTER
	MOV	AL,2		;MODE FOR 8237
	OUT	DMA+10,AL	;INITIALIZE THE DISKETTE CHANNEL
	RET			;RETURN TO CALLER
				; CFL SET BY ABOVE IF ERROR

	
;----------------------------------------------------------------
; CHK_STAT_2
;	THIS ROUTINE HANDLES THE INTERRUPT RECEIVED AFTER A
;	RECALIBRATE, SEEK, OR RESET TO THE ADAPTER.
;	THE INTERRUPT IS WAITED FOR, THE INTERRUPT STATUS SENSED,
;	AND THE RESULT RETURNED TO THE CALLER.
; INPUT
;	NONE
; OUTPUT
;	CY = 0 SUCCESS
;	CY = 1 FAILURE -- ERROR IS IN DISKETTE_STATUS
;	(AX) DESTROYED
;----------------------------------------------------------------
CHK_STAT_2:
	CALL	WAIT_INT	;WAIT FOR THE INTERRUPT
	JC	J34		;IF ERROR, RETURN IT
	MOV	AH,08H		;SENSE INTERRUPT STATUS COMMAND
	CALL	NEC_OUTPUT
	CALL	RESULTS		;READ IN THE RESULTS
	JC	J34		;CHK2_RETURN
	MOV	AL,[NEC_STATUS]	;GET THE FIRST STATUS BYTE
	AND	AL,060H		;ISOLATE THE BITS
	CMP	AL,060H		;TEST FOR CORRECT VALUE
	JZ	J35		;IF ERROR, GO MARK IT
	CLC			;GOOD RETURN
J34:
	RET			;RETURN TO CALLER
J35:				;CHK2_ERROR
	OR	BYTE PTR [DISKETTE_STATUS],BAD_SEEK
	STC			;ERROR RETURN CODE
	RET	
	
;----------------------------------------------------------------
;WAIT_INT
;	THIS ROUTINE WAITS FOR AN INTERRUPT TO OCCUR. A TIME OUT
;	ROUTINE TAKES PLACE DURING THE WAIT, SO THAT AN ERROR MAY BE
;	RETURNED IF THE DRIVE IS NOT READY.
; INPUT
;	NONE
; OUTPUT
;	CY = 0 SUCCESS
;	CY = 1 FAILURE -- DISKETTE_STATUS IS SET ACCORDINGLY
;	(AX) DESTROYED
;----------------------------------------------------------------
WAIT_INT:
	STI			;TURN ON INTERRUPTS, JUST IN CASE
	PUSH	BX
	PUSH	CX		;SAVE REGISTERS
	MOV	BL,2		;CLEAR THE COUNTERS
	XOR	CX,CX		; FOR 2 SECOND WAIT
J36:
	TEST	BYTE PTR [SEEK_STATUS],INT_FLAG ;TEST FOR INTERRUPT OCCURRING
	JNZ	J37
	LOOP	J36		;COUNT DOWN WHILE WAITING
	DEC	BL		;SECOND LEVEL COUNTER
	JNZ	J36
	OR	BYTE PTR [DISKETTE_STATUS],TIME_OUT ;NOTHING HAPPENED
	STC			;ERROR RETURN
J37:
	PUSHF			;SAVE CURRENT CARRY
	AND	BYTE PTR [SEEK_STATUS],INT_FLAG_NOT ;TURN OFF INTERRUPT FLAG
	POPF			;RECOVER CARRY
	POP	CX
	POP	BX		;RECOVER REGISTERS
	RET			;GOOD RETURN CODE COMES
				; FROM TEST INSTRUCTION
				
;---- INT E -------------------------------------------------------
; DISK_INT
;	THIS ROUTINE HANDLES THE DISKETTE INTERRUPT
; INPUT
;	NONE
; OUTPUT
;	THE INTERRUPT FLAG IS SET IN SEEK_STATUS
;------------------------------------------------------------------

DISK_INT:
	STI			;RE ENABLE INTERRUPTS
	PUSH	DS
	PUSH	AX
	CALL	DDS
	OR	BYTE PTR [SEEK_STATUS],INT_FLAG
	MOV	AL,20H		;END OF INTERRUPT MARKER
	OUT	20H,AL		;INTERRUPT CONTROL PORT
	POP	AX
	POP	DS		;RECOVER SYSTEM
	IRET			; RETURN FROM INTERRUPT
				
;--------------------------------------------------------
; RESULTS
;	THIS ROUTINE WILL READ ANYTHING THAT THE NEC CONTROLLER HAS
;	TO SAY FOLLOWING AN INTERRUPT.
; INPUT
;	NONE
; OUTPUT
;	CY = 0 SUCCESSFUL TRANSFER
;	CY = 1 FAILURE -- TIME OUT IN WAITING FOR STATUS
;	NEC_STATUS AREA HAS STATUS BYTE LOADED INTO IT
;	(AH) DESTROYED
;--------------------------------------------------------
RESULTS:
	CLD
	MOV	DI, NEC_STATUS ;POINTER TO DATA AREA
	PUSH	CX		;SAVE COUNTER
	PUSH	DX
	PUSH	BX
	MOV	BL,7		;MAX STATUS BYTES

;-------------- WAIT FOR REQUEST FOR MASTER

J38:				;INPUT_LOOP
	XOR	CX,CX		; COUNTER
	MOV	DX,03F4H	;STATUS PORT
J39:				;WAIT FOR MASTER
	IN	AL,DX		;GET STATUS
	TEST	AL,080H		;MASTER READY
	JNZ	J40A		;TEST_DIR
	LOOP	J39		;WAIT MASTER
	OR	BYTE PTR [DISKETTE_STATUS],TIME_OUT
J40:				;RESULTS_ERROR
	STC			;SET ERROR RETURN
	POP	BX
	POP	DX
	POP	CX
	RET

;-------------- TEST THE DIRECTION BIT

J40A:
	IN	AL,DX		;GET STATUS REG AGAIN
	TEST	AL,040H		;TEST DIRECTION BIT
	JNZ	J42		;OK TO READ STATUS
J41:				;NEC_FAIL
	OR	BYTE PTR [DISKETTE_STATUS],BAD_NEC
	JMP	J40		;RESULTS_ERROR

;-------------- READ IN THE STATUS

J42:				;INPUT_STAT
	INC	DX		;POINT AT DATA PORT
	IN	AL,DX		;GET THE DATA
	MOV	[DI],AL		;STORE THE BYTE
	INC	DI		;INCREMENT THE POINTER
	MOV	CX,10		;LOOP TO KILL TIME FOR NEC
J43:	LOOP	J43
	DEC	DX		;POINT AT STATUS PORT
	IN	AL,DX		;GET STATUS
	TEST	AL,010H		;TEST FOR NEC STILL BUSY
	JZ	J44		;RESULTS DONE
	DEC	BL		;DECREMENT THE STATUS COUNTER
	JNZ	J38		;GO BACK FOR MORE
	JMP	J41		;CHIP HAS FAILED

;-------------- RESULT OPERATION IS DONE

J44:
	POP	BX
	POP	DX
	POP	CX		;RECOVER REGISTERS
	RET			;GOOD RETURN CODE FROM TEST INST
	
;---------------------------------------------------------------
; NUM_TRANS
;	THIS ROUTINE CALCULATES THE NUMBER OF SECTORS THAT
;	WERE ACTUALLY TRANSFERRED TO/FROM THE DISKETTE
; INPUT
;	(CH) = CYLINDER OF OPERATION
;	(CL) = START SECTOR OF OPERATION
; OUTPUT
;	(AL) = NUMBER ACTUALLY TRANSFERRED
;	NO OTHER REGISTERS MODIFIED
;---------------------------------------------------------------
NUM_TRANS:
	MOV	AL,[NEC_STATUS+3]	;GET CYLINDER ENDED UP ON
	CMP	AL,CH		;SAME AS WE STARTED
	MOV	AL,[NEC_STATUS+5]	;GET ENDING SECTOR
	JZ	J45		;IF ON SAME CYL, THEN NO ADJUST
	MOV	BX,8
	CALL	GET_PARM	;GET EOT VALUE
	MOV	AL,AH		; INTO AL
	INC	AL		;USE EOT+1 FOR CALCULATION
J45:
	SUB	AL,CL		;SUBTRACT START FROM END
	RET
	
;----- INT 14 ---------------------------------------------------------
; RS232_IO
;	THIS ROUTINE PROVIDES BYTE STREAM I/O TO THE COMMUNICATIONS
;	PORT ACCORDING TO THE PARAMETERS:
;	(AH)=0	INITIALIZE THE COMMUNICATIONS PORT
;		(AL) HAS PARAMETERS FOR INITIALIZATION
;
;	7	6	5	4	3	2	1	0
;	----- BAUD RATE --	-PARITY--     STOPBIT	--WORD LENGTH--
;	000 - 110		X0 - NONE	0 - 1	 10 - 7 BITS
;	001 - 150		01 - ODD	1 - 2	 11 - 8 BITS
;	010 - 300		11 - EVEN
;	011 - 600
;	100 - 1200
;	101 - 2400
;	110 - 4800
;	111 - 9600
;
;	ON RETURN, CONDITIONS SET AS IN CALL TO COMMO STATUS (AH=3)
;	(AH)=1	SEND THE CHARACTER IN (AL) OVER THE COMMO LINE
;		(AL) REGISTER IS PRESERVED
;		ON EXIT, BIT 7 OF AH IS SET IF THE ROUTINE WAS UNABLE
;			TO TRANSMIT THE BYTE OF DATA OVER THE LINE.
;			IF BIT 7 OF AH IS NOT SET, THE REMAINDER OF AH
;			IS SET AS IN A STATUS REQUEST, REFLECTING THE
;			CURRENT STATUS OF THE LINE.
;	(AH)=2	RECEIVE A CHARACTER IN (AL) FROM COMMO LINE BEFORE
;			RETURNING TO CALLER
;		ON EXIT, AH HAS THE CURRENT LINE STATUS, AS SET BY THE
;			STATUS ROUTINE, EXCEPT THAT THE ONLY BITS
;			LEFT ON ARE THE ERROR BITS (7,4,3,2,1)
;			IF AH HAS BIT 7 ON (TIME OUT) THE REMAINING
;			BITS ARE NOT PREDICTABLE.
;			THUS, AH IS NON ZERO ONLY WHEN AN ERROR
;			OCCURRED.
;	(AH)=3	RETURN THE COMMO PORT STATUS IN (AX)
;		AH CONTAINS THE LINE STATUS
;		BIT 7 = TIME OUT
;		BIT 6 = TRANS SHIFT REGISTER EMPTY
;		BIT 5 = TRAN HOLDING REGISTER EMPTY
;		BIT 4 = BREAK DETECT
;		BIT 3 = FRAMING ERROR
;		BIT 2 = PARITY ERROR
;		BIT 1 = OVERRUN ERROR
;		BIT 0 = DATA READY
;		AL CONTAINES THE MODEM STATUS
;		BIT 7 = RECEIVED LINE SIGNAL DETECT
;		BIT 6 = RING INDICATOR
;		BIT 5 = DATA SET READY
;		BIT 4 = CLEAR TO SEND
;		BIT 3 = DELTA RECEIVE LINE SIGNAL DETECT
;		BIT 2 = TRAILING EDGE RING DETECTOR
;		BIT 1 = DELTA DATA SET READY
;		BIT 0 = DELTA CLEAT TO SEND
;
;	(DX) = PARAMETER INDICATING WHICH RS232 CARD (0,1 ALLOWED)
;
; DATA AREA RS232_BASE CONTAINES THE BASE ADDRESS OF THE 8250 ON THE
;	CARD LOCATION. 400H CONTAINS UP TO 4 RS232 ADDRESSES POSSIBLE.
;	DATA AREA LABEL RS232_TIM_OUT (BYTE) CONTAINS OUTER LOOP COUNT
;	VALUE FOR TIME OUT (DEFAULT=1)
; OUTPUT
;	AX MODIFIED ACCORDING TO PARMS OF CALL
;	ALL OTHERS UNCHANGED
;----------------------------------------------------------------------

A1:		;TABLE OF INIT VALUES
	DW	1047		;110 BAUD
	DW	768		;150
	DW	384		;300
	DW	192		;600
	DW	96		;1200
	DW	48		;2400
	DW	24		;4800
	DW	12		;9600

RS232_IO:

;------ VECTOR FOR APPROPRIATE ROUTINE

	STI			;INTERRUPTS BACK ON
	PUSH	DS		;SAVE SEGMENT
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	BX
	MOV	SI,DX		;RS232 VALUE TO SI
	MOV	DI,DX
	SHL	SI,1		;WORD OFFSET
	CALL	DDS
	MOV	DX,RS232_BASE[SI]		;GET RS232_BASE ADDRESS
	OR	DX,DX		;TEST FOR 0 BASE ADDRESS
	JZ	A3		;RETURN
	OR	AH,AH		;TEST FOR AH=0
	JZ	A4		;COMMUN INIT
	DEC	AH		;TEST FOR AH=1
	JZ	A5		;SEND AL
	DEC	AH		;TEST FOR AH=2
	JZ	A12		;RECEIVE INTO AL
	DEC	AH		;TEST FOR AH=3
	JNZ	A3
	JMP	A18		;COMMUNICATION STATUS
A3:				;RETURN FROM RS232
	POP	BX
	POP	CX
	POP	DI
	POP	SI
	POP	DX
	POP	DS
	IRET			;RETURN TO CALLER, NO ACTION

;------ INITIALIZE THE COMMUNICATIONS PORT

A4:
	MOV	AH,AL		;SAVE INIT PARMS IN AH
	ADD	DX,3		;POINT TO 8250 CONTROL REGISTER
	MOV	AL,80H
	OUT	DX,AL		;SET DLAB=1

;------ DETERMINE BAUD RATE DIVISOR

	MOV	DL,AH		;GET PARMS TO DL
	MOV	CL,4
	ROL	DL,CL
	AND	DX,0EH		;SELECT BAUD RATE BITS
	MOV	DI, A1	;BASE OF TABLE
	ADD	DI,DX		;PUT INTO INDEX REGISTER
	MOV	DX,RS232_BASE[SI]		;POINT TO HIGH ORDER OF DIVISOR
				;RS232_BASE[SI]
	INC	DX
	MOV	AL,CS:[DI]+1	;GET HIGH ORDER OF DIVISOR
	OUT	DX,AL		;SET MS OF DIV TO 0
	DEC	DX
	MOV	AL,CS:[DI]	;GET LOW ORDER OF DIVISOR
	OUT	DX,AL		;SET LOW OF DIVISOR
	ADD	DX,3
	MOV	AL,AH		;GET PARMS BACK
	AND	AL,01FH		;STRIP OFF THE BAUD BITS
	OUT	DX,AL		;LINE CONTROL TO 8 BITS
	DEC	DX
	DEC	DX
	MOV	AL,0
	OUT	DX,AL		;INTERRUPT ENABLES ALL OFF
	JMP	A18	;COM_STATUS

;------ SEND CHARACTER IN AL OVER COMMO LINE

A5:
	PUSH	AX		;SAVE CHAR TO SEND
	ADD	DX,4		;MODEM CONTROL REGISTER
	MOV	AL,3		;DTR AND RTS
	OUT	DX,AL		;DATA TERMINAL READY, REQUEST TO SEND
	INC	DX		;MODEM STATUS REGISTER
	INC	DX
	MOV	BH,30H		;DATA SET READY & CLEAR TO SEND
	CALL	WAIT_FOR_STATUS	;ARE BOTH TRUE
	JE	A9		;YES, READY TO TRANSMIT CHAR
A7:
	POP	CX
	MOV	AL,CL		;RELOAD DATA BYTE
A8:
	OR	AH,80H		;INDICATE TIME OUT
	JMP	A3		;RETURN
A9:				;CLEAR_TO_SEND
	DEC	DX		;LINE STATUS REGISTER
				;WAIT_SEND
	MOV	BH,20H		;IS TRANSMITTER READY
	CALL	WAIT_FOR_STATUS	;TEST FOR TRANSMITTER READY
	JNZ	A7		;RETURN WITH TIME OUT SET
				;OUT_CHAR
	SUB	DX,5		;DATA PORT
	POP	CX		;RECOVER IN CX TEMPORARILY
	MOV	AL,CL		;MOVE CHAR TO AL FOR OUT, STATUS IN AH
	OUT	DX,AL		;OUTPUT CHARACTER
	JMP	A3		;RETURN

;------ RECEIVE CHARACTER FROM COMMO LINE

A12:
	ADD	DX,4		;MODEM CONTROL REGISTER
	MOV	AL,1		;DATA TERMINAL READY
	OUT	DX,AL
	INC	DX		;MODEM STATUS REGISTER
	INC	DX
				;WAIT_DSR
	MOV	BH,20H		;DATA SET READY
	CALL	WAIT_FOR_STATUS	;TEST FOR DSR
	JNZ	A8		;RETURN WITH ERROR
				;WAIT_DSR_END
	DEC	DX		;LINE STATUS REGISTER
				;WAIT_RECV
	MOV	BH,1		;RECEIVE BUFFER FULL
	CALL	WAIT_FOR_STATUS	;TEST FOR REC. BUFF. FULL
	JNZ	A8		;SET TIME OUT ERROR
				;GET_CHAR
	AND	AH,00011110B	;TEST FOR ERR CONDITIONS ON RECV CHAR
	MOV	DX,RS232_BASE[SI]		;DATA PORT, RS232_BASE[SI]
	IN	AL,DX		;GET CHARACTER FROM LINE
	JMP	A3		;RETURN

;------ COMMO PORT STATUS ROUTINE

A18:
	MOV	DX,RS232_BASE[SI]		;RS232_BASE[SI]
	ADD	DX,5		;CONTROL PORT
	IN	AL,DX		;GET LINE CONTROL STATUS
	MOV	AH,AL		;PUT IN AH FOR RETURN
	INC	DX		;POINT TO MODEM STATUS REGISTER
	IN	AL,DX		;GET MODEM CONTROL STATUS
	JMP	A3		;RETURN
;----------------------------------------
; WAIT FOR STATUS ROUTINE
;
; ENTRY:
;	BH=STATUS BIT(S) TO LOOK FOR,
;	DX=ADDR. OF STATUS REG
; EXIT:
;	ZERO FLAG ON = STATUS FOUND
;	ZERO FLAG OFF = TIME OUT.
;	AH=LAST STATUS READ
;-----------------------------------------
WAIT_FOR_STATUS:
	MOV	BL,[DI+7CH]	;LOAD OUTER LOOP COUNT, RS232_TIM_OUT
WFS0:
	SUB	CX,CX
WFS1:
	IN	AL,DX		;GET STATUS
	MOV	AH,AL		;MOVE TO AH
	AND	AL,BH		;ISOLATE BITS TO TEST
	CMP	AL,BH		;EXACTLY = TO MASK
	JE	WFS_END		;RETURN WITH ZERO FLAG ON
	LOOP	WFS1		;TRY AGAIN
	DEC	BL
	JNZ	WFS0

	OR	BH,BH		;SET ZERO FLAG OFF
WFS_END:
	RET
	
	
; Keyboard definitions

INS_STATE 		EQU 80H ; INSERT STATE IS ACTIVE
CAPS_STATE 		EQU 40H ; CAPS LOCK STATE HAS BEEN TOGGLED
NUM_STATE 		EQU 20H ; HUM LOCK STATE HAS BEEN TOGGLED
SCROLL_STATE 	EQU 10H ; SCROll LOCK STATE HAS BEEN TOGGLED
ALT_SHIFT 		EQU 08H ; ALTERNATE SHIfT KEY DEPRESSED
CTL_SHIFT 		EQU 04H ; CONTROL SHIFT KEY DEPRESSED
LEFT_SHIFT 		EQU 02H ; lEFT SHIFT KEY DEPRESSED
RIGHT_SHIFT 	EQU 01H ; RIGHT SHIFT KEY DEPRESSED

INS_SHIFT 		EQU 80H ; INSERT KEY IS DEPRESSED
CAPS_SHIFT 		EQU 40H ; CAPS LOCK KEY IS DEPRESSED
NUM_SHIFT 		EQU 20H ; NUN LOCK KEY IS DEPRESSED
SCROLL_SHIFT 	EQU 10H ; SCROLL LOCK KEY IS DEPRESSEO
HOLD_STATE 		EQU 08H ; SUSPEND KEY HAS BEEN TOGGLED

NUM_KEY 		EQU 69	;SCAN CODE FOR NUMBER LOCK
SCROLL_KEY 		EQU 70 	;SCROLL LOCK KEY
ALT_KEY 		EQU 56	;ALTERNATE SHIFT KEY SCAN COOE
CTL_KEY 		EQU 29	;SCAN CODE FOR CONTROL KEY
CAPS_KEY 		EQU 58 	;SCAN CODE FOR SHIFT LOCK
LEFT_KEY 		EQU 42 	;SCAN CODE FOR LEFT SHIFT
RIGHT_KEY 		EQU 54 	;SCAN COOE FOR RIGHT SHIFT
INS_KEY 		EQU 82 	;SCAN CODE FOR UlSERT KEY
DEL_KEY 		EQU 83 	;SCAN CODE FOR DELETE KEY

KB_DATA			EQU	PORT_A
KB_CTL			EQU PORT_B

	
;---- INT 16 -----------------------------------------------------
; KEYBOARD I/O
;        THESE ROUTINES PROVIDE KEYBOARD SUPPORT
; INPUT
;	(AH)=0	READ THE NEXT ASCII CHARACTER STRUCK FROM THE KEYBOARD
;		RETURN THE RESULT IN (AL), SCAN CODE IN (AH)
;	(AH)=1  SET THE Z FLAG TO INDICATE IF AN ASCII CHARACTER IS
;		AVAILABLE TO READ.
;		(ZF)=1 -- NO CODE AVAILABLE
;		(ZF)=0 -- CODE IS AVAILABLE
;		IF ZF = 0, THE NEXT CHARACTER IN THE BUFFER TO BE READ
;		IS IN AX, AND THE ENTRY REMAINS IN THE BUFFER
;	(AH)=2  RETURN THE CURRENT SHIFT STATUS IN AL REGISTER
;		THE BIT SETTINGS FOR THIS CODE ARE INDICATED IN THE
;		EQUATES FOR KB_FLAG
; OUTPUT
;	AS NOTED ABOVE, ONLY AX AND FLAGS CHANGED
;	ALL REGISTERS PRESERVED
;------------------------------------------------------------------

KEYBOARD_IO:
	STI			;INTERRUPTS BACK ON
	PUSH	DS		;SAVE CURRENT DS
	PUSH	BX		;SAVE BX TEMPORARILY
	CALL	DDS
	OR	AH,AH		;AH=0
	JZ	K1		;ASCII_READ
	DEC	AH		;AH=1
	JZ	K2		;ASCII_STATUS
	DEC	AH		;AH=2
	JZ	K3		;SHIFT_STATUS
	JMP	INT10_END ;EXIT

;----- READ THE KEY TO FIGURE OUT WHAT TO DO

K1:				;ASCII READ
	STI			;INTERRUPTS BACK ON DURING LOOP
	NOP			;ALLOW AN INTERRUPT TO OCCUR
	CLI			;INTERRUPTS BACK OFF
	MOV	BX,[BUFFER_HEAD]	;GET POINTER TO HEAD OF BUFFER
	CMP	BX,[BUFFER_TAIL]	;TEST END OF BUFFER
	JZ	K1		;LOOP UNTIL SOMETHING IN BUFFER
	MOV	AX,[BX]		;GET SCAN CODE AND ASCII CODE
	CALL	K4		;MOVE POINTER TO NEXT POSITION
	MOV	[BUFFER_HEAD],BX	;STORE VALUE IN VARIABLE
	JMP	INT10_END	;RETURN

;----- ASCII STATUS

K2:
	CLI			;INTERRUPTS OFF
	MOV	BX,[BUFFER_HEAD]	;GET HEAD POINTER
	CMP	BX,[BUFFER_TAIL]	;IF EQUAL (Z=1) THEN NOTHING THERE
	MOV	AX,[BX]
	STI			;INTERRUPTS BACK ON
	POP	BX		;RECOVER REGISTER
	POP	DS		;RECOVER SEGMENT
	RETF	2		;THROW AWAY FLAGS

;----- SHIFT STATUS

K3:
	MOV	AL,[KB_FLAG]	;GET THE SHIFT STATUS FLAGS
INT10_END:
	POP	BX		;RECOVER REGISTER
	POP	DS		;RECOVER REGISTER
	IRET			;RETURN TO CALLER


;----- INCREMENT A BUFFER POINTER

K4:	
	INC	BX		; MOVE TO NEXT WORD IN LIST
	INC	BX		;
	CMP	BX,[BUFFER_END]	; AT END OF BUFFER ?
	JNE	K5		; NO, CONTINUE
	MOV	BX,[BUFFER_START] ; YES, RESET TO BUFFER BEGINNING
K5:
	RET
	
;----- TABLE OF SHIFT KEYS AND MASK VALUES

K6:
	DB	INS_KEY		; INSERT KEY
	DB	CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
	DB	LEFT_KEY,RIGHT_KEY
K6L	EQU	$-K6

;----- SHIFT_MASK_TABLE

K7:
	DB	INS_SHIFT	; INSERT MODE SHIFT
	DB	CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
	DB	LEFT_SHIFT,RIGHT_SHIFT

;----- SCAN CODE TABLES

K8:	DB	27,-1,0,-1,-1,-1,30,-1
	DB	-1,-1,-1,31,-1,127,-1,17
	DB	23,5,18,20,25,21,9,15
	DB	16,27,29,10,-1,1,19
	DB	4,6,7,8,10,11,12,-1,-1
	DB	-1,-1,28,26,24,3,22,2
	DB	14,13,-1,-1,-1,-1,-1,-1
	DB	' ',-1

;----- CTL TABLE SCAN

K9:
	DB	94,95,96,97,98,99,100,101
	DB	102,103,-1,-1,119,-1,132,-1
	DB	115,-1,116,-1,117,-1,118,-1
	DB	-1

;----- LC TABLE

K10:
	DB	1BH,'1234567890-=',08H,09H
	DB	'qwertyuiop[]',0dh,-1,'asdfghjkl;',27H,60H
	DB	-1,5CH,'zxcvbnm,./',-1,'*',-1,' '
	DB	-1

;----- UC TABLE

K11:
	DB	27,'!@#$',37,5eh,'&*()_+',08H,0
	DB	'QWERTYUIOP{}',0DH,-1,'ASDFGHJKL:"',7EH
	DB	-1,'|ZXCVBNM<>?',-1,0,-1,' ',-1

;----- UC TABLE SCAN

K12:
	DB	84,85,86,87,88,89,90
	DB	91,92,93

;----- ALT TABLE SCAN

K13:
	DB	104,105,106,107,108
	DB	109,110,111,112,113

;----- NUM STATE TABLE

K14:
	DB	'789-456+1230.'

;----- BASE CASE TABLE

K15:
	DB	71,72,73,-1,75,-1,77
	DB	-1,79,80,81,82,83
	DB	0FFH	;DUMMY ****************
	
;---- INT 9 ------------------------------------------
; KB_INT
;
;   THIS ROUTINE HANDLES THE KEYBOARD INTERRUPT
;-----------------------------------------------------

KB_INT:
        STI                     ; ENABLE INTERRUPTS
KB_BREAK:
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        PUSH    DS
        PUSH    ES
        CLD                    ; FORWARD DIRECTION
		CALL	DDS
        IN     AL,KB_DATA      ; READ IN THE CHARACTER
        PUSH   AX              ; SAVE IT
        IN     AL,KB_CTL       ; GET THE CONTROL PORT
        MOV    AH,AL           ; SAVE VALUE
        OR      AL,80H          ; RESET BIT FOR KEYBOARD
        OUT     KB_CTL,AL       ; 
        XCHG    AH,AL           ; GET BACK ORIGINAL CONTROL
        OUT     KB_CTL,AL       ; KB HAS BEEN RESET
        POP     AX              ; RECOVER SCAN CODE
        MOV     AH,AL           ; SAVE SCAN CODE IN AH ALSO

;----- TEST FOR OVERRUN SCAN CODE FROM KEYBOARD
 
        CMP     AL,0FFH         ; IS THIS AN OVERRUN CHAR
        JNZ     K16             ; NO, TEST FOR SHIFT KEY
        JMP     K62             ; BUFFER_FULL_BEEP

;----- TEST FOR SHIFT KEYS

K16:                            ; TEST_SHIFT
		AND	AL,7FH		; TURN OFF THE BREAK BIT
		PUSH 	CS		; 
		POP	ES		; ESTABLISH ADDRESS OF SHIFT TABLE
		MOV	DI, K6	; SHIFT KEY TABLE
		MOV	CX,K6L		; LENGTH
		REPNE	SCASB		; LOOK THROUGH THE TABLE FOR A MATCH
		MOV	AL,AH		; RECOVER SCAN CODE
		JE	K17		; JUMP IF MATCH FOUND
		JMP	K25		; IF NO MATH, THEN SHIFT NOT FOUND
  
;----- SHIFT KEY FOUND

K17:	SUB	DI, K6+1	; ADJUST PTR TO SCAN CODE MATCH
		MOV	AH,CS:K7[DI]	; GET MASK INTO AH
		TEST	AL,80H		; TEST FOR BREAK KEY
		JNZ	K23		; BREAK_SHIFT_FOUND

;----- SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE

		CMP	AH,SCROLL_SHIFT	; 
		JAE	K18		; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY

;----- PLAIN SHIFT KEY, SET SHIFT ON

    	OR	[KB_FLAG],AH	; TURN ON SHIFT BIT
		JMP	K26		; INTERRUPT_RETURN

;----- TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT

K18:				; SHIFT_TOGGLE
		TEST	BYTE PTR [KB_FLAG], CTL_SHIFT ; CHECK CTL SHIFT STATE
		JNZ	K25		; JMP IF CTL STATE
		CMP	AL, INS_KEY	; CHECK FOR INSERT KEY
		JNZ	K22		; JUMP IF NOT INSERT KEY
		TEST	BYTE PTR [KB_FLAG],ALT_SHIFT ; CHECK FOR ALTERNATE SHIFT
		JNZ	K25		; JUMP IF ALTERNATE SHIFT
		TEST	BYTE PTR [KB_FLAG], NUM_STATE ; CHECK FOR BASE STATE
		JNZ	K21		; JUMP IF NUM LOCK IS ON
		TEST	BYTE PTR [KB_FLAG], LEFT_SHIFT+ RIGHT_SHIFT
		JZ	K22		; JUMP IF BASE STATE

K20:				; NUMERIC ZERO, NOT INSERT KEY
		MOV	AX, 5230H	; PUT OUT AN ASCII ZERO
		JMP	K57		; BUFFER_FILL
K21:				; MIGHT BE NUMERIC
		TEST	BYTE PTR [KB_FLAG], LEFT_SHIFT+ RIGHT_SHIFT
		JZ	K20		; JUMP NUMERIC, NOT INSERT

K22:				; SHIFT TOGGLE KEY HIT; PROCESS IT
		TEST	AH,[KB_FLAG_1]	; IS KEY ALREADY DEPRESSED?
		JNZ	K26		; JUMP IF KEY ALREADY DEPRESSED
		OR	[KB_FLAG_1],AH	; INDICATE THAT THE KEY IS DEPRESSED
		XOR	[KB_FLAG],AH	; TOGGLE THE SHIFT STATE
		CMP	AL,INS_KEY	; TEST FOR 1ST MAKE OF INSERT KEY
		JNE	K26		; JUMP IF NOT INSERT KEY
		MOV	AX,INS_KEY*256	; SET SCAN CODE INTO AH, 0 INTO AL
		JMP	K57		; PUT INTO OUTPUT BUFFER

;----- BREAK SHIFT FOUND

K23:				; BREAK-SHIFT-FOUND
		CMP	AH,SCROLL_SHIFT	; IS THIS A TOGGLE KEY ?
		JAE	K24		; YES, HANDLE BREAK TOGGLE
		NOT	AH		; INVERT MASK
		AND	[KB_FLAG],AH	; TURN OFF SHIFT BIT
		CMP	AL,ALT_KEY+80H	; IS THIS ALTERNATE SHIFT RELEASE ?
		JNE	K26		; INTERRUPT_RETURN

;----- ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER

		MOV	AL,[ALT_INPUT]	; 
		MOV	AH,0		; SCAN CODE OF 0
		MOV	[ALT_INPUT],AH	; ZERO OUT THE FIELD
		CMP	AL,0		; WAS THE INPUT=0 ?
		JE	K26		; INTERRUPT_RETURN
		JMP	K58		; IT WASN'T, SO PUT IN BUFFER
K24:				; BREAK-TOGGLE
		NOT	AH		; INVERT MASK
		AND	[KB_FLAG_1],AH	; INDICATE NO LONGER DEPRESSED
		JMP K26	; INTERRUPT_RETURN

;----- TEST FOR HOLD STATE

K25:				; NO-SHIFT-FOUND
		CMP	AL,80H		; TEST FOR BREAK KEY
		JAE	K26		; NOTHING FOR BREAK CHARS FROM HERE ON
		TEST	BYTE PTR [KB_FLAG_1],HOLD_STATE ; ARE WE IN HOLD STATE ?
		JZ	K28		; BRANCH AROUND TEST IF NOT
		CMP	AL,NUM_KEY	; 
		JE	K26		; CAN'T END HOLD ON NUM_LOCK
		AND	BYTE PTR [KB_FLAG_1],~HOLD_STATE ; TURN OFF THE HOLD STATE BIT
K26:				; INTERRUPT_RETURN
		CLI			; TURN OFF INTERRUPTS
		MOV	AL,EOI		; END OF INTERRUPT COMMAND
		OUT	20H,AL		; SEND COMMAND TO INT CONTROL PORT
K27:				; INTERRUPT_RETURN_NO_EOI
		POP	ES
		POP	DS
		POP	DI
		POP	SI
		POP	DX
		POP	CX
		POP	BX
		POP	AX		; RESTORE STATE
		IRET			; RETURN, INTERRUPTS BACK ON
					; WITH FLAG CHANGE

;----- NOT IN HOLD STATE, TEST FOR SPECIAL CHARS

K28:				; NO-HOLD-STATE
	TEST	BYTE PTR [KB_FLAG],ALT_SHIFT ; ARE WE IN ALTERNATE SHIFT ?
	JNZ	K29		; JUMP IF ALTERNATE SHIFT
	JMP	K38		; JUMP IF NOT ALTERNATE

;----- TEST FOR RESET KEY SEQUENCE (CTL ALT DEL)

K29:				; TEST-RESET
	TEST	BYTE PTR [KB_FLAG],CTL_SHIFT ; ARE WE IN CONTROL SHIFT ALSO ?
	JZ	K31		; NO_RESET
	CMP	AL,DEL_KEY	; SHIFT STATE IS THERE, TEST KEY
	JNE	K31		; NO_RESET

;----- CTL-ALT-DEL HAS BEEN FOUND, DO I/O CLEANUP

	MOV	WORD PTR [RESET_FLAG], MAGIC ;SET FLAG FOR RESET FUNCTION
;	JMP     RESET		; JUMP TO POWER ON DIAGNOTICS
		DB	0EAH	; HARD CODE JUMP
		DW	RESET	;OFFSET
		DW	0F000H	;SEGMENT

;----- ALT-INPUT-TABLE

K30:
	DB	82,79,80,81,75,76,77,71,72,73	; 10 NUMBERS ON KEYPAD

;----- SUPER-SHIFT-TABLE

	DB	16,17,18,19,20,21,22,23 ; A-Z TYPEWRITER CHARS
	DB	24,25,30,31,32,33,34,35
	DB	36,37,38,44,45,46,47,48
	DB	49,50

;----- IN ALTERNATE SHIFT, RESET NOT FOUND

K31:				; NO-RESET
	CMP	AL,57		; TEST FOR SPACE KEY
	JNE	K32		; NOT THERE
	MOV	AL,' '		; SET SPACE CHAR
	JMP	K57		; BUFFER_FILL

;----- LOOK FOR KEY PAD ENTRY

K32:				; ALT-KEY-PAD
	MOV	DI, K30	; ALT-INPUT-TABLE
	MOV	CX,10		; LOOK FOR ENTRY USING KEYPAD
	REPNE	SCASB		; LOOK FOR MATCH
	JNE	K33		; NO_ALT_KEYPAD
	SUB	DI, K30+1	; DI NOW HAS ENTRY VALUE
	MOV	AL,[ALT_INPUT]	; GET THE CURRENT BYTE
	MOV	AH,10		; MULTIPLY BY 10
	MUL	AH
	ADD	AX,DI		; ADD IN THE LATEST ENTRY
	MOV	[ALT_INPUT],AL	; STORE IT AWAY
	JMP	K26		; THROW AWAY THAT KEYSTROKE

;----- LOOK FOR SUPERSHIFT ENTRY

K33:				; NO-ALT-KEYPAD
	MOV	BYTE PTR [ALT_INPUT],0	; ZERO ANY PREVIOUS ENTRY INTO INPUT
	MOV	CX,26		; DI,ES ALREADY POINTING
	REPNE	SCASB		; LOOK FOR MATCH IN ALPHABET
	JNE	K34		; NOT FOUND, FUNCTION KEY OR OTHER
	MOV	AL,0		; ASCII CODE OF ZERO
	JMP	K57		; PUT IT IN THE BUFFER

;----- LOOK FOR TOP ROW OF ALTERNATE SHIFT

K34:				; ALT-TOP-ROW
	CMP	AL,2		; KEY WITH '1' ON IT
	JB	K35		; NOT ONE OF INTERESTING KEYS
	CMP	AL,14		; IS IT IN THE REGION ?
	JAE	K35		; ALT-FUNCTION
	ADD	AH,118		; CONVERT PSEUDO SCAN CODE TO RANGE
	MOV	AL,0		; INDICATE AS SUCH
	JMP	K57		; BUFFER FILL

;----- TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES

K35:				; ALT-FUNCTION
	CMP	AL,59		; TEST FOR IN TABLE
	JAE	K37		; ALT-CONTINUE
K36:				; CLOSE-RETURN
	JMP	K26		; IGNORE THE KEY
K37:				; ALT-CONTINUE
	CMP	AL,71		; IN KEYPAD REGION ?
	JAE	K36		; IF SO,IGNORE
	MOV	BX, K13	; ALT SHIFT PSEUDO SCAN TABLE
	JMP	K63		; TRANSLATE THAT

;----- NOT IN ALTERNATE SHIFT

K38:				; NOT-ALT-SHIFT
	TEST	BYTE PTR [KB_FLAG],CTL_SHIFT ; ARE WE IN CONTROL SHIFT ?
	JZ 	K44		; NOT-CTL-SHIFT

;----- CONTROL SHIFT, TEST SPECIAL CHARACTERS

;----- TEST FOR BREAK AND PAUSE KEYS

	CMP	AL,SCROLL_KEY	; TEST FOR BREAK
	JNE	K39		; NO-BREAK
	MOV	BX,[BUFFER_START]	; RESET BUFFER TO EMPTY
	MOV	[BUFFER_HEAD],BX	; 
	MOV	[BUFFER_TAIL],BX	; 
	MOV	BYTE PTR [BIOS_BREAK],80H	; TURN ON BIOS_BREAK BIT
	INT	1BH		; BREAK INTERRUPT VECTOR
	SUB	AX,AX		; PUT OUT DUMMY CHARACTER
	JMP	K57		; BUFFER_FILL
K39:				; NO-BREAK
	CMP	AL,NUM_KEY	; LOOK FOR PAUSE KEY
	JNE	K41		; NO-PAUSE
	OR	BYTE PTR [KB_FLAG_1], HOLD_STATE ; TURN ON THE HOLD FLAG
	MOV	AL,EOI		; END OF INTERRUPT TO CONTROL PORT
	OUT	20H,AL		; ALLOW FURTHER KEYSTROKE INTS

;----- DURING PAUSE INTERVALL,TURN CRT BACK ON

	CMP	BYTE PTR [CRT_MODE],7	; IS THIS BLACK AND WHITE CARD ?
	JE	K40		; YES, NOTHING TO DO
	MOV	DX,03D8H	; PORT FOR COLOR CARD
	MOV	AL,[CRT_MODE_SET]	; GET THE VALUE OF THE CURRENT MODE
	OUT	DX,AL		; SET THE CRT MODE, SO THAT CRT IS ON
K40:				; PAUSE-LOOP
	TEST	BYTE PTR [KB_FLAG_1],HOLD_STATE ; LOOP UNTIL FLAG TURNED OFF
	JNZ	K40		; LOOP UNTIL FLAG TURNED OFF
	JMP	K27		; INTERRUPT_RETURN_NO_EOI
K41:				; NO-PAUSE

;----- TEST SPECIAL CASE KEY 55

	CMP	AL,55		;
	JNE	K42		; NOT-KEY-55
	MOV	AX,114*256	; START/STOP PRINTING SWITCH
	JMP	K57		; BUFFER_FILL

;----- SET UP TO TRANSLATE CONTROL SHIFT

K42:				; NOT-KEY-55
	MOV	BX, K8	; SET UP TRANSLATE CTL
	CMP	AL,59		; IS IT IN TABLE ?
				; CTL-TABLE-TRANSLATE
	JB	K56		; YES, GO TRANSLATE CHAR
				; CTL-TABLE-TRANSLATE
	MOV	BX, K9	; CTL TABLE SCAN
	JMP	K63		; TRANSLATE_SCAN

;----- NOT IN CONTROL SHIFT

K44:				; NOT-CTL-SHIFT
	CMP	AL,71		; TEST FOR KEYPAD REGION
	JAE	K48		; HANDLE KEYPAD REGION
	TEST	BYTE PTR [KB_FLAG],LEFT_SHIFT+RIGHT_SHIFT ;
	JZ	K54		; TEST FOR SHIFT STATE

;----- UPPER CASE, HANDLE SPECIAL CASES

	CMP	AL,15		; BACK TAB KEY
	JNE	K45		; NOT-BACK-TAB
	MOV	AX,15*256	; SET PSEUDO SCAN CODE
	JMP	K57	; BUFFER_FILL
K45:				; NOT-BACK-TAB
	CMP	AL,55		; PRINT SCREEN KEY
	JNE	K46		; NOT-PRINT-SCREEN

;----- ISSUE INTERRUPT TO INDICATE PRINT SCREEN FUNCTION

	MOV	AL,EOI		; END OF CURRENT INTERRUPT
	OUT	20H,AL		; SO FURTHER THINGS CAN HAPPEN
	INT	5H		; ISSUE PRINT SCREEN INTERRUPT
	JMP	K27		; GO BACK WITHOUT EOI OCCURRING
K46:				; NOT-PRINT-SCREEN
	CMP	AL,59		; FUNCTION KEYS
	JB	K47		; NOT-UPPER FUNCTION
	MOV	BX, K12	; UPPER CASE PSEUDO SCAN CODES
	JMP	K63		; TRANSLATE_SCAN
K47:				; NOT-UPPER-FUNCTION
	MOV	BX, K11	; POINT TO UPPER CASE TABLE
	JMP K56	; OK, TRANSLATE THE CHAR

;----- KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION

K48:				; KEYPAD-REGION
	TEST	BYTE PTR [KB_FLAG],NUM_STATE ; ARE WE IN NUM_LOCK ?
	JNZ	K52		; TEST FOR SURE
	TEST 	BYTE PTR [KB_FLAG],LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE ?
	JNZ	K53		; IF SHIFTED, REALLY NUM STATE

;----- BASE CASE FOR KEYPAD

K49:				; BASE-CASE
	CMP	AL,74		; SPECIAL CASE FOR A COUPLE OF KEYS
	JE	K50		; MINUS
	CMP	AL,78		;
	JE	K51		; 
	SUB	AL,71		; CONVERT ORIGIN
	MOV	BX, K15	; BASE CASE TABLE
	JMP	 K64	; CONVERT TO PSEUDO SCAN
K50:
	MOV	AX,74*256+'-'	; MINUS
	JMP K57	; BUFFER_FILL
K51:
	MOV	AX,78*256+'+'	 ; PLUS
	JMP K57	; BUFFER_FILL

;----- MIGHT BE NUM LOCK, TEST SHIFT STATUS

K52:				; ALMOST-NUM-STATE
	TEST	BYTE PTR [KB_FLAG],LEFT_SHIFT+RIGHT_SHIFT ;
	JNZ	K49		; SHIFTED TEMP OUT OF NUM STATE
K53:				; REALLY_NUM_STATE
	SUB	AL,70		; CONVERT ORIGIN
	MOV	BX, K14	; NUM STATE TABLE
	JMP	K56	; TRANSLATE_CHAR

;----- PLAIN OLD LOWER CASE

K54:				; NOT-SHIFT
	CMP	AL,59		; TEST FOR FUNCTION KEYS
	JB	K55		; NOT-LOWER-FUNCTION
	MOV	AL,0		; SCAN CODE IN AH ALREADY
	JMP	K57	; BUFFER_FILL
K55:				; NOT-LOWER-FUNCTION
	MOV	BX,  K10	; LC TABLE
	
;----- TRANSLATE THE CHARACTER

K56:				; TRANSLATE-CHAR
	DEC	AL		;CONVERT ORIGIN
	PUSH DS
	PUSH CS
	POP  DS
	XLAT			; CONVERT THE SCAN CODE TO ASCII
	POP  DS

;----- PUT CHARACTER INTO BUFFER

K57:				; BUFFER_FILL
	CMP	AL,-1		; IS THIS AN IGNORE CHAR ?
	JE	K59		; YES, DO NOTHING WITH IT
	CMP	AH,-1		; LOOK FOR -1 PSEUDO SCAN
	JE	K59		; NEAR_INTERRUPT_RETURN

;----- HANDLE THE CAPS LOCK PROBLEM

K58:				; BUFFER_FILL_NOTEST
	TEST	BYTE PTR [KB_FLAG],CAPS_STATE ; ARE WE IN CAPS LOCK STATE ?
	JZ	K61		; SKIP IF NOT

;----- IN CAPS LOCK STATE
	
	TEST	BYTE PTR [KB_FLAG],LEFT_SHIFT+RIGHT_SHIFT ; TEST FOR SHIFT STATE
	JZ	K60		; IF NOT SHIFT, CONVERT LOWER TO UPPER

;----- CONVERT ANY UPPER CASE TO LOWER CASE

	CMP	AL,'A'		; FIND OUT IF ALPHABETIC
	JB	K61		; NOT_CAPS_STATE
	CMP	AL,'Z'
	JA	K61		; NOT_CAPS_STATE
	ADD	AL,'a'-'A'	; CONVERT TO LOWER CASE
	JMP	K61	; NOT_CAPS_STATE
K59:				; NEAR-INTERRUPT-RETURN
	JMP	K26		; INTERRUPT_RETURN

;------ CONVERT ANY LOWER CASE TO UPPER CASE

K60:				; LOWER-TO-UPPER
	CMP	AL,'a'		; FIND OUT IF ALPHABETIC
	JB	K61		; NOT CAPS STATE
	CMP	AL,'z'		;
	JA	K61		; NOT_CAPS_STATE
	SUB	AL,'a'-'A'	; CONVERT TO UPPER CASE
K61:				; NOT-CAPS-STATE
	MOV	BX,0[BUFFER_TAIL]	; GET THE END POINTER TO THE BUFFER
	MOV	SI,BX		; SAVE THE VALUE
	CALL	K4		; ADVANCE THE TAIL
	CMP	BX,[BUFFER_HEAD]	; HAS THE BUFFER WRAPPED AROUND ?
	JE	K62		; BUFFER_FULL_BEEP
	MOV	[SI],AX		; STORE THE VALUE
	MOV	[BUFFER_TAIL],BX	; MOVE THE POINTER UP
	JMP	K26		; INTERRUPT_RETURN

;----- TRANSLATE SCAN FOR PSEUDO SCAN CODES

K63:				; TRANSLATE-SCAN
	SUB	AL,59		; CONVERT ORIGIN TO FUNCTION KEYS
K64:				; TRANSLATE-SCAN-ORGD
	PUSH DS
	PUSH CS
	POP  DS
	XLAT		; CTL TABLE SCAN
	POP  DS
	MOV	AH,AL		; PUT VALUE INTO AH
	MOV	AL,0		; ZERO ASCII CODE
	JMP	K57		; PUT IT INTO THE BUFFER
	
;----- BUFFER IS FULL, SOUND THE BEEPER

K62:
	MOV	AL,EOI		; END OF INTERRUPT COMMAND
	OUT	20H,AL		; SEND COMMAND TO INT CONTROL PORT
	MOV	BX,80H		; NUMBER OF CYCLES FOR 1/12 SECOND TONE
	IN	AL,KB_CTL	; GET CONTROL INFORMATION
	PUSH 	AX		; SAVE
K65:				; BEEP-CYCLE
	AND	AL,0FCH		; TURN OFF TIMER GATE AND SPEAKER DATA
	OUT	KB_CTL,AL	; OUTPUT TO CONTROL
	MOV	CX,48H		; HALF CYCLE TIME FOR TONE
K66:
	LOOP	K66		; SPEAKER OFF
	OR	AL,2		; TURN ON SPEAKER BIT
	OUT	KB_CTL,AL	; OUTPUT TO CONTROL
	MOV	CX,48H		; SET UP COUNT
K67:
	LOOP	K67		; ANOTHER HALF CYCLE
	DEC	BX		; TOTAL TIME COUNT
	JNZ	K65		; DO ANOTHER CYCLE
	POP	AX		; RECOVER CONTROL
	OUT	KB_CTL,AL	; OUTPUT THE CONTROL
	JMP	K27
		
;------- INT 17 -------------------------------------------------
; PRINTER I/O
;     THIS ROUTINE PROVIDES COMMUNICATION WITH THE PRINTER
; INPUT
;	(AH)=0	PRINT THE CHARACTER IN (AL)
;		ON RETURN, AH=1 IF CHARACTER COULD NOT BE PRINTED
;		(TIME OUT). OTHER BITS SET AS ON NORMAL STATUS CALL
;	(AH)=1	INITIALIZE THE PRINTER PORT
;		RETURNS WITH (AH) SET WITH PRINTER STATUS
;	(AH)=2	READ THE PRINTER STATUS INTO (AH)
;		7	6	5	4	3	2-1   0
;		|	|	|	|	|	|     |_TIMEOUT
;		|	|	|	|	|	|_UNUSED
;		|	|	|	|	|_ 1 = I/O ERROR
;		|	|	|	|_ 1 = SELECTED
;		|	|	|_ 1 = OUT OF PAPER
;		|	|_ 1 = ACKNOWLEDGE
;		|_ 1 = NOT BUSY
;
;	(DX) = PRINTER TO BE USED (0,1,2) CORRESPONDING TO ACTUAL
;		VALUES IN PRINTER_BASE AREA
; DATA AREA PRINTER_BASE CONTAINS THE BASE ADDRESS OF THE PRINTER
; CARD(S) AVAILABLE (LOCATED AT BEGINNING OF DATA SEGMENT,
; 408H ABSOLUTE, 3 WORDS)
;
; DATA AREA PRINT_TIM_OUT (BYTE) MAY BE CHANGED TO CAUSE DIFFERENT
; TIME_OUT WAITS. DEFAULT=20
;
; REGISTERS	AH IS MODIFIED
;		ALL OTHERS UNCHANGED
;---------------------------------------------------------------------
	
PRINTER_IO:
	STI			; INTERRUPTS BACK ON
	PUSH	DS		; SAVE SEGMENT
	PUSH	DX
	PUSH	SI
	PUSH	CX
	PUSH	BX
	CALL	DDS		; GET PARAGRAPH OF DATA AREA
	MOV	SI,DX		; GET PRINTER PARM
	MOV	BL,PRINT_TIM_OUT[SI]	;LOAD PRINT_TIM_OUT PARM
	SHL	SI,1		; WORD OFFSET INTO TABLE
	MOV	DX,PRINTER_BASE[SI]	;GET BASE ADDRESS FOR PRINTER CARD
				;PRINTER_BASE[SI]
	OR	DX,DX		; TEST DX FOR ZERO,
				; INDICATING NO PRINTER
	JZ	B1		; RETURN
	OR	AH,AH		; TEST FOR (AH)=0
	JZ	B2		; PRINT_AL
	DEC	AH		; TEST FOR (AH)=1
	JZ	B8		; INIT_PRT
	DEC	AH		; TEST FOR (AH)=2
	JZ	B5		; PRINTER STATUS
B1:
	POP	BX
	POP	CX
	POP	SI		; RECOVER REGISTERS
	POP	DX		; RECOVER REGISTERS
	POP	DS
	IRET

;------ PRINT THE CHARACTER IN (AL)

B2:
	PUSH	AX		; SAVE VALUE TO PRINT
	OUT	DX,AL		; OUTPUT CHAR TO PORT
	INC	DX		; POINT TO STATUS PORT
B3:
	SUB	CX,CX		; WAIT_BUSY
B3_1:
	IN	AL,DX		; GET STATUS
	MOV	AH,AL		; STATUS TO AH ALSO
	TEST	AL,80H		; IS THE PRINTER CURRENTLY BUSY ?
	JNZ	B4		; OUT_STROBE
	LOOP	B3_1		; TRY AGAIN
	DEC	BL		; DROP LOOP COUNT
	JNZ	B3		; GO TILL TIMEOUT ENDS
	OR	AH,1		; SET ERROR FLAG
	AND	AH,0F9H		; TURN OFF THE OTHER BITS
	JMP	B7	; RETURN WITH ERROR FLAG SET
B4:				; OUT_STROBE
	MOV	AL,0DH		; SET THE STROBE HIGH
	INC	DX		; STROBE IS BIT 0 OF PORT C OF 8255
	OUT	DX,AL		; 
	MOV	AL,0CH		; SET THE STROBE LOW
	OUT	DX,AL
	POP	AX		; RECOVER THE OUTPUT CHAR

;------ PRINTER STATUS

B5:
	PUSH	AX		; SAVE AL REG
B6:
	MOV	DX,PRINTER_BASE[SI]	;PRINTER_BASE[SI]
	INC	DX
	IN	AL,DX		; GET PRINTER STATUS
	MOV	AH,AL
	AND	AH,0F8H		; TURN OFF UNUSED BITS
B7:				; STATUS_SET
	POP	DX		; RECOVER AL REG
	MOV	AL,DL		; GET CHARACTER INTO AL
	XOR	AH,48H		; FLIP A COUPLE OF BITS
	JMP	B1		; RETURN FROM ROUTINE

;------ INITIALIZE THE PRINTER PORT

B8:
	PUSH	AX		; SAVE AL
	INC	DX		; POINT TO OUTPUT PORT
	INC	DX
	MOV	AL,8		; SET INIT LINE LOW
	OUT	DX,AL
	MOV	AX,1000
B9:				; INIT_LOOP
	DEC	AX		; LOOP FOR RESET TO TAKE
	JNZ	B9		; INIT_LOOP
	MOV	AL,0CH		; NO INTERRUPTS, NO AUTO LF,
				; INIT HIGH
	OUT	DX,AL
	JMP	B6		; PRT_STATUS_1


;--- INT 2 -----------------------------------------------------------
; NON-MASKABLE INTERRUPT ROUTINE:	 			:
;	THIS ROUTINE WILL PRINT A PARITY CHECK 1 OR 2 MESSAGE:	:
;	AND ATTEMPT TO FIND THE STORAGE LOCATION CONTAINING THE	:
;	BAD PARITY.  IF FOUND, THE SEGMENT ADDRESS WILL BE	:
;	PRINTED.  IF NO PARITY ERROR CAN BE FOUND (INTERMITTANT	:
;	READ PROBLEM) ?????<-WILL BE PRINTED WHERE THE ADDRESS	:
;	WOULD NORMALLY GO.					:
;	IF ADDRESS IN ERROR IS IN THE I/O EXPANSION BOX, THE	:
;	ADDRESS WILL BE FOLLOWED BY A '(E)', IF IN SYSTEM UNIT,	:
;	A '(S)' WILL FOLLOW THE ADDRESS.			:
;----------------------------------------------------------------
NMI_INT:
	; TODO - implement NMI
	IRET
	
;----------------------------------------
;	ROS CHECKSUM SUBROUTINE		:
;----------------------------------------
ROS_CHECKSUM:		; NEXT_ROS_MODULE
	MOV	CX,8192			; NUMBER OF BYTES TO ADD
ROS_CHECKSUM_CNT:			; ENTRY FOR OPTIONAL ROS TEST
	XOR	AL,AL
C26:
	ADD	AL,[BX]
	INC	BX			; POINT TO NEXT BYTE
	LOOP	C26			; ADD ALL BYTES IN ROS MODULE
	OR	AL,AL			; SUM = 0 ?
	RET
	
;----------------------------------------
;	MESSAGE AREA FOR POST		:
;----------------------------------------
E0	DB	'101',13,10		; SYSTEM BOARD ERROR
E1	DB	' 201',13,10		; MEMORY ERROR
F3A	DB	'ROM',13,10		; MEMORY ERROR
F3C	DB	'1801',13,10		; EXPANSION IO BOX ERROR
F3D	DB	'ERROR. (RESUME = "F1" KEY)',13,10 ;ERROR PROMPT
D1	DB	'PARITY CHECK 2',13,10
D2	DB	'PARITY CHECK 1',13,10
D2A	DB	'?????',13,10

F4:			; PRINTER SOURCE TABLE
	DW	3BCH
	DW	378H
	DW	278H
F4E:
;--------------------------------------------------------
;	BLINK LED PROCEDURE FOR MFG RUN-IN TESTS	:
;	 IF LED IS ON, TURN IT OFF, IF OFF, TURN ON	:
;--------------------------------------------------------

BLINK_INT:
	STI
	PUSH	AX			; SAVE AX REG CONTENTS
	IN	AL,PORT_B		; READ CURRENT VAL OF PORT B
	MOV	AH,AL
	NOT	AL			; FLIP ALL BITS
	AND	AL,01000000B		; ISOLATE CONTROL BIT
	AND	AH,10111111B		; MASK OUT OF ORIGINAL VAL
	OR	AL,AH			; OR NEX CONTROL BIT IN
	OUT	PORT_B,AL
	MOV	AL,EOI
	OUT	INTA00,AL
	POP	AX			; RESTORE AX REG
	IRET
	
;----------------------------------------------------------------
;  PRINT ADDRESS AND ERROR MESSAGE FOR ROM CHECKSUM ERRORS	:
;----------------------------------------------------------------
ROM_ERR:
	PUSH	DX			; SAVE POINTER
	PUSH	AX
	MOV	DX,DS			; GET ADDRESS POINTER
	MOV	ES:[MFG_ERR_FLAG],DH	; ******************************
					; ****  CHECKPOINTS C0->F4  ****
					; ******************************
	CMP	DX,0C800H		; CRT CARD IN ERROR?
	JL	ROM_ERR_BEEP		; GIVE CRT CARD FILE BEEP
	;CALL	PRT_SEG			; PRINT SEGMENT IN ERROR
	MOV	SI,F3A		; DISPLAY ERROR MESSAGE
	NOP				; DUMMY **********
	CALL	E_MSG
ROM_ERR_END:
	POP	AX
	POP	DX
	RET
ROM_ERR_BEEP:
	MOV	DX,0102H		; BEEP 1 LONG, 2 SHORT
	CALL	ERR_BEEP
	JMP	ROM_ERR_END
	
F1	DB	' 301',13,10	; KEYBOARD ERROR
F3	DB	'601',13,10	;DISKETTE ERROR
	
;--------------------------------------------------------
; THIS ROUTINE CHECKSUMS OPTIONNAL ROM MODULES AND	:
; IF CHECKSUM IS OK, CALLS INIT/TEST CODE IN MODULE	:
;--------------------------------------------------------
ROM_CHECK:
	MOV	AX,DATA			; POINT ES TO DATA AREA
	MOV	ES,AX
	SUB	AH,AH			; ZERO OUT AH
	MOV	AL,[BX+2]		; GET LENGTH INDICATOR
	MOV	CL,09H			; MULTIPLY BY 512
	SHL	AX,CL
	MOV	CX,AX			; SET COUNT
	PUSH	CX
	MOV	CX,4			; ADJUST
	SHR	AX,CL
	ADD	DX,AX			; SET POINTER TO NEXT MODULE
	POP	CX			; RETRIEVE COUNT
	CALL	ROS_CHECKSUM_CNT	; DO CHECKSUM
	JZ	ROM_CHECK_1
	CALL	ROM_ERR			; POST CHECKSUM ERROR
	JMP	ROM_CHECK_END		; AND EXIT
ROM_CHECK_1:
	PUSH	DX			; SAVE POINTER
	MOV	WORD PTR ES:[IO_ROM_INIT],0003H	; LOAD OFFSET
	MOV	ES:[IO_ROM_SEG],DS	; LOAD SEGMENT
	CALL ES:[IO_ROM_INIT]	; CALL INIT./TEST ROUTINE
	POP	DX
ROM_CHECK_END:
	RET				; RETURN TO CALLER
	
;------------------------------------------------
; CONVERT AND PRINT ASCII CODE			:
;	AL MUST CONTAIN NUMBER TO BE CONVERTED.	:
;	AX AND BX DESTROYED.			:
;------------------------------------------------
XPC_BYTE:
	PUSH	AX			; SAVE FOR LOW NIBBLE DISPLAY
	MOV	CL,4			; SHIFT COUNT
	SHR	AL,CL			; NIBBLE SWAP
	CALL	XLAT_PR			; DO THE HIGH NIBBLE DISPLAY
	POP	AX			; REVOVER THE NIBBLE
	AND	AL,0FH			; ISOLATE TO LOW NIBBLE
					; FALL INTO LOW NIBBLE CONVERSION
XLAT_PR:			; CONVERT 00-0F TO ASCII CHARACTER
	ADD	AL,090H			; ADD FIRST CONVERSION FACTOR
	DAA				; ADJUST FOR NUMERIC AND ALPHA RANGE
	ADC	AL,040H			; ADD CONVERSION AND ADJUST LOW NIBBLE
	DAA				; ADJUST HIGH NIBBLE TO ASCHI RANGE
PRT_HEX:
	MOV	AH,14			; DISPLAY CHARACTER IN AL
	MOV	BH,0
	INT	10H			; CALL VIDEO_IO
	RET
	
;--------------------------------------------------------
; THIS SUBROUTINE WILL PRINT A MESSAGE ON THE DISPLAY	:
;							:
; ENTRY REQUIREMENTS:					:
;	SI = OFFSET(ADDRESS) OF MESSAGE BUFFER		:
;	CX = MESSAGE BYTE COUNT				:
;	MAXIMUM MESSAGE LENGTH IS 36 CHARACTERS		:
;--------------------------------------------------------
E_MSG:
	MOV	BP,SI			; SET BP NON-ZERO TO FLAG ERR
	CALL	P_MSG			; PRINT MESSAGE
	PUSH	DS
	CALL	DDS
	MOV	AL,BYTE PTR [EQUIP_FLAG]	; LOOP/HALT ON ERROR
	AND	AL,01H			; SWITCH ON ?
	JNE	G12			; NO - RETURN
MFG_HALT:
	CLI				; YES - HALT SYSTEM
	MOV	AL,89H
	OUT	CMD_PORT,AL
	MOV	AL,10000101B		; DISABLE KB
	OUT	PORT_B,AL
	MOV	AL,[MFG_ERR_FLAG]		; RECOVER ERROR INDICATOR
	OUT	PORT_A,AL		; SET INTO 8255 REG
	HLT				; HALT SYS
G12:
	POP	DS			; WRITE_MSG:
	RET
	
P_MSG:
G12A:
	MOV	AL,CS:[SI]		; PUT CHAR IN AL
	INC	SI			; POINT TO NEXT CHAR
	PUSH	AX			; SAVE PRINT CHAR
	CALL	PRT_HEX			; CALL VIDEO_IO
	POP	AX			; RECOVER PRINT CHAR
	CMP	AL,10			; WAS IT LINE FEED?
	JNE	G12A			; NO, KEEP PRINTING STRING
	RET

;-------------------------------------------
;	SUBROUTINES FOR POWER ON DIAGNOSTICS
;--------------------------------------------------------------------
;	THIS PROCEDURE WILL ISSUE ONE LONG TONE (3 SECS) AND ONE OR
;	MORE SHORT TONES (1 SEC) TO INDICATE A FAILURE ON THE PLANAR
;	BOARD, A BAD RAM MODULE, OR A PROBLEM WITH THE CRT.
; ENTRY PARAMETERS:
;	DH = NUMBER OF LONG TONES TO BEEP
;	DL = NUMBER OF SHORT TONES TO BEEP
;--------------------------------------------------------------------
	
ERR_BEEP:
	PUSHF				; SAVE FLAGS
	CLI				; DISABLE SYSTEM INTERRUPTS
	PUSH	DS			; SAVE DS REG CONTENTS
	CALL	DDS
	OR	DH,DH			; ANY LONG ONES TO BEEP
	JZ	G3			; NO, DO THE SHORT ONES
G1:					; LONG_BEEP:
	MOV	BL,6			; COUNTER FOR BEEPS
	CALL	BEEP			; DO THE BEEP
G2:
	LOOP	G2			; DELAY BETWEEN THE BEEPS
	
	DEC	DH			; ANY MORE TO DO
	JNZ	G1			; DO IT

	CMP	BYTE PTR [MFG_TST],1		; MFG TEST MODE?
	JNE	G3			; YES - CONTINUE BEEPING SPEAKER
	JMP	MFG_HALT		; STOP BLINKING LED
G3:					; SHORT BEEP:
	MOV	BL,1			; COUNTER FOR A SHORT BEEP
	CALL	BEEP			; DO THE SOUND
G4:
	LOOP	G4			; DELAY BETWEEN BEEPS
	DEC	DL			; DONE WITH SHORTS
	JNZ	G3			; DO SOME MORE
G5:
	LOOP	G5			; LONG DELAY BEFORE RETURN
G6:
	LOOP	G6

	POP	DS 			; RESTORE ORIG CONTENTS OF DS
	POPF				; RESTORE FLAGS TO ORIG SETTINGS
	RET				; RETURN TO CALLER

;----- ROUTINE TO SOUND BEEPER

BEEP:
	MOV	AL,10110110B		; SEL TIM 2,LSB,MSB,BINARY
	OUT	TIMER+3,AL		; WRITE THE TIMER MODE REG
	MOV	AX,533H			; DIVISOR FOR 1000 HZ
	OUT	TIMER+2,AL		; WRITE TIMER 2 CNT - LSB
	MOV	AL,AH
	OUT	TIMER+2,AL 		; WRITE TIMER 2 CNT - MSB
	IN	AL,PORT_B		; GET CURRENT SETTING OF PORT
	MOV	AH,AL			; SAVE THAT SETTING
	OR	AL,03			; TURN SPEAKER ON
	OUT	PORT_B,AL
	SUB	CX,CX			; SET CNT TO WAIT 500 MS
G7:
	LOOP	G7			; DELAY BEFORE TURNING OFF
	
	DEC	BL			; DELAY CNT EXPIRED?
	JNZ	G7			; NO - CONTINUE BEEPING SPK
	MOV	AL,AH			; RECOVER VALUE OF PORT
	OUT	PORT_B,AL
	RET				; RETURN TO CALLER
;------------------------------------------------------------------
;	THIS PROCEDURE WILL SEND A SOFTWARE RESET TO THE KEYBOARD.
;	SCAN CODE 'AA' SHOULD BE RETURNED TO THE CPU.
;------------------------------------------------------------------
KBD_RESET:
	MOV	AL,08H			; SET KBD CLK LINE LOW
	OUT	PORT_B,AL		; WRITE 8255 PORT B
	MOV	CX,10582		; HOLD KBD CLK LOW FOR 20 MS
G8:
	LOOP	G8			; LOOP FOR 20 MS
	MOV	AL,0C8H			; SET CLK, ENABLE LINES HIGH
	OUT	PORT_B,AL
SP_TEST:				; ENTRY FOR MANUFACTURING TEST 2
	MOV	AL,48H			; SET KBD CLK HIGH, ENABLE LOW
	OUT	PORT_B,AL
	MOV	AL,0FDH			; ENABLE KEYBOARD INTERRUPTS
	OUT	INTA01,AL		; WRITE 8259 IMR
	MOV	 BYTE PTR [INTR_FLAG-DATA_BASE],0
					; RESET INTERRUPT INDICATOR
	STI				; ENABLE INTERRUPTS
	SUB	CX,CX			; SETUP INTERRUPT TIMEOUT CNT
G9:
	TEST	BYTE PTR [INTR_FLAG-DATA_BASE],02H
					; DID A KEYBOARD INTR OCCUR?
	JNZ	G10			; YES - READ SCAN CODE RETURNED
	LOOP	G9			; NO - LOOP TILL TIMEOUT
G10:
	IN	AL,PORT_A		; READ KEYBOARD SCAN CODE
	MOV	BL,AL			; SAVE SCAN CODE JUST READ
	MOV	AL,0C8H			; CLEAR KEYBOARD
	OUT	PORT_B,AL
	RET				; RETURN TO CALLER
	
DDS:
	PUSH	AX			; SAVE AX
	MOV	AX,DATA
	MOV	DS,AX			; SET SEGMENT
	POP	AX			; RESTORE AX
	RET
	
;--- INT 1A ---------------------------------------------
; TIME_OF_DAY						:
;  THIS ROUTINE ALLOWS THE CLOCK TO BE SET/READ		:
;							:
; INPUT							:
;   (AH) = 0	READ THE CURRENT CLOCK SETTING		:
;		RETURNS CX = HIGH PORTION OF COUNT	:
;			DX = LOW PORTION OF COUNT	:
;			AL = 0 IF TIMER HAS NOT PASSED	:
;			 24 HOURS SINCE LAST READ	:
;			   <>0 IF ON ANOTHER DAY	:
;   (AH) = 1	SET CURRENT CLOCK			:
;	CX = HIGH PORTION OF COUNT			:
;	DX = LOW PORTION OF COUNT			:
; NOTE: COUNTS OCCUR AT THE RATE OF			:
;	 1193180/65536 COUNTS/SEC			:
;	(OR ABOUT 18.2 PER SECOND -- SEE EQUATES BELOW)	:
;--------------------------------------------------------

TIME_OF_DAY:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; SAVE SEGMENT
	CALL	DDS
	OR	AH,AH			; AH=0 ?
	JZ	T2			; READ_TIME
	DEC	AH			; AH=1 ?
	JZ	T3			; SET_TIME
T1:					; TOD_RETURN
	STI				; INTERRUPTS BACK ON
	POP	DS			; RECOVER SEGMENT
	IRET				; RETURN TO CALLER
T2:					; READ_TIME
	CLI				; NO TIMER INTERRUPTS WHILE READING
	MOV	AL,[TIMER_OFL]
	MOV	BYTE PTR [TIMER_OFL],0		; GET OVERFLOW, AND RESET THE FLAG
	MOV	CX,[TIMER_HIGH]
	MOV	DX,[TIMER_LOW]
	JMP	T1			; TOD_RETURN
T3:					; SET_TIME
	CLI				; NO TIMER INTERRUPTS WHILE WRITING
	MOV	[TIMER_LOW],DX
	MOV	[TIMER_HIGH],CX		; SET THE TIME
	MOV	BYTE PTR [TIMER_OFL],0		; RESET OVERFLOW
	JMP	T1			; TOD_RETURN
	
;--- INT 8 ----------------------------------------------
; TIMER_INT
;
; THIS ROUTINE HANDLES THE TIMER INTERRUPT FROM		:
;  CHANNEL 0 OF THE 8253 TIMER. INPUT FREQUENCY		:
;  IS 1.19318 MHZ AND THE DIVISOR IS 65536, RESULTING	:
;  IN APPROX. 18.2 INTERRUPTS EVERY SECOND.		:
; THE INTERRUPT HANDLER MAINTAINS A COUNT OF INTERRUPTS	:
;  SINCE POWER ON TIME, WHICH MAY BE USED TO ESTABLISH	:
;  TIME OF DAY.						:
; THE INTERRUPT HANDLER ALSO DECREMENTS THE MOTOR	:
;  CONTROL COUNT OF THE DISKETTE, AND WHEN IT EXPIRES,	:
;  WILL TURN OFF THE DISKETTE MOTOR, AND RESET THE 	:
;  MOTOR RUNNING FLAGS.					:
; THE INTERRUPT HANDLER WILL ALSO INVOKE A USER ROUTINE	:
;  THROUGH INTERRUPT 1CH AT EVERY TIME TICK. THE USER	:
;  MUST CODE A RETURN AND PLACE THE CORRECT ADDRESS IN	:
;  THE VECTOR TABLE.					:
;--------------------------------------------------------

TIMER_INT:
	STI				; INTERRUPTS BACK ON
	PUSH	DS
	PUSH	AX
	PUSH	DX			; SAVE MACHINE STATE
	CALL	DDS
	
	INC	WORD PTR [TIMER_LOW]		; INCREMENT TIME
	JNZ	T4			; TEST_DAY
	INC	WORD PTR [TIMER_HIGH]		; INCREMENT HIGH WORD OF TIME
T4:					; TEST_DAY
	CMP	WORD PTR [TIMER_HIGH],018H		; TEST FOR COUNT EQUALING 24 HOURS
	JNZ	T5			; DISKETTE_CTL
	CMP	WORD PTR [TIMER_LOW],0B0H
	JNZ	T5			; DISKETTE_CTL

;------  TIMER HAS GONE 24 HOURS

	SUB	AX,AX
	MOV	[TIMER_HIGH],AX
	MOV	[TIMER_LOW],AX
	MOV	BYTE PTR [TIMER_OFL],1

;------ TEST FOR DISKETTE TIME OUT

T5:					; DISKETTE_CTL
	DEC	BYTE PTR [MOTOR_COUNT]
	JNZ	T6			; RETURN IF COUNT NOT OUT
	AND	BYTE PTR [MOTOR_STATUS],0F0H	; TURN OFF MOTOR RUNNING BITS
	MOV	AL,0CH
	MOV	DX,03F2H		; FDC CTL PORT
	OUT	DX,AL			; TURN OFF THE MOTOR
T6:					; TIMER_RET
	INT	1CH			; TRANSFER CONTROL TO A USER ROUTINE
	MOV	AL,EOI
	OUT	020H,AL			; END OF INTERRUPT TO 8259
	POP	DX
	POP	AX
	POP	DS			; RESET MACHINE STATE
	IRET				; RETURN FROM INTERRUPT
	
;-- INT 5 ---------------------------------------------------------------
; PRINT_SCREEN
;	THIS LOGIC WILL BE INVOKED BY INTERRUPT 05H TO PRINT THE	:
;	SCREEN. THE CURSOR POSITION AT THE TIME THIS ROUTINE IS INVOKED :
;	WILL BE SAVED AND RESTORED UPON COMPLETION. THE ROUTINE IS	:
;	INTENDED TO RUN WITH INTERRUPTS ENABLED. IF A SUBSEQUENT	:
;	'PRINT SCREEN' KEY IS DEPRESSED DURING THE TIME THIS ROUTINE	:
;	IS PRINTING IT WILL BE IGNORED. 				:
;	ADDRESS 50:0 CONTAINS THE STATUS OF THE PRINT SCREEN:		:
; 									:
;	50:0	=0	EITHER PRINT SCREEN HAS NOT BEEN CALLED 	:
;			OR UPON RETURN FROM A CALL THIS INDICATES	:
;			A SUCCESSFUL OPERATION. 			:
;		=1	PRINT SCREEN IN PROGRESS 			:
;		=255	ERROR ENCOUNTERED DURING PRINTING 		:
;------------------------------------------------------------------------

PRINT_SCREEN:
	IRET	;  TODO - Implement INT5
	
;----------------------------------------------------------------
;	PRINT A SEGMENT VALUE TO LOOK LIKE A 20 BIT ADDRESS.	:
;	DX MUST CONTAIN THE SEGMENT VALUE TO BE PRINTED.	:
;----------------------------------------------------------------
PRT_SEG:
	MOV	AL,DH			; GET MSB
	CALL	XPC_BYTE
	MOV	AL,DL			; LSB
	CALL	XPC_BYTE
	MOV	AL,'0'			; PRINT A '0'
	CALL	PRT_HEX
	MOV	AL,' '			; SPACE
	CALL	PRT_HEX
	RET
	
;------------------------------------------------------------------------
;	CHARACTER GENERATOR GRAPHICS FOR 320X200 AND 640X200 GRAPHICS	:
;------------------------------------------------------------------------

CRT_CHAR_GEN:

	DB	000H,000H,000H,000H,000H,000H,000H,000H ; D_00
	DB	07EH,081H,0A5H,081H,0BDH,099H,081H,07EH ; D_01
	DB	07EH,0FFH,0DBH,0FFH,0C3H,0E7H,0FFH,07EH ; D_02
	DB	06CH,0FEH,0FEH,0FEH,07CH,038H,010H,000H ; D_03
	DB	010H,038H,07CH,0FEH,07CH,038H,010H,000H ; D_04
	DB	038H,07CH,038H,0FEH,0FEH,07CH,038H,07CH ; D_05
	DB	010H,010H,038H,07CH,0FEH,07CH,038H,07CH ; D_06
	DB	000H,000H,018H,03CH,03CH,018H,000H,000H ; D_07
	DB	0FFH,0FFH,0E7H,0C3H,0C3H,0E7H,0FFH,0FFH ; D_08
	DB	000H,03CH,066H,042H,042H,066H,03CH,000H ; D_09
	DB	0FFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0FFH ; D_0A
	DB	00FH,007H,00FH,07DH,0CCH,0CCH,0CCH,078H ; D_0B
	DB	03CH,066H,066H,066H,03CH,018H,07EH,018H ; D_0C
	DB	03FH,033H,03FH,030H,030H,070H,0F0H,0E0H ; D_0D
	DB	07FH,063H,07FH,063H,063H,067H,0E6H,0C0H ; D_0E
	DB	099H,05AH,03CH,0E7H,0E7H,03CH,05AH,099H ; D_0F
	DB	080H,0E0H,0F8H,0FEH,0F8H,0E0H,080H,000H ; D_10
	DB	002H,00EH,03EH,0FEH,03EH,00EH,002H,000H ; D_11
	DB	018H,03CH,07EH,018H,018H,07EH,03CH,018H ; D_12
	DB	066H,066H,066H,066H,066H,000H,066H,000H ; D_13
	DB	07FH,0DBH,0DBH,07BH,01BH,01BH,01BH,000H ; D_14
	DB	03EH,063H,038H,06CH,06CH,038H,0CCH,078H ; D_15
	DB	000H,000H,000H,000H,07EH,07EH,07EH,000H ; D_16
	DB	018H,03CH,07EH,018H,07EH,03CH,018H,0FFH ; D_17
	DB	018H,03CH,07EH,018H,018H,018H,018H,000H ; D_18
	DB	018H,018H,018H,018H,07EH,03CH,018H,000H ; D_19
	DB	000H,018H,00CH,0FEH,00CH,018H,000H,000H ; D_1A
	DB	000H,030H,060H,0FEH,060H,030H,000H,000H ; D_1B
	DB	000H,000H,0C0H,0C0H,0C0H,0FEH,000H,000H ; D_1C
	DB	000H,024H,066H,0FFH,066H,024H,000H,000H ; D_1D
	DB	000H,018H,03CH,07EH,0FFH,0FFH,000H,000H ; D_1E
	DB	000H,0FFH,0FFH,07EH,03CH,018H,000H,000H ; D_1F
	DB	000H,000H,000H,000H,000H,000H,000H,000H ; SP D_20
	DB	030H,078H,078H,030H,030H,000H,030H,000H ; ! D_21
	DB	06CH,06CH,06CH,000H,000H,000H,000H,000H ; " D_22
	DB	06CH,06CH,0FEH,06CH,0FEH,06CH,06CH,000H ; # D_23
	DB	030H,07CH,0C0H,078H,00CH,0F8H,030H,000H ; $ D_24
	DB	000H,0C6H,0CCH,018H,030H,066H,0C6H,000H ; % D_25
	DB	038H,06CH,038H,076H,0DCH,0CCH,076H,000H ; & D_26
	DB	060H,060H,0C0H,000H,000H,000H,000H,000H ; ' D_27
	DB	018H,030H,060H,060H,060H,030H,018H,000H ; ( D_28
	DB	060H,030H,018H,018H,018H,030H,060H,000H ; ) D_29
	DB	000H,066H,03CH,0FFH,03CH,066H,000H,000H ; * D_2A
	DB	000H,030H,030H,0FCH,030H,030H,000H,000H ; + D_2B
	DB	000H,000H,000H,000H,000H,030H,030H,060H ; , D_2C
	DB	000H,000H,000H,0FCH,000H,000H,000H,000H ; - D_2D
	DB	000H,000H,000H,000H,000H,030H,030H,000H ; . D_2E
	DB	006H,00CH,018H,030H,060H,0C0H,080H,000H ; / D_2F
	DB	07CH,0C6H,0CEH,0DEH,0F6H,0E6H,07CH,000H ; 0 D_30
	DB	030H,070H,030H,030H,030H,030H,0FCH,000H ; 1 D_31
	DB	078H,0CCH,00CH,038H,060H,0CCH,0FCH,000H ; 2 D_32
	DB	078H,0CCH,00CH,038H,00CH,0CCH,078H,000H ; 3 D_33
	DB	01CH,03CH,06CH,0CCH,0FEH,00CH,01EH,000H ; 4 D_34
	DB	0FCH,0C0H,0F8H,00CH,00CH,0CCH,078H,000H ; 5 D_35
	DB	038H,060H,0C0H,0F8H,0CCH,0CCH,078H,000H ; 6 D_36
	DB	0FCH,0CCH,00CH,018H,030H,030H,030H,000H ; 7 D_37
	DB	078H,0CCH,0CCH,078H,0CCH,0CCH,078H,000H ; 8 D_38
	DB	078H,0CCH,0CCH,07CH,00CH,018H,070H,000H ; 9 D_39
	DB	000H,030H,030H,000H,000H,030H,030H,000H ; : D_3A
	DB	000H,030H,030H,000H,000H,030H,030H,060H ; ; D_3B
	DB	018H,030H,060H,0C0H,060H,030H,018H,000H ; < D_3C
	DB	000H,000H,0FCH,000H,000H,0FCH,000H,000H ; = D_3D
	DB	060H,030H,018H,00CH,018H,030H,060H,000H ; > D_3E
	DB	078H,0CCH,00CH,018H,030H,000H,030H,000H ; ? D_3F
	DB	07CH,0C6H,0DEH,0DEH,0DEH,0C0H,078H,000H ; @ D_40
	DB	030H,078H,0CCH,0CCH,0FCH,0CCH,0CCH,000H ; A D_41
	DB	0FCH,066H,066H,07CH,066H,066H,0FCH,000H ; B D_42
	DB	03CH,066H,0C0H,0C0H,0C0H,066H,03CH,000H ; C D_43
	DB	0F8H,06CH,066H,066H,066H,06CH,0F8H,000H ; D D_44
	DB	0FEH,062H,068H,078H,068H,062H,0FEH,000H ; E D_45
	DB	0FEH,062H,068H,078H,068H,060H,0F0H,000H ; F D_46
	DB	03CH,066H,0C0H,0C0H,0CEH,066H,03EH,000H ; G D_47
	DB	0CCH,0CCH,0CCH,0FCH,0CCH,0CCH,0CCH,000H ; H D_48
	DB	078H,030H,030H,030H,030H,030H,078H,000H ; I D_49
	DB	01EH,00CH,00CH,00CH,0CCH,0CCH,078H,000H ; J D_4A
	DB	0E6H,066H,06CH,078H,06CH,066H,0E6H,000H ; K D_4B
	DB	0F0H,060H,060H,060H,062H,066H,0FEH,000H ; L D_4C
	DB	0C6H,0EEH,0FEH,0FEH,0D6H,0C6H,0C6H,000H ; M D_4D
	DB	0C6H,0E6H,0F6H,0DEH,0CEH,0C6H,0C6H,000H ; N D_4E
	DB	038H,06CH,0C6H,0C6H,0C6H,06CH,038H,000H ; O D_4F
	DB	0FCH,066H,066H,07CH,060H,060H,0F0H,000H ; P D_50
	DB	078H,0CCH,0CCH,0CCH,0DCH,078H,01CH,000H ; Q D_51
	DB	0FCH,066H,066H,07CH,06CH,066H,0E6H,000H ; R D_52
	DB	078H,0CCH,0E0H,070H,01CH,0CCH,078H,000H ; S D_53
	DB	0FCH,0B4H,030H,030H,030H,030H,078H,000H ; T D_54
	DB	0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,0FCH,000H ; U D_55
	DB	0CCH,0CCH,0CCH,0CCH,0CCH,078H,030H,000H ; V D_56
	DB	0C6H,0C6H,0C6H,0D6H,0FEH,0EEH,0C6H,000H ; W D_57
	DB	0C6H,0C6H,06CH,038H,038H,06CH,0C6H,000H ; X D_58
	DB	0CCH,0CCH,0CCH,078H,030H,030H,078H,000H ; Y D_59
	DB	0FEH,0C6H,08CH,018H,032H,066H,0FEH,000H ; Z D_5A
	DB	078H,060H,060H,060H,060H,060H,078H,000H ; [ D_5B
	DB	0C0H,060H,030H,018H,00CH,006H,002H,000H ; \ D_5C
	DB	078H,018H,018H,018H,018H,018H,078H,000H ; ] D_5D
	DB	010H,038H,06CH,0C6H,000H,000H,000H,000H ; ^ D_5E
	DB	000H,000H,000H,000H,000H,000H,000H,0FFH ; _ D_5F
	DB	030H,030H,018H,000H,000H,000H,000H,000H ; ` D_60
	DB	000H,000H,078H,00CH,07CH,0CCH,076H,000H ; A D_61
	DB	0E0H,060H,060H,07CH,066H,066H,0DCH,000H ; B D_62
	DB	000H,000H,078H,0CCH,0C0H,0CCH,078H,000H ; C D_63
	DB	01CH,00CH,00CH,07CH,0CCH,0CCH,076H,000H ; D D_64
	DB	000H,000H,078H,0CCH,0FCH,0C0H,078H,000H ; E D_65
	DB	038H,06CH,060H,0F0H,060H,060H,0F0H,000H ; F D_66
	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,0F8H ; G D_67
	DB	0E0H,060H,06CH,076H,066H,066H,0E6H,000H ; H D_68
	DB	030H,000H,070H,030H,030H,030H,078H,000H ; I D_69
	DB	00CH,000H,00CH,00CH,00CH,0CCH,0CCH,078H ; J D_6A
	DB	0E0H,060H,066H,06CH,078H,06CH,0E6H,000H ; K D_6B
	DB	070H,030H,030H,030H,030H,030H,078H,000H ; L D_6C
	DB	000H,000H,0CCH,0FEH,0FEH,0D6H,0C6H,000H ; M D_6D
	DB	000H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ; N D_6E
	DB	000H,000H,078H,0CCH,0CCH,0CCH,078H,000H ; O D_6F
	DB	000H,000H,0DCH,066H,066H,07CH,060H,0F0H ; P D_70
	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,01EH ; Q D_71
	DB	000H,000H,0DCH,076H,066H,060H,0F0H,000H ; R D_72
	DB	000H,000H,07CH,0C0H,078H,00CH,0F8H,000H ; S D_73
	DB	010H,030H,07CH,030H,030H,034H,018H,000H ; T D_74
	DB	000H,000H,0CCH,0CCH,0CCH,0CCH,076H,000H ; U D_75
	DB	000H,000H,0CCH,0CCH,0CCH,078H,030H,000H ; V D_76
	DB	000H,000H,0C6H,0D6H,0FEH,0FEH,06CH,000H ; W D_77
	DB	000H,000H,0C6H,06CH,038H,06CH,0C6H,000H ; X D_78
	DB	000H,000H,0CCH,0CCH,0CCH,07CH,00CH,0F8H ; Y D_79
	DB	000H,000H,0FCH,098H,030H,064H,0FCH,000H ; Z D_7A
	DB	01CH,030H,030H,0E0H,030H,030H,01CH,000H ; { D_7B
	DB	018H,018H,018H,000H,018H,018H,018H,000H ; | D_7C
	DB	0E0H,030H,030H,01CH,030H,030H,0E0H,000H ; } D_7D
	DB	076H,0DCH,000H,000H,000H,000H,000H,000H ; ~ D_7E
	DB	000H,010H,038H,06CH,0C6H,0C6H,0FEH,000H ; DELTA D_7F
	
;---------------------------------------------------------------------
; DISK_BASE
;	THIS IS THE SET OF PARAMETERS REQUIRED FOR DISKETTE OPERATION.
;	THEY ARE POINTED AT BY THE DATE VARIABLE DISK_POINTER.
;	TO MODIFY THE PARAMETERS, BUILD ANOTHER PARAMETER BLOCK AND
;	POINT DISK_POINTER TO IT.
;---------------------------------------------------------------------
DISK_BASE:
	DB	11001111B	;SRT=C, HD UNLOAD=OF - 1ST SPECIFY BYTE
	DB	2		;HD LOAD=1, MODE=DMA - 2ND SPECIFY BYTE
	DB	37	;WAIT AFTER OPN TIL MOTOR OFF
	DB	2		;512 BYTES/SECTOR
	DB	8		;EOT (LAST SECTOR ON TRACK)
	DB	02AH		;GAP LENGTH
	DB	0FFH		;DTL
	DB	050H		;GAP LENGTH FOR FORMAT
	DB	0F6H		;FILL BYTE FOR FORMAT
	DB	25		;HEAD SETTLE TIME (MILLISECONDS)
	DB	4		;MOTOR START TIME (1/8 SECONDS)
	
;--------------------------------------------------
;   POWER ON RESET VECTOR  AT FFFF:0000 = F000:FFF0
;--------------------------------------------------
	ORG 0FFF0H
;	JMP	RESET
		DB	0EAH		; HARD CODE JUMP
		DW	START		; OFFSET
		DW	0F000H		; SEGMENT
	DB	'11/08/82'		; RELEASE MARKER PC XT
	DB	0FFH
	DB	0FEH			; ID FOR THIS PC (PC XT)
;	DB	028H			; LAST BYTE CAN'T BE PROCESSED